程序员的层次
不同公司或人有自己的划分标准，但大体上可以分为以下几类:
第一层 菜鸟
第二层 大虾
熟练使用C/C++，STL，数据结构，掌握一点网络编程，多线程编程的基础知识，对面向对象，开发环境和测试，版本控制，代码质量等有基本的认识，经过2~3年的努力，一般人都可以达到，但是他们依然经常被一些疑难杂症给困扰。我就是！
第三层 牛人
了解C++编译器的原理和实现机制，了解操作系统中的内部机制如内存管理、进程和线程的管理机制，了解处理器的基础知识和代码优化的方法，此外还需要更深入地学习更多的数据结构与算法，掌握更深入的测试和调试知识以及质量管理和控制方法，对各种设计方法有更好的理解等。
看的专业书会更多，学习开源项目，掌握各种实战经验和技巧。
在国内，这样的牛人就可以进许多大公司了，他们运气好可以当个“架构师”。
第四层 大牛
知道怎么写操作系统，怎么写编译器，会实现TCP/IP的底层实现，至少实现得像模像样。
这是一个例子，你不必会上面这些，但当下热门技术的思想原理，你能熟悉并运用自如，那这就比牛人 牛，比如实现一个像TBB多核库一样的东西，或者写一个类似Apache一样的服务器，或者写一个数据库等。
第五层 专家
做基础研究的人，“非数值”的计算。
多核计算，云计算，软件需求、设计、测试、调试、评估、质量控制、软件工程等，甚至芯片硬件设计也同样牵涉到非数值计算。
第六层 学者
创新，温故知新，research。
第七层 大师
用创新解决问题的人
你如果能象Hoare一样设计出一个快速排序的算法；或者象Eugene W. Myers一样设计出了一个用编辑图的最短路径模型来解决diff问题的算法；或者象M.J.D. Powell一样提出了一个能够处理非线性规划问题的SQP方法；或者你发现基于比较的排序算法，它的复杂度下界为O(NLogN)；或者你发现用栈可以 将递归的算法变成非递归的；或者你设计出一个红黑树或者AVL树之类的查找结构；或者你设计出一个象C++或Java一样的语言；或者你发明了 UML；...

时间
粗略估计时间
DWORD dwBegin = GetTickCount();
//执行代码
DWORD dwElapsed = GetTickCount() – dwBegin;
printf(“%d.03%d second\n”, dwElapsed / 1000, dwElapsed % 1000);

精确的时间估计
#include <windows.h>
 LARGE_INTEGER nFreq;
    LARGE_INTEGER nBeginTime;
    LARGE_INTEGER nEndTime;
    double time;
QueryPerformanceFrequency(&nFreq);   //每秒多少次计数
     QueryPerformanceCounter(&nBeginTime); //当前计数次数
     //代码
     QueryPerformanceCounter(&nEndTime);
     time=(double)(nEndTime.QuadPart-nBeginTime.QuadPart)/(double)nFreq.QuadPart;


CString  CTime转换
CString   s("2001-8-29   19:06:23");   
  int   nYear,   nMonth,   nDate,   nHour,   nMin,   nSec;   
  sscanf(s,   "%d-%d-%d   %d:%d:%d",   &nYear,   &nMonth,   &nDate,   &nHour,   &nMin,   &nSec);   
  CTime   t(nYear,   nMonth,   nDate,   nHour,   nMin,   nSec);

FILETIME和 LARGE_INTEGER
typedef struct _FILETIME {
DWORD dwLowDateTime; /* 低 32 位 */
DWORD dwHighDateTime; /* 高 32 位 */
} FILETIME, *PFILETIME, *LPFILETIME;

typedef   union   _LARGE_INTEGER   {    
          struct   { 
                  DWORD   LowPart;    
                  LONG     HighPart;    
          }; 
          LONGLONG   QuadPart; 
}   LARGE_INTEGER;

例如：
ULARGE_INTEGER ulRelativeStartTime;
	ulRelativeStartTime.QuadPart = (LONGLONG)-(10000000);   //-1的表示
	FILETIME ft;
	ft.dwHighDateTime = ulRelativeStartTime.HighPart;
	ft.dwLowDateTime = ulRelativeStartTime.LowPart;


UTC
UTC世界协调时间 是 0时区的时间
地方时是本地时间
格式是：y m d h min s
1970年1月1日0:0:0开始的秒数，用time_t 表示

#include <alttime.h>  ATL库
afx.h   CString
用CTime CTimeSpan CString 很方便
http://blog.sina.com.cn/s/blog_6163bdeb0100ow3t.html




windows
windows基础
设置开机启动
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp  往这里面放

桌面没有“我的电脑”
右键桌面 –> 个性化 -> 主题 -> 桌面图标

.NET Framework 3.5
一个库，像DirectX 运行库，VC++运行库，Java库等一样， 支持生成 和 运行 下一代应用程序的windows组件；


word点击超链接，提示“XX限制，请联系管理员”；
解决：IE的Internet选项，设置为默认浏览器；
打开注册表，HKEY_CURRENT_USER\Software\Classes\.htm和.html默认值修改为htmlfile；


Dos命令
diskmgmt.msc		磁盘管理器
explorer			资源管理器
taskmgr			任务管理器
control			控制面板
charmap			字符表
eventvwr			事件查看器
mstsc			远程连接
msconfig			系统配置
devmgmt.msc		设备管理器
perfmon			性能监视器
snippingtool		截图
stikynot			便签
calc				计算器
notepad			记事本
write			写字板
winword			Office Word
excel			Office Excel
outlook			Office Outlook
iexplore			IE
mplayer2			播放器
mspaint			画图板
regedit			注册表
compmgmt.msc	计算机管理
gpedit.msc		组策略
mmc			控制台
eudcedit 		造字
cmd				命令提示符
osk				屏幕键盘
journal			日记本
ipconfig			查看ip

查看端口是否被占用
netstat -ano 列出所有端口，在ip：port那
netstat -aon|findstr "49157"  查找49157端口对应的PID
到任务管理器找进程名字，或者tasklist|findstr "2720"  查找是哪个进程使用了



win32编程
win32框架代码
#include <tchar.h>
#include <Windows.h>


//宏
#define WINDOW_WIDTH 800
#define WINDOW_HEIGHT 600
#define WINDOW_TITLE _T("【永不熄灭的游戏开发梦想】GDI程序核心框架")


//全局变量
HDC g_hdc = NULL;

//全局函数声明
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);  //窗口过程
BOOL Game_Init(HWND);//资源初始化
VOID Game_Paint(HWND);//绘图
BOOL Game_CleanUp(HWND);//资源清理


//WinMain函数
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPSTR lpCmdLine, int nShowCmd)
{
	//设计窗口类
	WNDCLASSEX wcex = { 0 };
	wcex.cbSize = sizeof(wcex);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = WndProc;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = hInstance;
	wcex.hIcon = ::LoadIcon(NULL, IDI_APPLICATION);
	wcex.hCursor = ::LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)::GetStockObject(GRAY_BRUSH);
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = _T("ForTheDreamOfGameDevelop");
	
	//注册窗口类
	if (!RegisterClassEx(&wcex))
	{
		return -1;
	}

	//创建窗口
	HWND hwnd = ::CreateWindow(_T("ForTheDreamOfGameDevelop"),
		WINDOW_TITLE,
		WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT, WINDOW_WIDTH, WINDOW_HEIGHT,
		NULL, NULL, hInstance, NULL);

	//移动显示更新窗口
	MoveWindow(hwnd, 250, 80, WINDOW_WIDTH, WINDOW_HEIGHT, TRUE);
	ShowWindow(hwnd, nShowCmd);
	UpdateWindow(hwnd);

	if (!Game_Init(hwnd))
	{
		MessageBox(hwnd, _T("资源初始化失败！"), _T("消息窗口"), 0);
		return -1;
	}

	//消息循环
	MSG msg = { 0 };
	while (msg.message != WM_QUIT)
	{
		if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	//销毁窗口类
	UnregisterClass(_T("ForTheDreamOfGameDevelop"), hInstance);

	return 0;
}




LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;

	switch (message)
	{
	case WM_PAINT:
		g_hdc = BeginPaint(hwnd, &ps);
		Game_Paint(hwnd);
		EndPaint(hwnd, &ps);
		ValidateRect(hwnd, NULL);  //更新客户区
		break;

	case WM_DESTROY:
		Game_CleanUp(hwnd);
		PostQuitMessage(0);
		break;

	default:
		return DefWindowProc(hwnd, message, wParam, lParam);
	}

	return 0;
}

BOOL Game_Init(HWND hwnd)
{
	g_hdc = GetDC(hwnd);
	Game_Paint(hwnd);
	ReleaseDC(hwnd, g_hdc);
	return TRUE;
}

VOID Game_Paint(HWND hwnd)
{

}

BOOL Game_CleanUp(HWND hwnd)
{
	return TRUE;
}

win32程序设计概述
窗口，每个窗口都有窗口消息处理程序，程序运行，系统为进程建立一个“消息队列”，系统感知事件包装成消息投递，win32程序大部分工作就是处理各种消息， 下图为“windows编程模型”，
 

窗口是HWND句柄，就像线程句柄一样，是地址空间中的一块内存，系统分配和管理，有很多数据结构，如：PAINTSTRUCT

GDI，api，数据结构，宏组成的，获取dc后，绘制，笔记：GDI；
win32程序的方方面面都在3个dll，上千个api里，当你遇到一个“新事物”，比如滚动条，你要想到一些东西：窗口，消息，窗口过程，api，系统程序滚动条，这三者是如何协同的。。。；
64位编程，有的api已经被替换了，编译会报错，去找msdn；
资源即数据，存在exe文件中，图标、字符串、菜单、快捷键、对话框、位图。。。；


手册
Window Styles.
WS_BORDER / WS_CAPTION / WS_DISABLED // WS_HSCROLL/
WS_CHILD 不能有menu，与WS_POPUP互斥
WS_GROUP 一帮此属性的窗口可以tab切换
WS_MAXIMIZE 最大化显示 WS_MAXIMIZEBOX 最大化按钮 WS_MINIMIZE
WS_POPUP 、WS_SYSMENU、WS_TABSTOP、WS_SIZEBOX、WS_VISIBLE、
WS_CLIPCHILDREN，使得父窗体在绘制时留出其上的子窗体的位置不去画它，而那片区域留着子窗体去画。
WS_CLIPSIBLINGS，必须用于子窗体，不绘制重叠区域，都是减少重绘的；
WS_DLGFRAME 对话框样式，无标题
WS_OVERLAPPED 标题+边框
WS_OVERLAPPEDWINDOW 标题+边框+系统菜单+最大最小按钮+sizeable边框

WS_EX_ACCEPTFILES 拖拽文件；   
WS_EX_APPWINDOW 把顶层窗口放到任务栏上；
WS_EX_TOOLWINDOW 不显示在任务栏，alt+tab没用，显示一个浮动标题栏
WS_EX_CLIENTEDGE 下沉边框；
WS_EX_WINDOWEDGE 凸起边框；
WS_EX_COMPOSITED  绘制后代采用bottom-to-top painting order using double-buffering，不能有CS_OWNDC，CS_CLASSDC.；
WS_EX_CONTEXTHELP 窗口标题栏有一个问号标记，不和最大或最小风格一起；
WS_EX_CONTROLPARENT 窗口有子窗口，子窗口参与导航（Tab，方向键，键盘记忆）；
WS_EX_LAYERED 分层窗口；
WS_EX_MDICHILD 多文档子窗口
WS_EX_NOACTIVATE 不激活，用户点击都不会成为foreground window ，不会在任务栏显示，用SetActiveWindow或SetForegroundWindow
WS_EX_NOINHERITLAYOUT 不传递布局给子窗口
WS_EX_NOPARENTNOTIFY 子窗口不发送WM_PARENTNOTIFY消息
WS_EX_OVERLAPPEDWINDOW 下沉边框+
WS_EX_PALETTEWINDOW 调色板窗口 ：凸起+工具+ 顶层
WS_EX_RIGHT 右对齐属性，默认左对齐
WS_EX_TOPMOST 在all non-topmost 之上
WS_EX_TRANSPARENT 
。。。


窗口
overlapped  windows 就是标题，sizing，边框，菜单，最小/大按钮等，很Normal的窗口, WS_OVERLAPPEDWINDOW；

pop-up ，WS_POPUP, WS_CAPTION(标题), WS_POPUPWINDOW(bord，menu要WS_CAPTION才看得到)；

child，子窗口，WS_CHILD，必须指定父窗口（overlapped, pop-up, child），子窗口想要OVERLAPPED等特征，必须请求；子窗口忽略menu请求；父窗口移动后，子窗口要重绘客户区；

layered 分层窗口
提升性能，视觉效果，可以有复杂图形，动画和alpha；WS_EX_LAYERED, SetLayeredWindowAttributes or UpdateLayeredWindow 使窗口可见；win 8之前只有顶级窗口支持；
WS_EX_TOPMOST

调试帮助
对话框
先调用主对话框的构造，再调用成员控件的构造，再OnInitDialog，然后是各控件的PreSubclassWindow，再对话框的OnPaint，再控件的OnPaint；


消息
基础
windows程序是基于消息的设计模式，操作系统能捕获所有用户的操作，封装成消息，投递到进程的消息队列中；程序从队列取出消息，并传回给操作系统，由它调用窗口过程处理；
消息分“队列消息”和“非队列消息”，windows为每个线程维护了一个消息队列，::GetMessage()从调用线程取一个消息，而消息是映射窗口的，最终分发到映射的窗口处理函数。
队列消息有：键盘，鼠标，WM_TIMER,WM_PAINT,WM_QUIT等， 非队列：调用API发出的，系统直接发送给窗口过程；
struct MSG{  //系统感知事件包装成消息投递
	HWND;   //消息是哪个窗口的，::DispatchMessage分发到它的窗口过程处理;
	UINT;
	WPARAM;
	LPARAM;
	DWORD time;
	POINT;
}; 
SendMessage(hWnd, nMsg, wParam, lParam);



WM_PAINT
绘制和更新
移动一个窗口覆盖了下面的窗口，然后移开上面的窗口，那下面窗口就要绘制了；
windows内部为每个窗口保存了一个“绘图信息结构”，包含了无效区域（需要绘制的矩形）；



何时发出
窗口的部分显示区域需要绘制。
窗口首次创建（UpdateWindow)；
调整窗口大小；
最小又最大化；
被覆盖的区域暴露；
ScrollWindow/ScrollDC滚动客户区；
InvalidateRect/InvalidateRgn使无效；
ValidateRect使有效；

有时候显示区域被临时覆盖，windows试着保存这个区域以后恢复，但不一定会，所以系统有时会发送下面的WM_PAINT消息：
关闭一个对话框或消息框；
下拉菜单拉回；
显示提示信息；

少数情况，windows总是保存被覆盖的部分：
鼠标指针；
客户区内拖动图标；

无效区域
就是更新区域，PAINTSTRUCT里， P65；



键盘鼠标消息
键盘
windows中，所有键盘按键 被定义为一组通用的“虚拟键码”；  逐梦 P177；
虚拟键码值		16进制		10进制		对应键盘或鼠标
VK_LBUTTON  	01			1			鼠标左键
VK_CANCEL		03			3			Ctrl+Break
VK_0			30			48			0

按键按下  -> 操作系统捕获，封装WM_KEYDOWN等消息，传递虚拟键码等；
WM_CHAR 按下可打印字符时发送，处理控制字符，P221；

WPARAM  虚拟键码/ANSI或UNICODE
LPARAM   按键信息
 
重复次数： 如果你按下很多次，而你的程序来不及处理，会合计在这里；
GetKeyState 和 GetAsyncKeyState(VK_LSHIFT…) 返回负值，表示按下过（之后释放了也算组合键）；

插入字符
P252；


鼠标
LPARAM  LOWORD(x)，HIWORD(y)，(x,y)客户区坐标；
WPARAM : MK_LBUTTON, 按下左键中键右键，MK_SHIFT, MK_CONTROL
if( wParam & MK_LBUTTON)  左键是否按下;

接受双击事件
wcex.style =  xxx | CS_DBLCLKS;

非显示区域鼠标消息
标题、菜单、滚动条等，对应的有10个，左中右按下释放双击 WM_NCXX + WM_NCHITTEST；
wParam： HTXX，如HTCAPTION；
lparam：屏幕坐标；


命中测试消息
WM_NCHITTEST，优先于其它20个鼠标消息，转成其它20个，双击系统菜单关闭程序也是， 这种从消息产生消息的现象很多；
资源管理器中知道鼠标点击了哪个文件， 这叫“命中测试”；


WM_MOUSEWHEEL消息
wParam 低字节和之前一样，高字节120向前滚动，-120向后;


鼠标相关API
SetCursorPos( x,y); 设置光标位置，屏幕坐标;
ClientToScreen(HWND,  __inout  LPPOINT);
ShowCursor()
SetCapture(HWND)  鼠标在窗口外发出的消息 捕获到这个窗口;  ReleaseCapture(); 只有当鼠标在窗口的显示区域按下时才拦截鼠标；
ClipCursor( RECT) 限制鼠标移动区域，屏幕坐标；

GDIdemo11  鼠标控制人物发射子弹；动态背景图；子弹的发射；


WM_KILLFOCUS
窗口失去焦点了；
SetFocus(hWnd);，让窗口得到焦点；
WM_COMMAND
 


GDI 
基础&手册
几百个函数和一些数据结构与宏所组成的整体；
基本内容: 直线和曲线、填充区域、位图、文字、映射模式、图元、路径、裁剪、调色盘打印。。。

DC，设备环境，你要在输出设备（屏幕，打印机等）上绘图，就要先获取到dc，然后在dc里 填充数据结构，输出到设备上；

(HBRUSH)GetSotckObject(WHITE_BRUSH);获取系统预设GDI；
GetTextMetrics 字体信息；
GetSystemMetrics获取系统预设尺寸；



画几何图形
P155；
HPEN  CreatePen(线型，宽，色);  PS_SOLID
HBRUSH  CreateSolidBrush(色); 实色填充;   
CreateHatchBrush 阴影填充;
HGDIOBJ  SelectObject(HDC, HGDIOBJ);  返回原来的;
DeleteObject(HGDIOBJ) 占内存的;

LineTo 从画笔当前点 画到 X 点；
MoveToEx(, LPPOINT); 移动点; LPPOINT  保存上一个点；

Rectangle(); 边框线条 = 当前画笔

映射模式
P162；
坐标变换；

裁剪区域
P189；

文字
TextOut 默认黑色，白刷（背景色），系统字体；
GetTextMetrics;
DrawText(HDC, LPCTSTR, int, LPRECT, UINT格式);  在区域内输出文字；DT_LEFT.。。。
SetTextColor()
SetBkMode(HDC, int(模式));  OPAQUE( 当前背景画刷)  TRANSPARENT(透明)
字体
TTF，安装；
HFONT font = CreateFont(30, 0, 0, 0, 0, 0, 0, 0, GB2312_CHARSET,
		0, 0, 0, 0, _T("锐字逼格锐线体简4.0（原张海山锐线体）"));
SelectObject(g_hdc, font);

	TCHAR* szText1 = _T("hello,world!");
	TCHAR* szText2 = _T("东汉末年分三国，烽火连天不休");
	TCHAR* szText3 = _T("----------大法师•安东尼");

	SetBkMode(g_hdc, TRANSPARENT);
	SetTextColor(g_hdc, RGB(32,32,32));
	TextOut(g_hdc, 50, 50, szText1, (int)_tcslen(szText1));
文字处理API   逐梦P118；

位图
HANDLE  LoadImage(
NULL(磁盘或资源文件加载),
LPCTSTR, 	UINT(类型 IMAGE_BITMAP/CUSOR/ICON ), 宽， 高，
UINT(方式 LR_LOADFROMFILE);

创建内存dc
为什么要内存dc？ CSDN大神的回答：位图由许多像素组成，每个像素都要重绘，于是会不停闪烁；
CreateCompatibleDC
DeleteDC
SelectObjcet 选入位图
BitBlt(HDC目标, x,y, w,h, HDC源, x,y, DWORD 贴图方式)

用PS 制作bmp图片
1）	去网上下 *.png 的素材，或其它格式的，导入PS
2）	修改素材图，制作遮罩图，另存为*.bmp
3）	相关素材的拼接，新建画布

对话框&子控件
对话框


子控件
发送WM_COMMAND给父窗口
LOWORD(wParam)  子窗口ID，HIWORD(wParam)通知码，lParam子窗口句柄；

父窗口发消息给子窗口
BM_SETCHECK，SendMessage(hChild,...);
id = GetDlgCtrlID(hWnd);  h = GetDlgItem(hWnd, id);

窗口子类化
子控件的窗口过程一般在windows内部，GetWindowLong(hWnd, GWL_WNDPROC) 可以获取到地址，SetWindowLong设置一个新的窗口过程，它能让你安装Hoot，截获某些消息，同时将其它消息传递给旧的窗口过程；
滚动条处理tab键：
LRESULT CALLBACK ScrollProc(HWND hwnd, UINT message,
	WPARAM wParam, LPARAM lParam) //
{
	int id = GetWindowLong(hwnd, GWL_ID);
	switch (message)
	{
	case WM_KEYDOWN:
		if (wParam == VK_TAB)
			SetFocus(GetDlgItem(GetParent(hwnd),
			(id + (GetKeyState(VK_SHIFT) < 0 ? 2 : 1)) % 3));
		break;
	case WM_SETFOCUS:
		idFocus = id;
		break;
	}
	return CallWindowProc(OldScroll[id], hwnd, message, wParam, lParam);
}
//设置滚动条的窗口过程
WNDPROC OldScroll[i] = (WNDPROC)SetWindowLong(hwndScroll[i],
				GWL_WNDPROC, (LONG)ScrollProc);



窗口程序添加控制台窗口
void SetupConsole()
{
	if (FALSE == AllocConsole())
	{
		//给调用进程产生一个console窗口，成功TRUE，失败FALSE，一个进程最多一个，多个可共享一个
		return;
	}

	DWORD stds[] = { STD_OUTPUT_HANDLE,STD_INPUT_HANDLE, STD_ERROR_HANDLE };
	FILE* stdfiles[] = { stdout,stdin,stderr };
	int len = sizeof(stds) / sizeof(stds[0]);

	HANDLE h = INVALID_HANDLE_VALUE;
	for (int i = 0; i < len; ++i)
	{
		//使用WriteConsole，ReadConsole等api比较麻烦，所以改用c库方法
		h = GetStdHandle(stds[i]);
		if (INVALID_HANDLE_VALUE != h)
		{
			int ff = _open_osfhandle((intptr_t)h, _O_TEXT); //返回一个文件描述符 3,4,5
			if (-1 != ff)
			{
				FILE* fp = _fdopen(ff, (stds[i] == STD_INPUT_HANDLE) ? "r" : "w"); //打开文件描述符对应的文件指针
				if (fp)
				{
					*(stdfiles[i]) = *fp; //重定向到c库的标准流
					setvbuf(fp, NULL, _IONBF, 0);
				}
			}
		}
	}

	//输入输出一定要另起线程
	printf("hello,world!\n");
}
¬windows核心编程
错误处理
P24；
线程本地存储 机制，线程互不干扰，GetLastError()，winerror.h;
调试时监视“上一个错误代码”，Error Lookup，  P26；
FormatMessage 描述错误；
定义自己的错误码，每个dll都可以有自己的错误代码，方法， P30；
内核对象
winobj，查看所有内核对象类型的列表；
只是一个内存块，操作系统内核管理，安全描述符，引用计数等 共有， 独有的，如进程有ID，优先级，退出码等；文件有偏移量，共享模式，打开模式等，。。。
内核对象的安全性， P55；
任务管理器，查看，选择列，查看进程句柄数,；ProcessExplorer 查看哪些句柄没有关闭， P61；
跨进程共享内核对象，P63；

系统级别
系统版本， P102；
OSVERSIONINFOEX {
    DWORD dwOSVersionInfoSize; 必须sizeof(OSVERSIONINFOEX)初始化
    DWORD dwMajorVersion; 主机系统主版本号
    DWORD dwMinorVersion; 次版本号
    DWORD dwBuildNumber; 构建版本号
    DWORD dwPlatformId; 平台id，VER_PLATFORM_WIN32s
    WCHAR  szCSDVersion[ 128 ];     
    WORD   wServicePackMajor; 最新安装的Service Pack主版本号
    WORD   wServicePackMinor;
    WORD   wSuiteMask;套件掩码，VER_SUITE_SMALLBUSINESS
    BYTE  wProductType; 产品类型，VER_NT_WORKSTATION
    BYTE  wReserved;
} 
OSVERSIONINFOEX ver;
ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
GetVersionEx((LPOSVERSIONINFO)&ver);
win7之后不赞成使用了，因为你还要麻烦地比较版本号，新的API封装了比较：
https://msdn.microsoft.com/en-gb/library/ms724429.aspx
IsWindows8OrGreater()  winow8.1 sdk kit可能要更新，没有win10的判断，


系统信息，GetSystemInfo， P397，注意32位程序在64位机上运行， P399；
SYSTEM_INFO {
    union {
        DWORD dwOemId;          // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture; CPU架构：PROCESSOR_ARCHITECTURE_INTEL x86,没法区分是32位或64位，
            WORD wReserved;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
    DWORD dwPageSize; CPU页面大小,x86和x86-64为4k，IA-64为8k，区别：http://www.cnblogs.com/ZhouL3777/archive/2012/10/17/2728677.html
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;哪些CPU正在活动
    DWORD dwNumberOfProcessors; CPU数
    DWORD dwAllocationGranularity; 分配粒度65535
    WORD wProcessorLevel;
    WORD wProcessorRevision;
};

虚拟内存状态，GlobalMemoryStatus，P405， MEMORYSTATUS中dwAvailVirtual和进程相关，表示所有free区域；

文件版本信息
右键文件-》属性-》详细信息，VS版本资源，
#pragma comment(lib,"version.lib")
typedef struct tagVS_FIXEDFILEINFO {
  DWORD dwFileVersionMS;
  DWORD dwFileVersionLS;
  DWORD dwFileFlagsMask;
  DWORD dwFileFlags; VS_FF_DEBUG
  DWORD dwFileOS; VOS__WINDOWS32
  DWORD dwFileType; VFT_APP
  DWORD dwFileSubtype; VFT2_DRV_DISPLAY
  DWORD dwFileDateMS;
  DWORD dwFileDateLS;
} VS_FIXEDFILEINFO;
BOOL WINAPI VerQueryValue(
  _In_  LPCVOID pBlock, GetFileVersionInfo返回
  _In_  LPCTSTR lpSubBlock, 三种：\检索VS_FIXEDFILEINFO；\VarFileInfo\Translation翻译表；\StringFileInfo\lang-codepage\string-name字符串信息
https://msdn.microsoft.com/en-us/library/ms647464
  _Out_ LPVOID  *lplpBuffer,输出
  _Out_ PUINT   puLen 输出
);
TCHAR fn[MAX_PATH];
	GetModuleFileName(NULL, fn, MAX_PATH);
	DWORD dwLen;
	dwLen = GetFileVersionInfoSize(fn, &dwLen);
	if (dwLen) {
		PBYTE pVer = new BYTE[dwLen];
		if (GetFileVersionInfo(fn, 0, dwLen, pVer)) {
			VS_FIXEDFILEINFO *pVI = NULL;
			if (VerQueryValueW(pVer, (LPCWSTR)"\\", (LPVOID*)&pVI, (PUINT)&dwLen)){
			}
		}
	}

进程
进程结构
exe/dll 是PE文件， 它按一定的格式组织,更详细的文档：http://blog.csdn.net/zfpigpig/article/details/11203249
进程内核对象句柄表;
虚拟地址空间（exe/模块代码和数据，线程堆栈和堆等），笔记：虚拟地址空间；
线程的容器，线程执行代码， 默认创建主线程，每个线程有自己的堆栈；
进程句柄，winmain参数, hInstance, 其实是将exe文件映像加载到虚拟空间的地址，link.exe， P91：查看模块加载的虚拟空间地址；
进程命令行，系统创建进程时传递， P94；
进程环境变量，是地址空间中的一块内存，笔记：环境变量；
进程关联的一组标志：进程关联性，强迫线程在CPU子集上运行；进程错误模式，如何响应严重错误；
进程当前驱动器和目录，系统在内部跟踪记录（环境变量），不提供完整路径时，就在这找。
进程里的线程，笔记：线程；
进程页面表，与页交换文件的 映射管理，写时复制；
进程堆，初始化创建默认堆1M，笔记：堆；
进程的dll,笔记：dll;
进程TLS，笔记：线程TLS；
进程消息队列，系统感知消息（还有系统队列）；

进程虚拟地址空间
结构
32位4G，只是虚拟，要分配物理存储器才能使用；
分区：NULL区  用户模式分区  64KB禁入区  内核模式分区
内核模式分区：操作系统代码，线程调度、内存管理、文件系统、网络、设备驱动等等，所有进程共有；
页面保护属性，P383；

系统创建虚拟地址空间时，可用地址空间大部分是闲置或未分配的，调VirtualAlloc(P418)分配区域（预订）；
预订的起始地址 = 分配粒度 整数倍（64k * n）；
区域大小 = 系统页面 整数倍（4kb/8kb * n）；
系统会预订一些块，如PEB/TEB/线程栈，进程/线程环境块，系统管理，起始地址不一定是；
将物理存储器 映射到 预订的区域，叫做调拨(commit)，始终以页面为单位，VirtualAlloc(P420)，VirtualFree(P425)；


段
每个exe或dll由许多段组成，段有属性：READ,WRITE,EXECUTE,SHARED；
.text 代码
.bss 未初始化的数据
.data 已初始化的数据
.CRT 只读的C运行时数据
.debug 调试信息
.didata 延迟导入的名字表
.edata 导出名字表
.idata 导入名字表
.rdata 只读的运行时数据
.xdata 异常处理表
.reloc 重定位表
.rsrc 资源
.textbss 增量链接选项生成
.tls 线程本地存储
以上是编译器和链接器创建的标准段；

创建自己的段
#pragma data_seg(“mysection”)
LONG g_lXxx = 0;   //初始化的数据才会放到自己的段中
#pragma data_seg()
然后告诉链接器要共享这个段的变量
#pragma comment(linker, “/SECTION:mysection,RWS”) //都不能有空格
报警告：4068，屏蔽了：#pragma warning(disable:4068) #pragma warning (default: 4068)

DumpBin /Headers查看，好像看不到自己的段；

堆
进程要用到内存块时，如，ANSI转Unicode，临时内存，windows函数会用默认堆，多线程是阻塞的，默认堆由进程销毁，HANDLE GetProcessHeap；
为什么要创建额外的堆
1，更有效的内存管理；
2，局部访问；
内存 与 页交换文件的交换是很影响效率的；
3，避免线程同步开销；
分配大块内存时（1M+），不建议用堆；

HANDLE HeapCreate( //标识,0,HEAP_GENERATE_EXCEPTIONS类
                  //初始大小  //最大大小，0为自动增长)
进程维护已分配内存链表 和 闲置内存链表；
PVOID HeapAlloc(h, //标识HEAP_ZERO_MEMORY类， //分配多少字节)
NULL HeapReAlloc，HEAP_ZERO_MEMORY,增大部分清零，HEAP_REALLOC_IN_PLACE_ONLY不要移动内存块；
HeapSize 获取内存块大小
HeapFree
HeapDestroy

低碎片堆
P516；

在C++中使用堆
为什么有了new，还要用堆，堆是一个平台，可以管理内存， P518；

ToolHeap 枚举进程的堆和堆中的内存块， P521；


页交换文件
磁盘上的文件称为 页交换文件, 当今的操作系统与CPU，可以把内存中的一部分保存到页交换文件中，需要的时候 再载入内存，VirtualAlloc其实是从页交换文件中分配的（每个进程的虚拟地址空间都在磁盘上），内存作为磁盘的高速缓存，所以页交换文件也可以叫“物理存储器”；

内存映射文件
把程序位于硬盘上的文件映像（exe或dll），用作地址空间区域对应的物理存储器时，这个文件就叫 内存映射文件；
访问磁盘数据文件，避免I/O操作了，一旦把文件映射到地址空间，好像载入内存一样；
同一台机器不同进程间共享数据，最高效，windows提供很多进程间通信机制，包括RPC、COM、OLE、DDE、windows消息（WM_COPYDATA）、剪贴板、邮件槽、管道、套接字等，底层都是内存映射文件；

使用
1，创建或打开文件内核对象；2，创建文件映射内核对象；3，映射全部或部分文件；4，使用完后，取消映射，关闭两个内核对象
h = CreateFile, 笔记：同步I/O;
NULL CreateFileMapping(h, //安全属性
                     //保护属性,PAGE_READONLY类 可以或上“段“类 SEC_IMAGE映射一个PE文件,SEC_LARGE_PAGES大页面内存，P475
                     //映射文件大小，高32位，对于<4G的文件始终为0，
                     //2个0，以当前文件大小访问，如果要追加数据，就要留有余地
                     //共享用，NULL );
在Process Explorer中，“段“就是内存映射内核对象；
PVOID MapViewOfFile(// hFileMap, //映射属性 FILE_MAP_WRITE类, //映射高32位，//低32， //字节，0表示全部)
注意文件偏移量必须是 分配粒度的 整数倍，这些API参数的地址系统都会向上或向下调整的；
当文件修改时（FILE_MAP_COPY），系统写时复制，线程访问的都是页交换文件中的副本，当调用UnmapViewOfFile后，系统不会把修改写到磁盘上，调用FlushViewOfFile强制写也是写到副本中去，所以要保存修改的内容，要做额外工作；

BOOL UnmapViewOfFile(PVOID);
CloseHandle();
多个进程把同一数据文件映射到多个视图中，数据修改了，系统会更新所有试图，保证数据的一致性；

MapViewOfFileEx 给内存映射文件指定基地址，共享数据时， P489；

以页交换文件为后备存储器的内存映射文件
需要处理临时数据时，不用创建文件，更方便， P492；
稀疏调拨的内存映射文件， P496；


其他
数据对齐
数据的地址 要能整除 它的大小，否则影响CPU处理的性能；
 
虚拟内存状态，GlobalMemoryStatus，P405， MEMORYSTATUS中dwAvailVirtual和进程相关，表示所有free区域；
进程地址空间中，被保存在内存里的页面 称为进程的工作集，psapi.h ， GetProcessMemoryInfo，P408；

地址空间状态，VirtualQuery/Ex，P409；

重置物理存储器
提高性能用的，当系统在找一页free内存页时找到了一个修改过的页面，那系统必须要先把它写到页交换文件中去，这比较慢，而有时候程序只是暂时使用存储器，我们可以这样： VirtualAlloc((PVOID)pnData, sizeof(int), MEM_RESET, PAGE_READWRITE);  pnData下面的int字节不用了， P434，注意系统会适配重置的地址和页面；

地址窗口扩展 AWE
程序需要在内存中保持更多的数据以减少磁盘和内存间的页交换，32位地址空间不够用，windows提供了这项特性；


进程执行过程
系统的加载程序（load.exe），把exe文件映射到进程地址空间后，检查exe中的段，如果有dll，系统调用LoadLibrary加载，dll包含其它dll，系统同样调用，每次调用LoadLibrary，也是内存映射，也会检查段，dll重定位问题，P459（文件映射过程，P491），然后调用C/C++运行库实现的 一个启动函数，启动函数再调用我们的入口点函数，启动函数做的事情有：
 
P89 程序能访问的C/C++运行库全局变量；


同时运行多个进程
P461，进程的虚拟内存只有一个，每个实例的地址空间各有一份， 每个实例的代码页，数据页都映射到虚拟内存；
打开exe，系统计算程序大小（代码和数据的大小），将exe文件的实际内容或称为文件映像作为预订的地址空间，并注明与该区域关联的物理存储器就是exe文件本身（页交换文件也可以是物理存储器）； 
写时复制
同时启动10个记事本
系统映射exe或dll时，先计算有多少页面是可写的（PAGE_READWRITE）,然后预订这么多空间，进程页面表管理着，当其中一个记事本的内容变化时，复制到新页面中去，更新页面表，其它进程不会受到影响；




进程环境变量
每一个进程都有，是地址空间中的一块内存，系统会预订进程环境块（PEB）。
类似这样的：
=::=::\...
varname1=varvalue1\0
varname2=varvalue2\0
varnameX=varvalueX\0
\0

用户登录windows，系统创建shell进程，读取注册表来关联环境字符串：
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment
HKEY_CURRENT_USER\Environment
上面和 “右键-我的电脑-环境变量”一致。
程序修改后 要重新登录后才会生效，要立即生效，处理WM_SETTINGCHANGE，更好的做法是 提供用户界面。
P98  环境变量相关的api


CreateProcess P105
(
LPCTSTR lpApplicationName,  	NULL
LPTSTR lpCommandLine,	  	命令行
LPSECURITY_ATTRIBUTES lpProcessAttributes,
LPSECURITY_ATTRIBUTES lpThreadAttributes,
BOOL bInheritHandles,
DWORD dwCreationFlags,		P109 CREATE_SUSPEND等
LPVOID lpEnvironment,			环境变量块，NULL继承
LPCTSTR lpCurrentDirectory,		当前驱动器和目录，NULL继承
LPSTARTUPINFO lpStartupInfo,	P113，必须初始化
LPPROCESS_INFORMATION  lpProcessInformation
);

子进程
P124；

权限管理
P126
ToolHelp API
作业
一组进程组成“沙盒”。
比如VS，编译的时候，要用CL.EXE，CL.EXE还要加载更多的子进程，当用户要停止构建时，VS必须终止全部进程；
又比如服务器，必须把一组进程当作一个组处理 ，客户端请求数据时，不能让其独占所有资源。
P141

线程
线程
基础
只有一个内核对象和 一个线程栈（函数参数，局部变量，线程消息队列等）；
线程可以访问进程级别的数据（句柄，内存等），代码等；
C/C++代码用 __beginthreadex 
typedef unsigned(__stdcall* PTHREAD_START)(void*);
线程函数声明:
unsigned int __stdcall ThreadFun(PVOID pv){}
使用：
h = (HANDLE)_beginthreadex(..  ThreadFun...)
线程退出，析构，内核对象释放，清理栈，系统维护退出码；

内幕
CreateThread或__beginthreadex创建内核对象（CPU寄存器，退出码等），在进程地址空间中分配堆栈，在堆栈顶端写两个指针（pvParam和pthreadfunc）；
每个线程都有一组CPU寄存器（线程上下文context），CONTEXT结构，它本身保存在内核对象中；
P172;

线程栈
创建线程时预订区域并调拨一些物理存储器，默认1M，link.exe会写入exe或dll的PE文件头中（如果代码中是0）；
自动增长，线程死循环了就会栈溢出，而栈下溢，是取了栈外地址，如 BYTE aBytes[100]; aBytes[1000] = 0;；

线程局部存储区TLS
将一个线程与指定数据关联，如：
新线程分配_tiddata内存块，存在TLS中，线程函数，参数，错误码…都在_tiddata中，TlsSetValue将值与线程关联上；
避免使用全局变量，分析是否可以改为局部变量，函数参数等，TLS将是很好的方法；
进程维护一组正在使用标志：
 
TLS_MINIMUM_AVAILABLE 64， 系统最多分配1000个；
创建线程时，系统分配TLS_MINIMUM_AVAILABLE个PVOID值，并与线程关联；

使用
DWORD/TLS_OUT_OF_INDEXES TleAlloc，系统返回一个可用的索引，dll或exe通常将它保存在全局变量中；
BOOL TlsSetValue(//线程索引， //值)，把值关联线程，索引是没有错误检查的；
PVOID TlsGetValue(//索引)
BOOL TlsFree；
以上完成 99%的工作，剩下 1%，P586；

静态TLS
__declspec(thread)  DWORD gt_time = 0; 将线程与它的启动时间关联， P586；





线程同步
P217
P250

线程池
自己可以创建适应特定情形，windows也提供了一个；
1）	异步调用一个func
2）	每隔一段时间调用一个func
3）	内核对象触发时调用一个func
4）	异步I/O完成时调用一个func
要小心调用，系统创建的资源会一直存在；
我们不用调用CreateThread之类的，系统会管理这个线程池（自动唤醒、创建、销毁线程）；
你不用管理线程池啦！ 只要你给出“回调函数“（业务实现的地方）；
windows线程池
P344

同步设备I/O与异步设备I/O
设备
 
打开上面的设备的方法： P297
INVALID_HANDLE_VALUE CreateFile(//设备名
                             //访问模式：GENERIC_READ类，设备专用类FILE_READ_ATTRIBUTES
                             //共享模式FILE_SHARE_READ类 
                             //指向安全属性的指针
                             //如何创建/打开（多用于文件）  CREATE_NEW类
                            //微调标志，FILE_FLAG_NO_BUFFERING，系统会缓存内容，如果你不需要的话，就要按P301的规则自己处理，可以提高性能；
FILE_FLAG_SEQUENTIAL_SCAN，顺序访问，系统就预读一些缓存，FILE_FLAG_RANDOM_ACCESS，随机访问，不预读，如果经常设置文件指针，就随机访问；
FILE_FLAG_WRITE_THROUGH，文件修改直接写入磁盘，减少数据丢失的可能，系统也会缓存，读取的时候用；
FILE_FLAG_DELETE_ON_CLOSE，FILE_ATTRIBUTE_TEMPORARY配合，临时文件，系统自动删除；
FILE_FLAG_OVERLAPPED，异步访问；
FILE_ATTRIBUTE_NORMAL类只有在创建新文件，且hFileTemplate为NULL时才有用, P303；
                            //用于文件，复制这个参数的微调
);
GetFileType() 返回什么设备 FILE_TYPE_XX；
GetFileSizeEx() 文件逻辑大小
GetCompressedFileSize() 文件在磁盘上的大小（有压缩）
SetFilePoint() 

BOOL WINAPI ReadFile(
  HANDLE       hFile,
LPVOID       lpBuffer, 	/读到这个缓存中
  DWORD        nNumberOfBytesToRead,//读多少字节
  LPDWORD       lpNumberOfBytesRead, //读了多少字节，异步为NULL
  LPOVERLAPPED 		lpOverlapped	//FILE_FLAG_OVERLAPPED异步访问设备
);

FlushFileBuffers() 强制系统将缓存数据写入设备；

异步I/O
线程 发送 异步I/O请求（Read/Write等）， 请求传给设备驱动程序，后者完成实际的I/O操作，而线程继续执行；到某时刻，设备完成了队列中的I/O请求，它必须通知程序已完成，已收到或发生了错误。

typedef struct _OVERLAPPED {   必须初始化
　　DWORD Internal;  驱动程序设置
　　DWORD InternalHigh; 
　　DWORD Offset; 			//文件偏移量
　　DWORD OffsetHigh; 
　　HANDLE hEvent; 		//IO完成端口用到，接收I/O完成通知
　　} OVERLAPPED
一般 派生自己的C++类，存放任何附加信息；
设备驱动 处理I/O请求 不一定是按代码顺序的；
OVERLAPPED是给驱动程序用的，完成之前不要销毁它，每一个I/O请求都要有一个，示例代码中有一个做法： 
完成键 CClientContext 很复杂的类，里面有和设备相关的信息，比如socket。将 扩展的OVERLAPPED 结构 放在里面，这样在每次异步读写的时候，就保证了不销毁；
如果完成键 很简单，那只能 new了；
PIO_OPERATION_DATA pIO = CONTAINING_RECORD(pOverlapped,											IO_OPERATION_DATA,
											overlapped);
这个神奇的宏可以找到 整个结构体地址；

#define   CONTAINING_RECORD(addr,type,field) ((type*)((unsigned char*)addr - (unsigned long)&((type*)0)->field))
    // addr:  结构体中某个成员变量的地址
    // type:  结构体的原型
    // field: 结构体的某个成员(与前面相同)
根据结构体中的某成员的地址来推算出该结构体整体的地址



完成端口模型 P326
HANDLE
WINAPI
CreateIoCompletionPort(  创建并关联
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE ExistingCompletionPort,
    _In_ ULONG_PTR CompletionKey,
    _In_ DWORD NumberOfConcurrentThreads
    );
只创建：CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, dwNumberOfThreads);
dwNumberOfThreads 为0就是 CPU数量， 一般取2 * CPU，但实际是要试验的；
关联：CreateIoCompletionPort(hDevice, hCompletionPort, dwCompletionKey, 0);


I/O完成端口数据结构
设备列表 ：
关联设备会添加
hDevice	dwCompletionKey
CloseHandle(hDevice) 会删除

I/O完成队列：
I/O请求完成、PostQueuedCompletionStatus调用 会添加
dwBytesTransferred  dwCompletionKey  pOverlapped   dwError
端口从 等待线程队列中删除一项 会删除

等待、已释放、已暂停线程队列：
dwThreadId
添加和删除 按字面意思；

BOOL
WINAPI
GetQueuedCompletionStatus(  监听 已完成的 I/O请求
    _In_ HANDLE CompletionPort,
    _Out_ LPDWORD lpNumberOfBytesTransferred,
    _Out_ PULONG_PTR lpCompletionKey,
    _Out_ LPOVERLAPPED * lpOverlapped,
    _In_ DWORD dwMilliseconds
    );
返回TRUE 成功， 失败错误码 P331；
完成键，让你知道是 哪一个设备完成了I/O请求，你可以这样定义：
struct _PER_HANDLE_DATA
{
     SOCKET socket;     //相关的套接字
     SOCKADDR_STORAGE clientAddr;     //客户端的地址
}
在关联的时候，,(ULONG_PTR)perDandleData（要么是常量，要么new）传入 ；
OVERLAP，让你知道 是设备的哪一个I/O请求完成了；
GetQueuedCompletionStatus(
             CompletionPort,                 
             &bytes,                         
             (LPDWORD)&perHandleData,     
             (LPOVERLAPPED*)&perIoData,     
             INFINITE);             

PostQueuedCompletionStatus 提供了一种 线程间通信 的方法；

DLL
概述
dll由一组可供程序使用的独立的函数组成；
link.exe 在链接时 指定/DLL开关， 在DLL文件映像中 保存一些与exe不同的head信息。
调用dll的函数必须将dll映射到进程的地址空间中，进程级的，线程都能调用（线程栈参数变量等），分静态链接和动态链接；
 
 

dll和exe分别维护自己的内存链表，exe无法释放它，要么各自维护，要么让操作系统管理内存；

编写
#ifdef MYAPI
#else
#define MYAPI extern “C” __declspec(dllimport)
//对于导出类 去掉extern “C”，因为编译器会名字改编
#endif

MYAPI int g_nResult; //导出变量
MYAPI int Add(int,int);//导出函数

在dll的每个cpp文件中，必须包含该头文件
#define MYAPI extern “C” __declspec(dllexport)
#include “..h”
//extern “C”告诉编译器不要进行变量名或函数名改编，这样在exe模块中调用dll函数，就能直接写Add调用
int Add(int a,int b){
//…
}

在exe模块中，包含头文件，这时候引用的变量函数类前面是 __declspec(dllimport)，编译器知道要去dll模块中导入，只要在链接的时候提供lib，编译器就知道有这些导出和去哪个dll模块找；

编译器看到__declspec(dllexport)，在lib文件列出了dll导出的符号，只要引用了dll导出的符合，lib是必需的，链接器还会在dll文件嵌入一个导出段（列出变量函数类，还有相对虚拟地址RVA）；
DumpBin.exe –imports查看exe依赖的dll 和dll导出的符号；
/-exports  查看dll的导出符号；
环境变量中没有配 dumpbin.exe所在目录，你可以把dll拷贝到程序目录，然后打开cmd查看；


导入段包含dll的名称，路径会按下面的顺序加载：
1，	exe目录  2，windows系统目录  3，windows目录  4，进程当前目录  5 环境变量

C/C++运行库
每个编译器通常都实现了标准C的超集——C Runtime Libray CRT。C++标准库类似，有IO流和STL等标准，就是平常用的C函数，time_t，STL…这些东西。
VC++编译器提供了实现，同时还有专门给windows设计的函数，还分别实现了DLL和静态库版本。
lib的实现在 libcmt.lib ，libcmtd.lib（C）; libcpmt.lib , libcpmtd.lib（C++）;
dll的实现在MSVCR100.DLL 100是vs2010,，MSVVR100D.DLL ; MSVCP100.DLL（vs2015嵌入MSVCP140.DLL）…
 
分别对应上面4个版本，link.exe会链接它们。
lib是直接copy代码， 会有重复定义问题；
Dependency Walker 工具分析dll。


模块定义文件.def
如果是导入的def文件，那么要在link-》input-》Module Definition File输入，否则无法生成lib，
dependency walker看不到导出的函数，但是dumpbin可以，


调试dll
如果客户程序和dll在一个sln里，则打开dll源文件，客户可以进入dll，



dll高级
动态加载
没有用到lib，exe没有导入表；
虚拟内存地址/NULL  LoadLibrary，搜索规则，任一线程；
LoadLibraryEx( //dll路径，//预留，//标志：0；DON’T_RESOLVE_DLL_REFERENCES, 不要调用DllMain（不载入依赖的dll）；
LOAD_LIBRARY_AS_DATAFILE，一般系统映射时，要检查dll，给不同段保护属性等，额外开销，此标志不需要，可用Ex加载exe读取资源；
LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE，禁止其它应用程序修改dll内容；
LOAD_LIBRARY_AS_IMAGE_RESOURCE，解析dll遍历其PE段时；
LOAD_WITH_ALTERED_SEARCH_PATH，根据传给pszDLLPathName的值，改变搜索算法， P543；

FreeLibrary，FreeLibraryAndExitThread ；
不要混用 LoadLibrary / Ex；

FARPROC GetProcAddress（h，”PCSTR函数名”）
比如有个函数：void DumpModule( HMODULE );
先声明： 
typedef void( CALLBACK * PFN_DUMPMODULE) (HMODULE)
然后获取导出函数：
PFN_DUMPMODULE pfn = (PFN_DUMPMODULE)GetProcAddress(hDll, “DumpModule”);

DLL的入口点函数
执行进程或线程的初始化和清理，由主线程执行，然后再执行启动代码的，收到某个让那个线程去执行；
向导会创建， P549， DllMain（//实例句柄，DialogBox类的用， 
                          //系统调用函数的原因，DLL_PROCESS_ATTACH，系统第一次将dll映射到地址空间时，调用DllMain，之后不会，引用计数为0了还会调，返回TRUE；
DLL_PROCESS_DETACH，撤销映射，引用计数0，清理；
                          //fImpLoad非0，静态， 0，动态；
DLL_THREAD_ATTACH，创建线程时，调用每个dll的DllMain（dll是进程级的，要让每个线程知道），然后线程函数，主线程不会收到；2种情况：映射新dll时，已运行的线程不会收到消息；创建新线程时，dll已经被映射，系统会调用入口；
DLL_THREAD_DETACH，解除线程与dll的连接；

避免在DllMain调用LoadLibrary（Ex）,会循环依赖；避免调用其他dll导入的函数（库），因为其他dll可能还没初始化；不要创建全局或static C++对象，调构造函数了；应该只执行例如，设置TLS，创建内核对象，打开文件，创建堆等；
DllMain是序列化调用的（一个完才能下一个，死锁）；

DllMain 与 c/c++运行库
入口嵌入到dll映像中，运行库提供了默认的DllMain，调用了DisableThreadLibraryCalls，不关心X_THREAD_X 消息，提升创建和销毁线程的性能；

延迟载入DLL
静态链接，只有引用dll符号时系统才载入dll， 这在下面的情况下很有用：1， 程序使用了多个dll， 映射它们（初始化）可能会比较慢， 2，我们使用了一个函数，但老版本的操作系统没有这个函数，然后报错，延迟加载可以解决；
初始化的时候，系统不会检查dll是否存在， 当程序无法找到dll时，__delayLoadHelper2抛出异常，SHE处理，否则进程终止，当程序找不到dll中的函数时，同样；

局限性：1，导出了全局变量的dll不能，2，Kernel32.dll 不能， 3，DllMain中不能调用一个延迟载入的函数

使用
#include<Delayimp.h>
/Lib：DelayImp.lib (属性Advanced)
/DelayLoad: MyDll.dll(属性Input)  //无法用#pragma comment，还有/DELAY
/Lib告诉linker将__delayLoadHelper2嵌入exe中，/DelayLoad告诉linker，1，从dll中去掉导入段，2，在exe嵌入一个新的延迟载入段，.didata表示导入哪些函数，3，对函数的调用都跳转到__ delayLoadHelper2完成对函数的解析（调用LoadLibrary和GetProcAddress等）；

卸载
/Delay:unload(属性 Advances) 嵌入一个卸载段，重置调用过的函数，如果没有指定，则__FUnloadDelayLoadedDll2什么也不做，返回FALSE；
__FUnloadDelayLoadedDll2，引用卸载段，重置函数地址，然后调FreeLibrary；
注意dll名字和/DelayLoad要一样；

挂钩函数
当__delayLoadHelper2执行的时候，我们可以提供挂钩函数，它们可以接收__delayLoadHelper2的进度通知和错误通知，还可以改变载入dll以及得到函数虚拟地址的方式， P563；
DependencyWalker工具，可以看依赖关系，静态，延迟，运行时对LoadLibrary/GetProcAddress的调用等；

两个异常码：VcppException( ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND) 和 ERROR_PROC_NOT_FOUND，异常过滤函数DelayLoad Dll Exception Filter检查异常码，不是这2个返回EXCEPTION_CONTINUE_SEARCH，是的话， __delayLoadHelper2提供一个DelayLoadInfo*  P561；

函数转发器
function forwarder是dll导出段一个条目，Kernel32.dll中有：
CloseThreadpoolTo ( forwarded to NTDLL.TpReleaseToCompletion)
意思是调用CloseThreadpoolTo其实会调用NTDLL.dll中的函数；
使用
#pragma comment( linker, “/export:SomeFunc_1=SomeDll_1.SomeOtherFunc_1”); 每个转发函数一条；
已知的dll
系统会在特殊目录查找，保存在注册表里，会去掉.dll后缀， P569；

DLL重定向
方便系统定位和共享多个应用程序所共享的模块，早期集中放在系统目录中，后来微软改为 加载程序先检查程序目录，在目录中放一个AppName.local目录，如：SuperApp.exe.local，LoadLibrary(Ex) 能轻易找到它，也可以建立文件夹，把dll放进去；
对已注册的COM对象很有用；
如果没开启，修改注册表， P572；

模块基地址重定位
嵌入文件中的，exe和dll都有嵌入默认基地址，如果相同了，就要重定位，linker嵌入重定位段（字节偏移量列表，如果dll载入到首选基地址，系统就不会访问该段，这是最好的），没有载入的话，loader必须遍历重定位段并修改模块大量代码（性能杀手），而且是写时复制！这意味系统要在页交换和内存之间切换；
如果想创建一个不包含重定位信息的映像，可以指定链接开关/SUBSYSTEM:WINDOWS, 5.0或CONSOLE, 5.0, P575， 这可以显著提高性能；
VS提供了Rebase工具（cmd模式），帮你模拟出所有dll最佳的基地址，不过要等到你的程序构建的后期， P577；


模块绑定
进一步提高性能,假设dll已经重定位好了,引用各符号时,地址都是正确的, 而当loader将导入符号地址写入exe导入段时（dll符号地址还要在exe中重定位，汗！）, 还要进行页交换文件和内存的切换（性能杀手）;
VS工具bind.exe（cmd模式）， P579， 它会将dll重定位后的符号地址写进exe，而不是让loader在加载程序的时候执行；
绑定系统dll时由于用户系统版本不同，绑定失败；

dll注入和api拦截
将一个dll注入到另一个进程的地址空间中；
注册表注入，不建议；
windows挂钩注入， P592；
远程线程注入，P606;
木马dll注入， P614；
用CreateProcess注入代码， P614；

API拦截
比如拦截ExitProcess函数，让它执行我们的代码，然后再执行它；
覆盖代码拦截，不建议；
修改模块的导入段符号地址来拦截API ， P617；

结构化异常
概念
Structured exception handling，SEH，让我们写代码时集中精力完成正常工作，如果运行时出现什么问题，系统会捕获并通知我们，分离功能编写和软件异常；
编译器产生特殊代码，以及一些数据结构表，还有给系统的回调函数, 它和c++不同，SEH利用了编译器和windows操作系统SEH功能；
SEH包含两方面功能：终止处理， 异常处理；

下面都是VC++编译器的
终止处理
__try{ // 保护代码 }
__finally{ // 终止代码 }
不管代码如何退出（return，goto，异常。。），除非调用ExitProcess，ExitThread，TerminateProcess，TerminateThread，终止代码都会被调用，__finally会在return之前调用，__finally之后的代码不会调用；
经验：在try-finally块中移除return，continue，break，goto等语句，把它们放在块的外面，这样编译器可以生成更小的代码；
一个很实用的例子，P645;
__try { if(//错误) __leave; }
__finally { //if(//哪个错误) //清理代码 }

__finally调用的原因：
正常流程
局部展开：从try块提前退出的；
全局展开：异常；
AbnormalTermination 判断， P646；

异常处理
概念
CPU捕获硬件异常抛出，如除0，操作系统和应用程序抛出的异常称为软件异常， 当硬件或软件抛出异常时，系统会定位到except块，并对异常过滤程序的表达式求值；
__try{  }
__except(//异常类型){  }
try块不能同时有finally和except块，但可以嵌套；

GetExceptionCode，内在函数（只能在异常过滤程序或异常处理程序中，不能在异常过滤函数里调），返回刚刚发生的异常类型，预定义异常标识符，EXCEPTION_ACCESS_VIOLATION类， P667；

异常发生，系统将向发生异常的线程压入三个结构：EXCEPTION_RECORD 异常信息, CONTEXT , EXCEPTION_POINTERS 指向上面2个结构的指针，
PEXCEPTION_POINTERS  GetExceptionInformation()，只能在异常过滤程序中调用，结构会销毁， P672；

异常过滤程序的返回值
__except( 异常过滤程序 )
EXCEPTION_EXECUTE_HANDLER 告诉系统，我知道有这个异常，有代码处理的，让它执行吧，全局展开，执行完从except块后继续；
EXCEPTION_EXECUTE_SEARCH 系统在调用栈中向上查找带except块的try，并调用它的异常过滤程序；
EXCEPTION_CONTINUE_EXECUTION 系统将程序跳转到发生异常的那条指令，谨慎使用，汇编级问题，配合VirtualAlloc，P655；
函数（返回上面三个中的一个），异常过滤程序要简单；

系统处理异常的过程
 

全局展开，P661 代码，异常-》找except，直到找到或没有，执行finally（展开），再执行except代码， 如果finally中return了，except代码不执行，停止全局展开；
避免在finally中return；


软件异常
函数“错误”了，抛出异常，有时会 比一层一层的错误判断更容易编写和维护；
异常捕获处理机制和 硬件异常完全一样；

抛出异常
硬件异常由CPU等抛出；
软件异常，如HeapXX等函数指定HEAP_GENERATE_EXCEPTIONS标记，当调用失败时抛出异常，P675；
还可以用 RaiseException(// 异常标志，windows错误代码格式，  //0或者EXCEPTION_NONCONTINUABLE， //附加信息， //附加信息
);

处理一个异常的时候又发生一个异常， P676；

未处理的异常
上次安装的回调  SetUnhandledExceptionFilter(//回调); 处理异常的最后机会，初始化的时候指定，任意线程抛出未处理异常，都会执行回调；
每个线程是这样写的：
__try { ExitThread((pfnStartAddr)(pvParam)); }
__except( 
UnhandledExceptionFilter(GetExceptionInformation())){ //..}

UnhandledExceptionFilter执行过程
P681；
允许对资源写入并继续执行 返回X_X_EXECUTION
将未处理异常报告给调试器 返回X_X_SEARCH
通知我们设置的全局异常过滤函数 如果是X_X_HANDLER或X_X_EXECUTION，直接给系统，如果是X_X_SEARCH，发送通知给WER（windows错误报告），这个通知是由高级本地过程调用ALPC机制发出的（系统来做， P684）；
再次报告调试器
终止进程




书签&总结
P689， 目录P21
 
windows网络编程
概述
网络结构
网络network 由 结点node 和 链路组成。结点：计算机、集线器、交换机或路由器等。
 
因特网Internet是世界上最大的互联网（还有其他把主机互连的网络），而且主机要安装许多使计算机能够交换信息的软件才行。
 
主机是因特网的边缘部分，传送数据、音视频，资源共享等，网络（结点和链路）和路由器等为边缘提供服务，构成了因特网的核心部分，
主机又叫“端系统”，个人电脑、掌上电脑、大型计算机等，拥有者可以是个人、单位（学校企业政府机关等）、ISP等，端系统之间的通信指的就是“主机A上的某个进程与主机B上的某个进程通信”，

ISP
1985年，美国国家科学基金会NSF围绕六个大型计算机中心建设计算机网络，分为主干网、地区网和校园网。1993年，美国政府将主干网交给私人公司经营，出现ISP（因特网服务提供者）。
ISP从因特网管理机构申请到多个IP地址，同时拥有通信线路，路由器等设备。
机构和个人只要交纳费用，即可获得IP地址，接入因特网。
 
上网就是指“通过某个ISP接入到因特网”，IP管理机构有偿“批发IP地址”给审查合格的ISP，
 
第一层ISP：国家范围，拥有高速主干网；
第二次ISP：电信等大公司；
第三层ISP：校园、企业、个人；
每一层都是上一层的客户，网络范围更小，
NAP：网络接入点，高效地交换大量因特网流量，因为每一层的网络范围不同，NAP使不同的ISP高效地交换流量，互相通信，
一旦某个用户接入因特网，那加个调制解调器或路由器等设备，他也能够成为一个ISP，？


网络程序结构：
C/S Client/Server，客户知道服务器ip，向其请求；服务器不断运行着，同时处理多个请求，一般要强大的硬件和高级操作系统支持，客户和服务的通信可以是双向的，
B/S Browser/Server，客户端运行浏览器，超文本形式向web服务器发出访问数据库请求，再以超文本形式返回结果。
	P2P peer-to-peer对等连接，不区分client，server，运行同样的软件，可支持大量用户（百万级）同时工作，10.3节？

分组交换
报文message：要发送的整块数据；
分组packet（又称为包）：将报文分成更小的等长数据段，在每个段前加上控制信息组成首部header（包头）即构成分组，分组是因特网中传送的数据单元；
路由器也是计算机，但它是用来转发分组的；
 
一台主机的多个进程与另一台主机的不同进程通信、网络突然出现故障等，路由器有“路由选择协议”，自动寻找其他路径转发，4.5节，



网络分类
广域网WAN，长距离传输，它的交换机链路都是高速链路；
城域网，5~50km，以太网技术，常并入局域网范围；
局域网LAN，1km，学校或企业，多个LAN可以互联；
公用网：电信公司建立的大型网络；
专用网：军队，铁路，电力等；

网络性能指标
速率，100M以太网（100Mb/s），主机在数字信道上传送数据的速率，比特率；
带宽，通信线路单位时间的最高比特率， 100M（100Mb/s）；
吞吐量，实际的传输数据，带宽100M，实际吞吐70M；
时延，发送时延（全部发出去），传播时延（路上），处理时延（处理分组），排队时延（输入/出队列），很重要的指标，编码要考虑的，P20；
时延带宽积，传播时延 * 带宽，第一个比特到达时，发送端已经发送的比特数；
往返时间RTT，发送数据，接收确认；


计算机网络体系
抽象概念，为了统一传输，定义了若干网络层及各种协议；
应用层：为进程提供服务，http，smtp，ftp等等；
运输层：2主机通信，tcp，udp；
网络层：封装运输层数据成 分组或包传送，选择合适的路由；
数据链路层：将分组 组装成帧在两个节点传输；
物理层：底层机器传输，电气特性；
 


以太网
局域网使用；
双绞线+集线器，就是通常说的网线+“路由器”；
网桥，将多个以太网（网段）连接，有转发帧目录；

网络层
概念
 
网络互连中的中间设备，物理层的转发器，链路层的网桥，网络层的路由器，之上的网关；
分组 –》 路由表  -》 目标主机；

IP地址
每个网卡一个IP地址，32位数字，IP地址 = 网络号 + 主机号。
 
128.11.3.31  8位一个点；
网络号全0：本网络， 全1：本机进程通信，主机号全0：本主机，全1：该网络上所有主机， P115，可分配的ip地址与特殊ip地址；
 
一台主机可以有多个ip（网卡），ip是通信的接口，在链路层被打包成MAC地址；
ARP
知道ip地址，如何找到MAC地址；
具体是：每台主机都设有APR高速缓存动态维护ip地址 到 MAC地址的映射表，如果是新加入的主机，ARP进程在局域网上广播一个ARP请求，运行ARP进程的主机见到自己的ip地址，就返回自己的硬件地址，其它主机忽略；
缓存有生存时间，长期不用会删除；
不同网络的主机，只是多了一个路由器，先打包路由器的MAC地址，剩下的交给路由器；

ip数据报的格式
 
P122，各字段含义功能；
ip层转发的流程
路由表记录的是：（目的网络地址，子网掩码，下一跳地址），下一跳就是下一个路由器地址，只有到达最后一个路由器时，才试图向目的主机最终交付；
对特定主机指定一个路由，特定主机路由，对控制，测试，安全问题，排错等很有帮助；
默认路由，主机连在一个小网络上，减少路由表占用空间和搜索路由表的时间：
 
如上，如果报文发给N2，那么会走R1；
整个分组转发算法如下：
1，提取数据报 目的主机ip D，得网络地址N；
2，若路由表中有D的特定主机路由，传给指定下一跳
3，否则就是正常找到达网络N的路由
4，若有默认路由，传给默认路由
5，加入子网掩码后，D都要与它“&”找到N

划分子网
单位内部的事情，外面看起来还是一个网络；
ip地址 = 网络号 + 子网号 + 主机号
数据报仍是根据网络号找到单位的路由器，但此路由器再根据子网号和主机号交付；
 
如何找到子网的网络号呢？
子网掩码
现在因特网都规定必须使用子网掩码，路由表里必须要记录；
 
主机的ip地址 & 子网掩码 = 主机所在的网络地址（可能带子网）；
下面看一下路由过程：
 
H1给H2发报文，H1网络号128.30.33.13 & 255.255.255.128 = 128.30.33.0  ！=  H2，R1查找路由表，目的网络地址和子网掩码， 找到下一跳路由接口；

CIDR
ipv6， P135；

ICMP网际控制报文协议
允许主机或路由报告差错情况和提供有关异常，P141；
差错报告报文：终点不可达、源点抑制、超时、参数问题。。。
询问报文：回送请求或回答、时间戳请求或回答
应用：ping， 测试两个主机之间的连通性，是应用层直接使用网络层，没有通过TCP/UDP；
ping www.baidu.com  主机向百度发送ICMP回送请求报文，如果服务器正常运作且响应这个请求（有的主机为防止恶意攻击会屏蔽这种请求），它就会返回ICMP回送回答报文；
应用：tracert，源到目的 的路径， P143；

IP多播
一对多时时交付，如会议，新闻，股市。。。
 
多播是靠多播路由器实现的， 它有一些识别多播数据报的软件；
局域网具有硬件多播功能，不需要复制数据报；
多播数据报的目的地址 是多播组的标识符，也就是D类地址，将想要加入到这个多播组的主机ip与标识符关联即可，多播数据报不保证全部交付；
有一些多播地址保留， P165；

IGMP网际组管理协议 和 多播路由选择协议
 
多播数据报不会发送给R4，但它怎么知道R4没有多播组的成员呢？
IGMP让连接在本地局域网上的多播路由器知道 本局域网上的成员情况；
多播路由协议，有多个；

虚拟专用网络VPN
很多情况下，机构内部分配ip作为本地地址，但是偶尔要连外网，而机构分配的ip和外网某个ip冲突了，为解决这个问题，出现了标准：专用ip地址：
10.0.0.0 ~ 10.255. 255. 255、172.16.0.0 ~ 172.31. 255. 255、192.168.0.0 ~ 192.168.255.255  
因特网所有路由器，对目的地址是专用地址的数据报一律不转发；

有时候机构部门在相距很远的地方，两个专用网要通信，怎么办？
租用电信公司的通信线路，简单但太贵；
使用VPN
在每个场所购买专门的硬件和软件并配置；
 
同一个机构 ：内联网，有时候需要外部机构参与，外联网，都基于tcp/ip协议；
有的机构是流动人员，他们要加入公司的电话会议，远程接入VPN，通过拨号接入；
如果本地地址的主机想联网了（不是加密和专用），申请ip是不容易的，可以采用网络地址转换NAT：在路由器上安装NAT软件，NAT路由器，它至少有一个全球ip；

运输层
概念
网络边缘部分的主机 才会用到， 网络核心部分只用到下三层；
 
 
两个主要的协议
TCP传输控制协议
UDP 用户数据报协议
 
复用和分用
运输层到ip层，打个首部就叫复用， ip层到运输层解析，叫分用；
端口
用来标识进程的，数据报交付到这里即可；
分类
系统端口号，0~1023，www.iana.org可查；
登记端口号，1024~49151，必须在IANA登记；
客户端使用端口号，~65535；

UDP
无连接，无释放，减少开销和时延，应用层传下来的报文，udp添加首部后就向下交付，报文太长，ip层要分片，降低效率，太短，ip数据报首部太多，降低效率；
没有拥塞控制，所以源主机的发送速率不会降低；
支持n对n的交互通信；
首部
 
udp分用发现端口号不对，就丢弃该报文；
伪首部只是计算校验和的，P185；

TCP
面向连接，点对点的，可靠交付：无差错、不丢失、不重复、按序到达，基于流，有发送和接收缓存，根据拥堵情况，发送字节流；
socket = ip地址 ： 端口号；
每一条tcp连接 唯一地 = （socket1，socket2）= （ip1：port1， ip2：port2）；
 
序号：2^32-1后又回到0，流的每个字节都按顺序编号，字段含义是报文第一个字节的序号；
确认号：A发送了501，200字节，B接收了全部数据，B期望收到A的下一个数据序号是701；
数据偏移：tcp首部长度（选项最多40字节）；
URG：紧急，不按顺序排队；
ACK确认：为1时，确认号有效，tcp规定都是1；
PSH推送：为1时，立即处理响应，不再等待整个缓存填满再交付；
RST复位：为1时，tcp出现差错，要重新连接；
SYN同步：SYN=1，ACK=0，连接请求报文，SYN=1，ACK=1，同意连接；
FIN终止：为1时，释放连接；
窗口：从确认号开始，现在允许对方发送的数据量，动态变化；
紧急指针：URG=1时有效，指出本报文中紧急数据的字节数（后面是普通数据）；
选项：P196;
tcp可靠传输的实现
以字节为单位的滑动窗口
 
发送/接收窗口都是 缓存中的一部分，循环移动；
窗口中有准备发送的数据，也有发送但未收到确认的数据，有未按序到达的数据。。。
出现差错的，如滞留在网络中的确认等， 超时重发；
流量控制
让发送方的发送速率不要太快，要让接收方来得及接收；
利用窗口值控制；

tcp的连接和释放
 
为什么客户端还要发送一次？
防止已失效的连接请求（延时到达）突然又传送到了B，如果不这样，那就建立连接了，但A此时并没有建立连接，B却要与A通信，浪费资源；
 
tcp有限状态机
粗实线client正常变迁，虚线server正常变迁，细实线，异常变迁；

 
应用层
概念
套接字
 

域名系统DNS
域名对应ip，找到ip的一种机制；
层次树状结构，联机分布式数据库系统，DNS使大多数名字都在本地解析，域名服务器分布在因特网上专设的节点上；
 
各级域名由其上一级域名管理机构管理，顶级域名由ICANN管理，现在已有265个，三大类，.cn , .us地理，  .com公司 .net网络服务机构, .org非营利组织；
二级域名由国家自行确定  .net  .com  .org 。。。；
http://www.cnnic.net.cn/ 中国互联网网络信息中心；
域名服务器管辖的范围叫区zone，区<=域；
 
根域名服务器
只要本地无法解析，首先要求助于它，一共有13个这样的装置 [a-m].rootservers.net，全世界一共有100多个根域名服务器，中国有3个；
顶级域名服务器
管理所有二级域名；
权限域名服务器
负责一个区的域名服务器；
本地域名服务器
一个ISP，大学甚至一个系都可以有一个，右键属性里有；
解析过程
DNS会把数据复制到几个DNS来保存，一个是主DNS，其他都是辅助DNS，这样主DNS瘫痪时也不影响查询，更改只在主DNS；
主机向本地DNS查询ip，找到返回，没有，本地DNS服务向其他 根DNS服务发送请求，根DNS要么返回ip，要么告诉本地DNS“下一步向哪个DNS查询（一般告诉顶级DNS ip）”，本地DNS向顶级DNS发报文， 一样， 顶级要么返回ip，要么告诉权限DNS；
 
都是8个UDP报文，有高速缓存；

文件传输协议FTP
不管是基于TCP的FTP还是UDP的TFTP，都是复制整个文件；
文件共享协议允许联机访问，而它是由操作系统提供服务的，这个服务访问远程文件就如同访问本地文件一样；
FTP工作原理
克服上百种计算机产商研制的文件系统差异；
一个主进程，打开21端口监听，启动从属进程处理client请求；
 
控制进程有控制信息， 带外传送的；
TFTP介绍，P234；

远程终端协议Telnet
tcp连接远程的主机，telnet能将用户的键盘鼠标消息传给远程主机，同时将远程主机的输出结果通过tcp返回；
client运行telnet客户进程，远程也运行telnent服务进程；

万维网 www
用户能够获取大量信息的地方，问题：
怎样标记分布在整个因特网上的万维网文档呢？ URL
用什么协议实现各种链接呢？  HTTP
怎样是不同风格的文档统一显示呢？ HTML
怎样使用户方便找到所需的信息呢？  浏览器

URL
对资源定位的方法，包括文件目录，文件，文档，图像，声音，链接等等，一般用： <协议>://<主机>:<端口>/<路径>，含义是：web资源是用什么“协议“获取的， 在哪台“主机“（域名）上，后2个可省略，http端口80，省略路径就到主页上；
http://www.tsinghua.edu.cn  主页
http://www.tsinghua.edu.cn/chn/yxsz/index.htm  带路径的页面

HTTP
http定义了浏览器（client端）怎样向服务器请求文档以及服务器怎样返回；
 
 
http/1.1协议 使用了持续连接，就是服务器响应后仍保持一段时间的tcp连接，后续只要文档来自同一个服务器，不会频繁地建立和释放连接，Internet选项-高级 可以去掉；
代理服务器
就是缓存，把最近的一些请求和响应暂存起来，可以在client端，server端，中间系统上；
 

http报文结构
P243;
 
如：Get http://www.tsinghua.edu.cn HTTP/1.1
 
http响应
HTTP/1.1 202 Accepted
 
在服务器上存放用户信息
Cookie能跟踪用户信息，某人浏览使用Cookie的网站，服务器为他产生一个唯一识别码，记录在db中，接着给他一个http响应，首部行设置一个：Set-cookie: 识别码，浏览器会管理Cookie文件，比如添加一行返回的服务器主机和Set-cookie值，当他再次浏览网站时，每条http请求都会带上cookie首部行；

HTML
静态的不用多说，动态生成文档需要服务器运行另一个程序，它处理http请求，并输出文档返回；
 
CGI是一种标准，CGI程序其实是CGI脚本；

电子邮件
 
用户代理就是类似outlook之类的client，SMTP是邮件发送协议，POP3是读取协议；
邮件服务器，因特网上有很多，需要两种协议；
具体介绍，P254；

动态主机配置协议DHCP
协议软件参数化，用参数配置消除不同计算机系统的差异，但要做到自动配置，用DHCP，允许pc加入新的网络，动态获取ip等；
当它在client端运行的时候，机制是这样的：需要ip的主机向DHCP服务器广播报文，服务器在其数据库查找，找不到就分配一个ip并返回，通常一个网络至少有一个DHCP中继代理（路由器，配置了DHCP服务器ip）；
 
DHCP分配给client的ip是临时的，在租用期内可使用，它由服务器决定（报文字段）；
端口67监听，68发送，具体，P265；

网络管理协议SNMP
P267，管理网络设备；

网络安全
概念
截获，中断，篡改，伪造。。。，攻击者观察截获修改流，更多的攻击，P284；
安全控制：加密，安全协议设计，访问控制；
两类密码体制
对称密钥：加密和解密密钥相同，缺点：不够灵活；
公钥
不同的加密和解密密钥，公钥，加密解密算法都是公开的，私钥保密；
密钥产生器生成一对密钥，开销挺大的；
 
数字签名
电子信息的盖章；
 
D虽然是解密，但运算后同样是得到一种密文；
有效性：A的私钥只有A有，一旦私钥泄露，同样可以篡改否认；
截获密文并知道发送者身份的人，都可以查手册获得公钥，然后看到内容；
 
鉴别
验证通信的对方是自己所要通信的对象；
报文鉴别
 
取报文的一段摘要，运算后 打包；
实体鉴别
P292；

密钥分配
私钥：P293；
公钥：认证中心Certification Authority CA，公钥与实体（人或机器）绑定关系，政府或大公司建立；

因特网使用的安全协议
网络层：P297；
运输层
SSL 安全套接层
应用层：
防火墙
自行设置，阻止网络，程序，进入和出去；

音视频协议

无线网络


字节顺序问题
计算机中，IP地址和端口号按“主机字节顺序”表示，有大小头之分；但在网络中，必须是大头表示。
htonl()和htons() host to net long short 主机字节序 转网络字节序
ntohl() ntohs() 网络 转 主机


TCP server 编程
1）	创建套接字，bind()-将服务器绑定到一个已知的地址上。
2）	设置server套接字为监听状态，listen()-等待client的连接。
3）	Server通过accept()接收请求。
4）	收发数据。
TCP client 编程 步骤：
1）	connect() 发出连接请求。
2）	收发数据。


1，不管是client还是server，首先必须加载Windows Sockets动态库。WSAStartup()实现此功能。
相关代码：
	WSAStartup( WORD 准备加载的dll版本，LPWSADATA 输出加载的dll信息); 0成功，失败错误码。
	WORD wVersionReq = MAKEWORD(副版本，主版本低字节);
	If(HIBYTE( wsaData.wVersion) != 2) //wsadata输出希望调用者使用的dll版本、支持的dll最高版本、当前使用的dll版本等
WSACleanup()释放套接字资源。 

2，加载dll后，创建套接字，socket()和WSASocket()实现此功能。
相关代码：
	SOCKET socket( int 协议的地址家族，创建TCP或UDP时，必须是AF_INET,
			int 协议的套接字类型，SOCK_STREAM, SOCK_DGRAM, SOCK_RAM,
			int 协议，套接字有多个数目时，限定一个特殊传输。对于SOCK_STREAM为IPPROTO_TCP或0，SOCK_DGRAM为IPPROTO_UDP或0)
返回句柄和INVAILD_SOCKET
	
3，将套接字绑定到地址（IP地址，端口）上
相关代码：
Int bind( SOCKET, SOCKADDR*, int len); 0成功， SOCKET_ERROR失败。
	
SOCKET s;
	SOCKADDR_IN servAddr; //服务器套接字地址;
	Int nServPort = 5500;
	Int nErrCode;
	servAddr.sin_family = AF_INET;
	servAddr.sin_addr.s_addr = htonl(INADDR_ANY); //任意网络接口; inet_addr(“127.0.0.1
”); 本地IP
	servAddr. sin_port = htons(nServPort);
	//将套接字s绑定到 servAddr上;
	nErrCode = bind(s, (SOCKADDR*)&servAddr, sizeof(servAddr));
	if(SOCKET_ERROR == nErrCode) {}

4，将套接字设置为监听模式，并不阻塞
相关代码：
	int listen( SOCKET, int 等待连接的最大队列长度); 0 SOCKET_ERROR
	最大连接：同时发出3个请求，第4个造成错误。

5，接受连接请求，等待client连接，阻塞
相关代码：
	SOCKET accept(SOCKET,   SOCKADDR* 返回连接主机的地址,  int len); 返回一个新的SOCKET与client通信，而监听套接字仍然用于接受client连接。

6，client连接服务器，如果服务器没有监听，失败
相关代码：
	int connect(SOCKET,   SOCKADDR* 服务器地址,   int len);成功0 失败SOCKET_ERROR。
	connect成功返回后，accept返回。

7，接收数据，client没有send会阻塞，send后recv返回
recv和WSARecv()实现此功能。
相关代码：
	接收的字节数 Int recv(SOCKET ,   char* buf,   int len,   int flag;//0无特殊行为，MSG_PEEK复制到缓冲区，MSG_OOB处理带外数据。)
SOCKET_ERROR错误。

8，发送数据
send和WSASend实现此功能。
相关代码：
	实际发送的字节数或SOCKET_ERROR int send(SOCKET  目标,   char* , int lien,  int flags //0无特殊行为，MSG_DONTROUTE传输层不要将数据路由出去，MSG_OOB数据带外发送)


9，关闭套接字
相关代码：
	int closesocket(SOCKET); 如果在使用，返回WSAENOTSOCK错误。
	int shutdown(SOCKET,   int //SD_RECEIVE不允许在接收数据， SD_SEND不允许再发送，SD_BOTH);


头文件#include <winSock2.h> 库 ws2_32.lib。


UDP套接字编程
1）	server : 创建套接字，绑定，接收数据，关闭
2）	client：创建套接字，发送数据，关闭
不用建立连接。
相关代码：
接收数据字节数和SOCKET_ERROR  int recvfrom(SOCKET, char FAR* buf,   int len,  
int flags,  //0无特殊；MSG_PEEK数据复制到buf，但没有从系统缓冲区删除；MSG_OOB处理带外数据
struct SOCKADDR* from, //返回发送数据的主机地址  int fromlen //sizeof(addr));
会阻塞，等待发送。

	发送数据字节数和SOCKET_ERROR  int sendto(SOCKET, const char* buf,  int  len,  
int flags, //0；MSG_DONTROUTE传输层不要将数据路由出去；MSG_OOB带外发送
		const struct SOCKADDR* to, //接收数据的地址  int tolen);


套接字选项
	成功0和SOCKET_ERROR  int getsockopt(SOCKET,   int level,//选项级别，有SOL_SOCKET, IPPROTO_TCP
		int optname,  char* optval,   int optlen);
相关代码：
	int nBufLen;  int nOptlen = sizeof(nBufLen);
	int errCode = getsockopt(s, SOL_SOCKET,  SO_RCVBUF,  (char*)&nBufLen,,  &nOptlen);

	setsockopt类似。

SOL_SOCKET选项类型：
	SO_ACCEPTCONN		BOOL		套接字处于监听模式
	SO_BROADCAST			BOOL		套接字已设置为广播消息发送
	SO_DEBUG				BOOL		允许输出调试信息
	SO_DONTLINGER		BOOL		禁止SO_LINGER
	SO_DONTROUTE			BOOL		不作出路由选择
	SO_ERROR				int			返回或重设错误代码
	SO_KEEPALIVE			BOOL		会话中发送“保持活动”消息。不小于2小时
	SO_LINGER				struct linger*	设置或获取当前的拖延值
	SO_OOBINLINE			BOOL		带外数据会在普通数据流中返回
	SO_RCVBUF				int			设置或获取接收数据的缓冲区
	SO_REUSEADDR			BOOL		套接字可以与一个正在被使用的地址绑定
	SO_SNDBUF				BOOL		设置或获取发送数据的缓冲区
	SO_TYPE				int			返回套接字类型SOCK_DGRAM等
	SO_SNDTIMEO			int			发送超时
	SO_RCVTIMEO			int			接收超时

Windows Sockets地址结构
3种：1，in_addr为网络地址结构，4字节
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};
	调用inet_ntoa()和inet_add()实现网络地址和“.”地址转换。
	sin_addr.s_addr = Unsigned  long  ulAddr  =  inet_addr(“192.168.1.100”);
	反过来 Char* pAddr = inet_ntoa(*(in_addr*)(&ulAddr));

2，SOCKADDR_IN为socket地址结构
	3，SOCKADDR 可以与SOCKADDR_IN转换。



Visual C++网络模式开发
1，	阻塞模式
调用函数在没有完成操作之前不会立即返回的工作模式，用于少量数据的简单网络程序。
缺点：当希望同时处理大量套接字时，将无从下手。

获取主机地址：gethostname() 和 gethostbyname();
相关代码： 
		LPHOSTENT  hostEntry;
		Char hostname[NAME_MAX_SIZE];
		Gethostname(hostname,  NAME_MAX_SIZE);
		hostEntry = gethostbyname(hostname);

		第二种方法： 
			Unsigned  long addr = inet_addr(“172.20.30.55”);
			hostEntry = gethostbyaddr((char*)&addr,  sizeof(addr),  2);

	struct hostent {  char* name;主机名;  char* alia 别名;  short 地址类型;  short 地址长度;  char*  地址列表 }

代码参考console工程socket 和 socket_client。



2，	非阻塞模式
在处理多连接，数据量不均，时间不定等方面具有优势，但使用有难度。

调API时，不要线程睡眠，而是立即返回错误码。非阻塞会多次调用recv()函数，直到recv()返回成功。

Socket()创建的默认为阻塞模式，ioctlsocket()设置为非阻塞。
相关代码：
		s = socket();
		unsigned  long ul  = 1; //套接字选项;
		ret = ioctlsocket(s,  FIONBIO,  (unsigned long*)&ul);  //设置为非阻塞模式;

	读取数据:
		While(nTotal   !=  NUM_REQUIRED)
		{
			nRead  =  recv(s,  &buf[BUF_SZ -  nBytes],  nLeft,  0);
			if(SOCKET_ERROR == nRead)
			{
				Int err  = WSAGetLastError();
				If(WSAEWOULDBLOCK  == err) //accept，recv，send，connect等都会返回。
					Continue;  //多次调用recv;
				Else  ….
}
}

	不足：while循环，系统开销大，后面会使用套接字的“I/O模型”，异步管理多个套接字。





3，Select模型
同一时间内管理多个套接字。
调用select函数检查当前各个套接字的状态（可读可写），然后调用相应的API完成数据收发。用FD_SET 、FD_ZERO、FD_ISSET、 FD_CLR，
优势和不足：
	Select像一个消息中心，当消息到来时，通知程序收发数据。如接收数据时，第一步调用select等待套接字满足条件，第二步，调用recv接收数据，这和阻塞模式一样，但它可以同时等待多个套接字。




4，WSAAsyncSelect模型
异步I/O模型。调用WSAAsyncSelect注册感兴趣的网络事件，非阻塞的。
当事件发生时，windows窗口接收消息处理（读写，监听，关闭等）。
与select相比：1，WSAAsyncSelect是异步的，注册后立即返回，而select阻塞。
2，发生网络事件时，应用程序得到通知的方式不同。Select是返回，WSAAsyncSelect是消息。
3，	要有窗口。



4，	WSAEventSelect模型
1），异步I/O模型。应用程序得到的通知为事件内核对象，而不是消息。
非阻塞。
注意：1)，多次调WSAEventSelect，后一次覆盖前一次。
2)，注册事件一次写，不要分开注册。
3），一个套接字不要关联多个事件对象。
4)，accept创建的套接字和监听套接字具有相同的属性。
5，第一个FD_WRITE事件后会收到WSAEWOULDBLOCKE，要下一次的FD_WRITE才能将数据发送。


Select，WSAAsyncSelect，WSAEventSelect从收发数据的角度看，都不是异步的，因为recv()等函数仍是阻塞操作。



5，	重叠I/O模型
投递多个I/O请求，完成后通知应用程序。
WSARecv()不阻塞，立即返回，线程继续执行，I/O完成，通知有两种：事件通知和完成例程。
相关函数：WSASocket, WSASend/WSASendTo，WSARecv/WSARecvFrom，WSAIoctrl，AcceptEx
SOCKET s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

int WSARecv(SOCKET,  LPWSABUF , DWORD dwBufCnt,  LPDWORD NumOfBytesRecvd,  LPDWORD flag,  LPWSAOVERLAPPED ,  完成例程)
操作立即完成，返回0；未立即完成，返回WSA_IO_PENDING；完成例程 = NULL，则当I/O完成时，lpOverlapped中的hEvent触发；不为NULL，忽略hEvent，用完成例程。


6，	完成端口模型
有一个socket连接上，关联到完成端口，要传入完成键。
当这个socket有通信时：
1）	服务器发送异步请求，投递到完成端口
需要一个扩展的I/O结构，里面带一个OVERLAPPED，然后填写其它信息，调用
WSASend(s, …, m_IO.overlapped); 这里的这个overlapped不能销毁，因为在
服务线程的 GetQueuedCompletionStatus(hComPort,
									&dwIoSize,
									(LPDWORD) &pClient,
									&lpOverlapped,  这个就是m_IO.overlapped！
								INFINITE);
然后通过一个神奇的宏，CONTAINING_RECORD
    //CONTAINING_RECORD宏的作用就是根据结构体  
    //类型和结构体中成员变量地址和名称则可求出  
    //该变量所在结构体的指针 
如：ABCD *pAbcd = CONTAINING_RECORD( &Abcd.b, ABCD, b );

PER_IO_CONTEXT* pIoContext = CONTAINING_RECORD(lpOverlapped, PER_IO_CONTEXT, m_Overlapped); 
2）	服务器在端口收到客户端发来的请求


创建完成端口
创建服务线程
AcceptEx，并关联端口
收发/处理数据

MyServer.h .cpp
AcceptEx
它也是通过完成端口异步完成的，取消了一个专门的accept线程。
就是要你发送多个AcceptEx调用，守候着，一个好的做法是：
	创建一个事件对象，WSAEventSelect 注册FD_ACCEPT事件，关联监听套接字，如果系统中没有AcceptEx在等待，你就是没有发出足够的AcceptEx；

创建一个socket开销相当高，AcceptEx先建立好socket，WSASocket(…);
把监听socket和完成端口绑定。
mswsock.dll中，我们应该用WSAIoctl 配合SIO_GET_EXTENSION_FUNCTION_POINTER参数来获取函数的指针，然后再调用AcceptEx。
LPFN_ACCEPTEX     m_lpfnAcceptEx;      // AcceptEx函数指针
GUID GuidAcceptEx = WSAID_ACCEPTEX;       // GUID，这个是识别AcceptEx函数必须的
DWORD dwBytes = 0;   
WSAIoctl( 
    m_pListenContext->m_Socket,				//任意有效的socket
    SIO_GET_EXTENSION_FUNCTION_POINTER,  
    &GuidAcceptEx,  
sizeof(GuidAcceptEx),  
    &m_lpfnAcceptEx,  
sizeof(m_lpfnAcceptEx),  
    &dwBytes,  
    NULL,  
    NULL); 
然后就可以通过m_lpfnAcceptEx调用AcceptEx函数了
BOOL AcceptEx (      
SOCKET sListenSocket,  	//监听套接字
SOCKET sAcceptSocket,  	//事先建立好的通信socket
PVOID lpOutputBuffer,  	//接收缓冲区：client的第一组数据；server地址；client地址；
DWORD dwReceiveDataLength, //上面缓冲区大小，为0直接返回，否则等待
DWORD dwLocalAddressLength,  //本地地址信息 sizeof(SOCKADDR_IN)+16
DWORD dwRemoteAddressLength,  //远程地址信息 sizeof(SOCKADDR_IN)+16
LPDWORD lpdwBytesReceived,   //出参
LPOVERLAPPED lpOverlapped  	//重叠结构
); 

m_lpfnGetAcceptExSockAddrs(pIoContext->m_wsaBuf.buf, pIoContext->m_wsaBuf.len - ((sizeof(SOCKADDR_IN)+16)*2),  sizeof(SOCKADDR_IN)+16, sizeof(SOCKADDR_IN)+16, (LPSOCKADDR*)&LocalAddr, &localLen, (LPSOCKADDR*)&ClientAddr, &remoteLen); 

inet_ntoa(ClientAddr->sin_addr) 是客户端IP地址
ntohs(ClientAddr->sin_port) 是客户端连入的端口
inet_ntoa(LocalAddr ->sin_addr) 是本地IP地址
ntohs(LocalAddr ->sin_port) 是本地通讯的端口
pIoContext->m_wsaBuf.buf 是存储客户端发来第一组数据的缓冲区


MFC网络编程
#include <afxsock.h>

AfxSocketInit() 
如果要在线程中使用网络接口，必须在一开始调用。（每一个线程）

带外数据（控制信号）
业务数据：语音、图像、对方的鼠标键盘消息等；数据量大。
控制信号：网络中断了，程序崩溃了等；数据量少，优先级高。


: public CAsyncSocket (异步)
OnAccept()
OnConnect()
OnReceive() 网卡已经收到数据之后调用
OnSend() 系统告诉应用程序当前可以发送数据
异步：基于消息的，初始化（AfxSocketInit，create，listen）之后，就被动等待client的消息了。
同步：一切由应用程序控制，像receive这种会阻塞。


一般用户电脑只有一张网卡，多张可以增加带宽；商业应用的服务器可能有10+的网卡。
netstat 查看网络端口。
工业系统一般不会装太多程序，所以端口少，端口冲突不多。

MFC
MFC简要
mfc源码都在 ...\Microsoft Visual Studio 14.0\VC\atlmfc\src\mfc下，把.cpp拖到sln里，F12即可进入定义，如果找不到，findstr /M “要查找的关键词” ./*.cpp；debug菜单-》选项-》符号-》加载服务器符号；
Hierarchy Chart继承图表
Message Maps(MFC) 消息及其处理函数声明
Attach/Detach/DeleteObject
CXx是对象，HWND是句柄，Attach关联，Detach取消关联，因为对象析构可能把句柄销毁，Attach的对象与句柄放在映射表里，有永久和临时的，
创建的GDI资源，使用完之后一定要释放，不然有资源泄漏，SelectObject(原来的)也是一种释放，


MFC关键技术
RTTI 运行时类型识别 && Dynamic Creation
识别对象的类型，对象的继承体系，实现：afx.h && OBJCORE.CPP；
关键词：CObject、CRuntimeClass、RUNTIME_CLASS、DECLARE_DYNAMIC、IMPLEMENT_DYNAMIC
CObject成员：static  CRuntimeClass classCObject //类的标识
RUNTIME_CLASS //获取类的CRuntimeClass*
为什么能获取到？
class CPerson : public CObject {
DECLARE_DYNAMIC(CPerson)
static const CRuntimeClass class##class_name;
};
IMPLEMENT_DYNAMIC(CPerson,CObject)
AFX_COMDAT const CRuntimeClass class_name::class##class_name = { \
		#class_name, sizeof(class class_name), wSchema, pfnNew, \
			&class_name::_GetBaseClass, NULL, class_init };
在声明类的时候，static就已经初始化好了！

动态创建
DECLARE_DYNCREATE；

模块状态信息
为每个模块维护状态信息，是为了方便运行时管理和查询；
afxstate.cpp  afxtls.cpp
AFX_MODULE_STATE、AFX_MODULE_THREAD_STATE类成员：
CThreadLocal<AFX_MODULE_THREAD_STATE> m_thread;//TLS
AfxGetAppModuleState()系列；

MFC初始化过程
winmain(){
1，获取当前CWinThread和CWinApp（模块状态信息里，全局变量）
2,AfxWinInit，安装钩子WH_MSGFILTER等
3，InitApplication/InitInstance，初始化
4，Run，主线程消息循环
}
在InitInstance，创建了多个窗口，对应多个CWnd对象，那么线程是如何创建窗口的呢？
窗口大多是继承自CWnd的类，必然调用Create创建窗口（CFrameWnd，CDialog等），一路跟踪即可看到注册创建窗口的过程；
向导创建的代码，从ID_FILE_NEW, &CWinApp::OnFileNew创建窗口；
如何将消息分发给对应的CWnd对象的呢？
系统感知事件包装成消息投递到进程的“消息队列”；windows为每个线程维护了一个消息队列，::GetMessage()从调用线程取一个消息，而消息是映射窗口的，最终分发到映射的窗口处理函数。
在“如何创建窗口的呢”我们知道了CreateEx创建窗口，而在CreateEx之前，会安装钩子，修改窗口过程地址为AfxWndProc；
AfxWndProc是程序所有窗口的消息处理函数，它的作用就是找到CWnd，然后调用pWnd->WindowProc分发；
如何处理消息？


程序入口点-》WINMAIN.CPP
CWinThread –》 THRDCODE.CPP
AfxWinInit-》APPINIT.CPP
InitApplication-》APPCORE.CPP
CWnd-》WINCORE.CPP
CFrameWnd-》WINFRM.CPP / CMDIChildWnd-》WINMDI.CPP / CSingleDocTemplate-》docsingl.cpp / CDocManager。。。
OnCmdMsg-》cmdtarg.cpp

钩子
一个问题，P190：调用CreateWindowEx时，窗口函数已经开始接受消息了，如：WM_CREATE等，而如何在窗口函数接受到任何消息之前改变窗口函数地址呢？
概念
应用程序为线程安装钩子函数，监视系统中的消息传输，在特定消息到达目的线程之前，钩子函数可以截获它们，监视的窗口可以是其他进程的；
钩子是系统级别的，多个钩子函数组成钩子链，钩子使系统变慢；
P324
HHOOK hHook = ::SetWindowsHookEx(WH_CBT,  HookProc, ...);
WH_CBT
深入浅出，P432，实例；

挂钩API技术
P331


Message Mapping 消息映射
WM_CREATE -> OnCreate  一条消息对应一个函数的关系；
如何把映射表记录下来呢？
struct AFX_MSGMAP_ENTRY
{
	UINT nMessage;   // windows message
	UINT nCode;      // control code or WM_NOTIFY code
	UINT nID;        // control ID (or 0 for windows messages)
	UINT nLastID;    // used for entries specifying a range of control id's
	UINT_PTR nSig;       // signature type (action) or pointer to message #
	AFX_PMSG pfn;    // 消息处理函数
};
typedef void(CCmdTarget::*AFX_PMSG)(void);//要求所有有消息处理能力的类都要从CCmdTarget继承
private:
static const AFX_MSGMAP_ENTRY _messageEntries[];
.cpp
const AFX_MSGMAP_ENTRY _messageEntries[]={
  {WM_CREATE,0,0,0,0,(AFX_PMSG)CMyWnd::OnCreate}
};

protected:
static const AFX_MSGMAP messageMap;
struct AFX_MSGMAP
{
	const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)(); //基类的消息映射表，如果没有找到处理函数的话，就向上冒泡
	const AFX_MSGMAP_ENTRY* lpEntries;			 //处理函数
};

DECLARE_MESSAGE_MAP()
BEGIN_MESSAGE_MAP(CtestMFCApp, CWinApp)
	ON_COMMAND(ID_HELP, &CWinApp::OnHelp)
END_MESSAGE_MAP()

消息映射宏
ON_WM_
windows消息映射宏，窗口消息，确定的窗口处理函数，但是内部调用了virtual，都在CWnd中，<afxwin.h>查找afx_msg空格；
#define ON_WM_PAINT() \ //消息映射宏都是填充下面的结构
	{ WM_PAINT, 0, 0, 0, AfxSig_vv, \
		(AFX_PMSG)(AFX_PMSGW) \
		(static_cast< void (AFX_MSG_CALL CWnd::*)(void) > ( &ThisClass :: OnPaint)) },

struct AFX_MSGMAP_ENTRY
{
	UINT nMessage;   // windows message
	UINT nCode;      // control code or WM_NOTIFY code
	UINT nID;        // control ID (or 0 for windows messages)
	UINT nLastID;    // used for entries specifying a range of control id's
	UINT_PTR nSig;       // signature type (action) or pointer to message #
	AFX_PMSG pfn;    // 消息处理函数
};

ON_COMMAND
命令消息映射宏，从一个窗口发送到另一个窗口，
#define ON_COMMAND(id, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSigCmd_v, \
		static_cast<AFX_PMSG> (memberFxn) },
ON_COMMAND_RANGE(id, idLast, fcn)

ON_CONTROL
控件通知消息映射宏，标准控件（CStatic，CButton等）发送到其它窗口的消息，
#define ON_CONTROL(wNotifyCode, id, memberFxn) \
	{ WM_COMMAND, (WORD)wNotifyCode, (WORD)id, (WORD)id, AfxSigCmd_v, \
		(static_cast< AFX_PMSG > (memberFxn)) },
#define ON_BN_CLICKED(id, memberFxn) \
	ON_CONTROL(BN_CLICKED, id, memberFxn)

ON_NOTIFY
通知消息映射宏，通用控件（afxcmn.h，(Global
 Scope查看, CComboBoxEx, CHeaderCtrl等)）发送到其它窗口的消息，
#define ON_NOTIFY(wNotifyCode, id, memberFxn) \
	{ WM_NOTIFY, (WORD)(int)wNotifyCode, (WORD)id, (WORD)id, AfxSigNotify_v, \
		(AFX_PMSG) \
		(static_cast< void (AFX_MSG_CALL CCmdTarget::*)(NMHDR*, LRESULT*) > \  //消息处理函数不同
		(memberFxn)) },
typedef struct tagNMHDR
{
    HWND      hwndFrom;//控件句柄
    UINT_PTR  idFrom;//控件id
    UINT      code;         // NM_ code
}   NMHDR;
在commctrl.h中，不同控件对应一个结构，
typedef struct tagNMHEADERA
{
    NMHDR   hdr;//继承
    //附加信息
    int     iItem;
    int     iButton;
    HDITEMA *pitem;
}  NMHEADERA, *LPNMHEADERA;
LPNMHEADERA p = (LPNMHEADERA)pNMHDR;

ON_X_REFLECT
http://blog.csdn.net/bagboy_taobao_com/article/details/6171616
反射消息映射宏，通知消息或控件通知消息，父窗口将其转为反射消息让子窗口先处理，这样就不用在父窗口写那么多子窗口的消息处理了，更模块化；
#define ON_NOTIFY_REFLECT
 (wNotifyCode, memberFxn) \
	{ WM_COMMAND+WM_REFLECT_BASE, (WORD)wNotifyCode, 0, 0, AfxSigCmd_v, \
		(static_cast<AFX_PMSG> (memberFxn)) },
还有一些普通窗口的，
ON_WM_HSCROLL_REFLECT
ON_WM_CTLCOLOR
有些在向导中没有，要积累，如ON_WM_MEASUREITEM_REFLECT()
ON_X_EX
扩展消息映射宏
ON_COMMAND_EX、ON_COMMAND_EX_RANGE、ON_NOTIFY_EX、ON_NOTIFY_EX_RANGE，可以在运行时确定是否向下传递；



Message Routing 消息传递
当系统调用回调，即窗口过程，它封装为CWnd::WindowProc，它会调用OnWndMsg取出消息映射表，找到消息处理。
MFC规定：
1，如果是一般的windows消息，WM_XX，则一定是由派生类流向基类。
2，如果是命令消息WM_COMMAND，则：
  命令接收者	直接处理
MDI frame wnd	激活的子窗口 -> mainframe->CWinApp
  frame wnd或MDIChild	  view->mainframe->CWinApp
  View	        view->Document
  Document	Document->Document Template
  Dialog 	Dialog -> 拥有者 -> CWinApp
    
注意微软的标准控件的通知消息在WM_COMMAND，通用控件的通知消息在WM_NOTIFY；
Persistence 永久保存
写文件，文件格式大致是：
文件大小 容器1元素个数 新类tag 版本 类名长度 嵌套容器1元素个数 元素内容 。。。

Archive与文件相关的缓存区；
CRuntimeClass的Load、Store处理类是否第一次出现，记录版本号，记录文件名等；

MFC框架代码
CWinApp+CFrameWnd
class CMyWinApp : public CWinApp {
public:
	virtual BOOL InitInstance();
};


class CMyFrameWnd : public CFrameWnd {
public:
	CMyFrameWnd();	
};

CMyWinApp theApp;

BOOL CMyWinApp::InitInstance() 
{
	m_pMainWnd = new CMyFrameWnd;
	m_pMainWnd->ShowWindow(m_nCmdShow);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}


CMyFrameWnd::CMyFrameWnd()
{
	Create(NULL, _T("Hello,World"), WS_OVERLAPPEDWINDOW,
		CRect(CPoint(rectDefault.left,rectDefault.top),CSize(500,500)), NULL);
}


Document Template的意义
1，一份Document对象——数据
2，一份View对象——显示
3，一份CMDIChildWnd对象——外边框
每打开一份文件，就有这三个对象，它们就是文档模板。


MFC鼠标拖放
用户从shell拖放一个文件到程序A，shell配置一块全局内存，填入路径+名称，然后发出WM_DROPFILES到A的消息队列。
窗口风格 WS_EX_ACCEPTFILES。
P343
m_pMainWnd->DragAcceptFiles(TRUE);  允许主窗口及每一个子窗口接受shell的拖放文件。CFrameWnd的OnDropFiles 处理WM_DROPFILES消息。
CWinApp::EnableShellOpen() shell下双击文件
CWinApp::RegisterShellFileTypes() 注册文件类型，不能横刀夺爱。

MFC容器
CArray，CList，CMap，CTypedPtrArray，CTypedPtrList，CTypedPtrMap

CARRAY<TYPE,TYPE>
Add添加元素，SetSize会预定义n个元素；
Append追加数组、Copy复制数组
FreeExtra释放未使用的内存
GetCount返回元素个数
Type* GetData返回首元素地址、GetUpperBound最大索引（比个数少1）
InsertAt 在索引处插入n个元素/插入一个数组（索引<0会dump）
IsEmpty、RemoveAll移除所有、RemoveAt在索引移除n个
SetAt设置索引处的值、SetAtGrow索引不存在自动增长
SetSize设置数组包含元素（频繁的重新分配和复制是低效的），用Add继续追加；
Type& operator[]
CDWordArray是CArray<DWORD>；
CPtrArray 是 void*对象；
CObArray 是 继承自CObject的对象；
同理CList、CMap等也是；

CLIST<TYPE,TYPE>
AddHead头部添加、AddTail尾部
POSITION Find(TYPE, POSITION) 从n开始搜索值
POSITION FindIndex(INT_PTR) 返回索引位置，list有索引
Type& GetAt(POSITION) 、GetCount
Type& GetHead、POSITION GetHeadPosition
Type& GetNext、GetPrev、GetTail、GetTailPosition
POSITION InsertAfter、InsertBefore
IsEmpty、RemoveAll、RemoveAt、RemoveHead、RemoveTail
SetAt 设置位置的值


CMAP<TYPE,TYPE,TYPE,TYPE>
CMapPtrToPtr 保存void指针，关键字为其它void指针
CMapWordToOb 保存CObject指针，关键字为WORD  
…
CMap::Cpair 键值对
GetCount
GetNextAssoc(POSITION, KEY&, VALUE&) 获取下个元素  GetStartPosition
BOOL Lookup(KEY, VALUE&)  查找元素
CMyMap::CPair* PGetFirstAssoc()  、PGetNextAssoc(CPair*)、CPair* PLookup(KEY)
RemoveAll、RemoveKey
SetAt、operator[]

CTYPEDPTRARRAY<BASS_CLASS, TYPE>，CTYPEDPTRLIST<BASS_CLASS, TYPE>，
CTYPEDPTRMAP<BASS_CLASS, KEY, VALUE>
CTypedPtrList<CObList, CPerson*>  m_list;  ->  它和 CObList 里放CPerson*对象是一样的，但是前者类型安全的；
typedef CTypedPtrMap<CMapWordToOb, int, CTestClass*>  CMyTypedMap;   
-> //error！要用WORD！类型不匹配会出奇怪的值；
成员和基本型一样用；

考虑使用mfc容器时，还要考虑：
1，	是否需要type-safe; 
2，	是否要序列化，一般CObXX的可以，CPtr的不可以；
3，	是否要有dump，CObXX的有；

遍历MAP
	POSITION pos = mapInt.GetStartPosition();
	WORD iKey = -1;
	CTestClass* ptVal = nullptr;
	while ( pos != nullptr )
	{
		mapInt.GetNextAssoc(pos, iKey, ptVal);
		TRACE(_T("\t[%d],[%s]\n"), iKey, ptVal->GetName());
	}


状态栏
MFC为状态栏提供了CStatusBar类，封装了状态栏的属性和操作。
Create  MainFrm.cpp OnCreate()

BOOL SetIndicators(const UINT* lpIDArray, int nIDCount);
用lpIDArray数组中的对应元素为每个指示器设置一个ID，然后加载每个ID代表的字符串

UINT GetItemID(int nIndex) const; 
获取由nIndex指定的指示器的ID

CString GetPaneText(int nIndex) const;
获取状态栏窗格中显示的文本。

BOOL SetPaneText(int nIndex, LPCTSTR lpszNewText, BOOL bUpdate = TRUE);
设置状态栏窗格的显示文本。

if(....)
m_wndStatusBar.SetPaneText(4, strTime);   



MFC内存检测
来自 ：http://blog.csdn.net/netanimals/article/details/7454820
1，	
在stdafx.h头文件中添加两行代码
//内存泄露检测
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>  #include <stdlib.h>
2，	
如果程序有多个退出点，要在程序开始的地方调用：
_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);  InitInstance();
在你的程序结束时调用_CrtDumpMemoryLeaks；
全局类的析构。。。

报告格式：
c:\users\dmxjmao\documents\visual studio 2015\projects\testmfcm\testmfcm\testmfcm.cpp(216) : {136} normal block at 0x01703290, 4 bytes long.
 Data: <  o > D0 9C 6F 01
文件位置（分配内存时的行号）：
{ 内存分配编号（第几次分配）} 
内存块类型（普通、客户端、CRT），
内存地址，
内存块大小，
前16字节内容；

如何定位内存泄露位置
1，根据内存分配编号设置断点
long _CrtSetBreakAlloc( long lBreakAlloc );
在内存分配编号处断点，条件是下次启动分配编号不变，
也可以在运行时设置，先查看程序使用的C运行库版本：Propertise -> C/C++ -> Code Generation -> Runtime Library，如果是/MTd则为静态链接，在Watch窗口name输入_crtBreakAlloc，value输入编号，若为/MDd动态链接，则输入{,,msvcrNN（版本号）d.dll}_crtBreakAlloc，
控制面板可以查看自己的系统上的运行库版本：Microsoft Visual C++ 2008 Redistribute- XXXX，win10设置-》应用也可以看，
使用Dependency Walker查看程序使用的运行库版本，发现vs2015使用MSVCP140D.DLL，
但是我输入：{,,msvcp140d.dll}_crtBreakAlloc，Value：_crtBreakAlloc is undefined，日，
只能自己添加代码了，我在InitInstance 添加了_crtBreakAlloc = 226;但是注意有的泄露不在CWinApp里，其他地方也要写，配合调用堆栈，反正多少有点用，


2，比较内存状态
_CrtMemState s1,s2,s3;
	_CrtMemCheckpoint(&s1);
//逻辑代码
_CrtMemCheckpoint(&s2);
	_CrtMemDifference(&s3, &s1, &s2);
	_CrtMemDumpStatistics(&s3);

[Output]窗口生成报告
0 bytes in 0 Free Blocks.
324 bytes in 3 Normal Blocks.
0 bytes in 0 CRT Blocks.
0 bytes in 0 Ignore Blocks.
0 bytes in 0 Client Blocks.
Largest number used: 0 bytes.
Total allocations: 324 bytes.


3，自己写一句int* a = new int;看它的分配编号，然后尝试找，


可以自己封装一个类
成员：
Enable 启用检测
SetNo  设置编号




MFC时间
UTC
UTC世界协调时间 是 0时区的时间
地方时是本地时间
格式是：y m d h min s
1970年1月1日0:0:0开始的秒数，用time_t 表示

文件时间
CFileTime : public FILETIME
CFileTimeSpan
FILETIME和 LARGE_INTEGER
typedef struct _FILETIME {
DWORD dwLowDateTime; /* 低 32 位 */
DWORD dwHighDateTime; /* 高 32 位 */
} FILETIME, *PFILETIME, *LPFILETIME;

typedef   union   _LARGE_INTEGER   {    
          struct   { 
                  DWORD   LowPart;    
                  LONG     HighPart;    
          }; 
          LONGLONG   QuadPart; 
}   LARGE_INTEGER;

CTime CTimespan 。
CString s = t.Format(_T("%A, %B %d, %Y"));
%a 缩写星期 %A 全写 %b缩写月 %B
%c locale日期和时间
%d 01-31号
%H 00-23点
%I 01-12点
%j 000-366天
%m 01-12月
%M 00-59分
%p A.M/P.M
%S 00-59秒
%W 00-53周（周一是一周的第一天） %U 00-53周（周日是第一天）
%w 0-6天（周日是0）
%x locale日期
%X locale时间
%y 00-99年  %Y 1999年
%#c  "Tuesday, March 14, 1995, 12:41:29".
其它加# 会去前导0.


CPOINT、CRECT、CIZE
构造  SIZE, POINT, 32位
Offset 偏移
operator+/-/+=…

CRect
构造 x,y  SIZE  2个POINT， 一个POINT一个SIZE，基础类型
DeflateRect 缩小 InflateRect 扩大
IntersectRect 去2个矩形交集 SubtractRect  UnionRect
BottomRight …矩形位置
PtInRect 点是否在内部
IsRectEmpty 判断
NormalizeRect 规范化

CSize 封装了SIZE



CImageList
管理大量icon或bmp。
Add，Remove, Replace，Attach一个列表（HIMAGELIST）给CImageList管理
Copy，Create，Detach（C++类对象有析构，但是我们有时并不希望HANDLE类的被销毁）
FromHandle 返回一个新的CIageList* ，如果没有CIageList附加给成员，创建一个临时的
FromHandlePermanent 同上，只是返回null。  DeleteTempMap 删除FromHandle创建的临时对象。
GetSafeHandle 返回成员
Read,Write 序列化
绘制图像 Draw系列。
拖动图像列表Drag系列。。
在控件中的使用。
用ps，icon插件安装，打开icon看模式几位的，新建32*n，位数相同，分辨率72px的图，拖入图标，窗口-》信息面板，小三角选项看宽高，全选粘贴过去，保存未bmp，24位； 
加载bitmap
m_imgList.Create(16,16,ILC_COLOR24,3,1);  //用这种方法指定颜色位数！
CBitmap bmp;
bmp.LoadBitmapW(IDB_comboxEx);
m_imgList.Add(&bmp, RGB(0,0,0));




MFC重绘
简要
子控件的窗口过程一般在windows内部，SetWindowLong可以设置；

控件大多是放在父窗口内的，构造函数会依次构造子控件，但是有些代码不能在构造函数内，因为控件还没创建出来，所以可以：
class 父{ DrawDlg(  Init(  控件.Init();  );  );  }   
Init内容为界面的默认UI，重绘要大多提供修改UI配置的方法；

Custom Draw
回调的一种，windows在绘制控件的过程中，会发消息给你，NM_XX（LVN_XX是控件通知父窗口），你可以选择忽略所有通知，或处理部分，或全部（Owner-Draw）；
绘制分两部分：擦除和绘画，每部分的开始和结束都会发送NM_CUSTOMDRAW；
NM_CUSTOMDRAW 结构；


背景色
对话框初始化完毕，显示窗口时按顺序调用OnSize()>OnEraseBkgnd()>OnPaint()>OnCtlColor();
OnEraseBkgnd(), 用窗口类中注册的Brush绘制背景
BOOL CMainWindow::OnEraseBkgnd(CDC* pDC)  
{   
 CRect rc;  
 GetClientRect(&rc);  
 pDC->FillSolidRect(&rc ,  RGB(0,0,255)  );   
 //return CFrameWnd::OnEraseBkgnd(pDC);   
 return TRUE;  
} 

BOOL CMainWindow::PreCreateWindow(CREATESTRUCT& cs)
{
	if (CFrameWnd::PreCreateWindow(cs))
	{
		//改变窗口类   
		WNDCLASS   wndclass;

		::GetClassInfo(AfxGetInstanceHandle(), cs.lpszClass, &wndclass);
//wndclass.hbrBackground  = (HBRUSH)(COLOR_3DFACE +   1);    
//wndclass.hbrBackground=(HBRUSH)GetStockObject(BLACK_BRUSH);   
wndclass.hbrBackground = CreateSolidBrush(RGB(0, 100, 100));
		wndclass.hbrBackground = m_BKBrush;//m_BKBrush不能为函数局部变量   
wndclass.hbrBackground = *(new CBrush(RGB(25, 25, 0)));//最方便的方法   
												//wndclass.hCursor   =   AfxGetApp()-> LoadCursor(IDC_CURSOR1);    
		wndclass.lpszClassName = _T("newViewClassName ");
		VERIFY(AfxRegisterClass(&wndclass));
		cs.lpszClass = wndclass.lpszClassName;
		return TRUE;
	}
	return FALSE;
}

自绘控件模板
#pragma once
#include "utility.h"/uicfg类，笔记：UI正则

class CMyListCtrl1 : public CListCtrl, public CUICfg
{
	//方法
    DECLARE_MESSAGE_MAP()
public:
	CMyListCtrl1();
	bool Init();
protected:
private:
	//属性
public:
protected:
private:
	virtual bool regex_callback(const boost::smatch& what);//ui正则回调
};

#include "stdafx.h"
#include "listctrl_test1.h"


BEGIN_MESSAGE_MAP(CMyListCtrl1, CListCtrl)
END_MESSAGE_MAP()

CMyListCtrl1::CMyListCtrl1()
{

}

bool CMyListCtrl1::Init()
{
	return true;
}

bool CMyListCtrl1::regex_callback(const boost::smatch& what)
{
	return true;
}



MFC GDI
CDC基类，CClientDC、CWindowDC、CPaintDC，与HDC是一一对应的；
api分类
设置视区，窗体范围和坐标；
坐标变换；
绘图模式；
绘制图形；
输出字符；

GDI对象
CPen、CBrush、CFont、CBitmap、CRgn；
CBrush
主要是填充用的；
CreateSolidBrush(颜色)实体画刷、CreateHatchBrush虚线、CreateBrushIndirect(LOGBRUSH*)结构、CreatePatternBrush(CBitmap*)位图、CreateDIBPatternBrush设备无关位图DIB、CreateSysColorBrush系统预定义颜色


CFont
BOOL CreateFont(
    int nHeight,  字体高度
    int nWidth,  0
    int nEscapement移位向量与设备x轴夹角,  
    int nOrientation, 每个字符与设备x轴夹角  
    int nWeight,  粗细 FW_BOLD
    BYTE bItalic,  是否倾斜
    BYTE bUnderline,  下划线
    BYTE cStrikeOut,  删除线
    BYTE nCharSet,  字符集GB2312_CHARSET
    BYTE nOutPrecision,  如何选择合适字体OUT_DEFAULT_PRECIS
    BYTE nClipPrecision,  裁剪精度CLIP_DEFAULT_PRECIS
    BYTE nQuality,  品质DEFAULT_QUALITY
    BYTE nPitchAndFamily,间距和属性  DEFAULT_PITCH | FF_SWISS
    LPCTSTR lpszFacename);字体名称_T("微软雅黑")
具体可参照LOGFONT
CFont font; font.CreateFont;

LOGFONT lf;
	memset(&lf, 0, sizeof(LOGFONT));
   //GetFont()->GetObject(sizeof(lf), &lf);获取默认
	lf.lfHeight = 20; lf.lfStrikeOut = TRUE;
	_stprintf_s(lf.lfFaceName, _T("%s"), _T("Arial")); //不识别的字体就用默认的
	CFont* font = new CFont; 
	font->CreateFontIndirect(&lf);
m_static_1.SetFont(font); //font必须存在

CFont* font = new CFont;
	font->CreatePointFont(150, _T("abc")); //150点就是15-pix的字高

CFont* pfont = CFont::FromHandle(hfont);//从HFONT转，你也可以传CFont变量，因为定义了operator HFONT()

CRgn
裁剪区域，矩形、多边形、椭圆等组合，可用于裁剪绘制，将它选入dc，就可以限制绘图区域；
CreateRect矩形/Elliptic椭圆/Polygon多边形/RoundRect圆角矩形Rgn；
Offset偏移;SetRectRgn将区域设置为指定矩形；GetRgnBox获取区域矩形
其它一些顾名思义的方法；

CMenu
下拉式：主菜单、子菜单及子菜单中的菜单项，
弹出式：主菜单不可见，只显示子菜单；
下拉相当于 Popup指针，指向SubMenu， SubMenu里有item（项、separator等）；
主菜单和子菜单都是CMenu，要CreateMenu，DestoryMenu销毁菜单资源；
AppendMenu( MF_POPUP 嵌套菜单/ MF_STRING 菜单项);

MFC常用api，宏，结构，原理，操作。。。
SetWindowPos
http://www.cnblogs.com/findumars/p/3948315.html
改变窗口的大小、位置和设置子窗口、弹出窗口或顶层窗口的排列顺序
(const CWnd* pWndInsertAfter,..,UINT nFlags)
hWndInsertAfter HWND，置于hwnd前面的窗口句柄。这个参数必须是窗口的句柄或是下面的值之一
HWND_BOTTOM 将窗口置于其它所有窗口的底部 
HWND_NOTOPMOST 将窗口置于其它所有窗口的顶部，并位于任何最顶部窗口的后面。如果这个窗口非顶部窗口，这个标记对该窗口并不产生影响 
HWND_TOP 将窗口置于它所有窗口的顶部 
HWND_TOPMOST 将窗口置于其它所有窗口的顶部，并位于任何最顶部窗口的前面。即使这个窗口不是活动窗口，也维持最顶部状态
 SWP_NOACTIVATE，SWP_NOMOVE 忽略x,y SWP_NOZORDER SWP_NOSIZE。。。
控件在Create时就指定了ZOrder的顺序，先Create的控件ZOrder值最小（最先响应此控件）,后面绘制的控件Z序增大，覆盖在上面
	//如果调用了SetWindowPos，且第一个参数为NULL，也不指定SWP_NOZORDER属性，则系统会将此控件置顶，此时ZOrder值变为最小，最先响应。

MoveWindow(x,y,cx,cy); 对于top-level，xy相对于屏幕；


windows窗口层次关系
窗口管理器记录了4个数据：子窗口、父窗口、所有者、下一兄弟窗口的 句柄；
windows初始化创建 桌面，在管理器窗口链表第一个元素，是最上层窗口；
桌面下一层就是顶层窗口，它们构成Z序，表示离桌面的距离，WS_EX_TOPMOST创建顶层，顶层之间还有“owner”关系，即指定hWndParent；
子窗口，WS_CHILD，第三层，类似桌面与顶层，都显示在父窗口的客户区，有Z序；

设置tabstop顺序
ctrl+D， 默认给第一个具有tabstop风格的控件；


设置窗体最小最大尺寸
处理ON_WM_GETMINMAXINFO
void Cowndraw_ctrlDlg::OnGetMinMaxInfo(MINMAXINFO* lpMMI)
{	if (lpMMI->ptMinTrackSize.x <= 500)
		lpMMI->ptMinTrackSize.x = 500;
	CDialogEx::OnGetMinMaxInfo(lpMMI);
}

设置控件位置 
注意坐标！客户区大小是比对话框 小的；
enum class RELATIVE_LOC { LEFT_TOP, RIGHT_TOP, LEFT_BOTTOM, RIGHT_BOTTOM };//相对位置

//设置控件位置
//绝对位置：x,y,cx,cy;
#define SetCtrlLocAbsolute(id,x,y,cx,cy) \
{\
	CWnd* pWnd = GetDlgItem(id);\
	if(pWnd){\
		pWnd->SetWindowPos(0, x, y, cx, cy, SWP_NOZORDER | SWP_NOREDRAW);\
	}\
}

//相对控件：idrel相对控件，offx,offy偏移; 
#define SetCtrlLocRelativeCtrl(id,idrel,dir,offx,offy) \
{\
	CWnd* pWnd = GetDlgItem(idrel); \
	if (pWnd) {\
		CRect rcCtrlrel;\
		pWnd->GetWindowRect(&rcCtrlrel);\
		CWnd* pWnd2 = GetDlgItem(id);\
		if (pWnd2) {\
			CRect rcCtrl;\
			pWnd2->GetClientRect(&rcCtrl);\
			int x, y;\
			switch (dir)\
			{\
			case RELATIVE_LOC::LEFT_TOP:\
				x = rcCtrlrel.left - offx - rcCtrl.Width();\
				y = rcCtrlrel.top;\
				break;\
			case RELATIVE_LOC::RIGHT_TOP:\
				x = rcCtrlrel.right + offx;\
				y = rcCtrlrel.top - offy;\
				break;\
			case RELATIVE_LOC::RIGHT_BOTTOM:\
				x = rcCtrlrel.right + offx;\
				y = rcCtrlrel.bottom + offy;\
				break;\
			case RELATIVE_LOC::LEFT_BOTTOM:\
				x = rcCtrlrel.left - offx - rcCtrl.Width();\
				y = rcCtrlrel.bottom + offy;\
				break;\
			}\
			pWnd2->SetWindowPos(0, x, y, rcCtrl.Width(), rcCtrl.Height(), SWP_NOZORDER | SWP_NOREDRAW);\
		}\
	}\
}

//相对对话框：id控件ID，dir：相对，offx偏移量(>0)
#define SetCtrlLocRelativeDlg(id,dir,offx,offy) \
{\
	CWnd* pWnd = GetDlgItem(id);\
	if (pWnd) {\
		CRect rcCtl;\
		pWnd->GetClientRect(&rcCtl);\
		CRect rcDlg;\
		GetClientRect(&rcDlg); \
		int x, y;\
		switch (dir) {\
		case RELATIVE_LOC::LEFT_TOP:\
			x = rcDlg.left + offx;\
			y = offy;\
			break;\
		case RELATIVE_LOC::RIGHT_TOP:\
			x = rcDlg.right - offx - rcCtl.Width();\
			y = offy;\
			break;\
		case RELATIVE_LOC::RIGHT_BOTTOM:\
			x = rcDlg.right - offx - rcCtl.Width();\
			y = rcDlg.bottom - offy - rcCtl.Height();\
			break;\
		case RELATIVE_LOC::LEFT_BOTTOM:\
			x = rcDlg.left + offx;\
			y = rcDlg.bottom - offy - rcCtl.Height();\
			break;\
		}\
		pWnd->SetWindowPos(0, x, y, rcCtl.Width(), rcCtl.Height(), SWP_NOZORDER | SWP_NOREDRAW); \
	}\
}


MFC类介绍
CBasePane (CFrameWndEx 才有)
样式：AFX_CBRS_FLOAT，AFX_CBRS_AUTOHIDE，AFX_CBRS_CLOSE 
AFX_CBRS_AUTO_ROLLUP浮动可以卷起；
AFX_CBRS_REGULAR_TABS ：Pane停靠另一个Pane，配合CTabbedPane；
AFX_CBRS_OUTLOOK_TABS ：Pane停靠另一个Pane，配合CMFCOutlookBar；

AddPane 添加给CDockingManager；CFrameWndEx 成员 CDockingManager  m_dockManager; 管理 main frame的 dock窗口。
Can类，Is类；
DockPane 停靠（Pane停靠另一个Pane，或停靠mainframe）
EnableDocking(CBRS_ALIGN_XX) 
EnableGripper() 拖拽
Save/LoadState 注册表保存/加载状态

概念：Pane，DockSite， MiniFrame，TabbedPane，
CPane : CBasePane
一个加强的CControlBar，不要再用CControlBar了,一般不直接用。
it can be docked in a CDockSite and it can be floated in a CPaneFrameWnd.


CDockablePane : CPane
http://www.codeproject.com/Articles/493218/Understanding-CDockablePane
Mini-frame 包含窗格的浮动窗口。工具栏就是袖珍框架窗口的一个例子。
AttachToTabWnd 会创建tabbed pane； CreateTabbedPane
CreateDefaultPaneDivider 和frame window的分隔条
DockToWindow Docks one to another ；
使用：
继承自CFrameWndEx 
创建类 class CTreePane: public CDockablePane 最好是向导创建，不然你会丢掉一些代码；
OnCreate 和 OnSize 一定要写
	OnCreate创建 Pane里面的控件， OnSize 布局控件；
CTreePane 作为 CMainFrame成员， Create它，然后：
m_treePane->EnableDocking(CBRS_ALIGN_ANY);
	 DockPane(m_treePane, AFX_IDW_DOCKBAR_LEFT);
	m_treePane->ShowPane(TRUE, FALSE, TRUE);

CMFCBaseToolBar : CPane
CMFCToolBar : CMFCBaseToolBar
CMFCToolBarButton是它的item；
类似CToolBar，但是提供额外特性，flat toolbars, toolbars with hot images, large icons, pager buttons, locked toolbars, rebar controls, text under images, background images, and tabbed toolbars，自定义工具栏，drag-and-drop，combo box buttons, edit box buttons, color pickers, and roll-up buttons。
样式：
TBSTYLE_ALTDRAG 按住alt拖拽；
TBSTYLE_FLAT 工具条和按钮都透明，文字图片在下面；
TBSTYLE_LIST 文字在图片右边；
TBSTYLE_TRANSPARENT 工具条透明
TBSTYLE_WRAPABLE 可以多行
TBSTYLE_TOOLTIPS 提示
BTNS_BUTTON、BTNS_AUTOSIZE按钮随图片
BTNS_CHECK 按下，再按下背景不一样 ，BTNS_CHECKGROUP 这个按下那个弹起；BTNS_GROUP 和 BTNS_CHECK组合起来就是 BTNS_CHECKGROUP；
BTNS_DROPDOWN 发送BN_DROPDOWN ，如果有TBSTYLE_EX_DRAWDDARROWS，就会有小箭头，点击小箭头发送BN_DROPDOWN，点击按钮发送WM_COMMAND；
BTNS_NOPREFIX
BTNS_SEP 分割条
BTNS_SHOWTEXT 显示文本，默认以tooltip显示，必须有TBSTYLE_LIST和TBSTYLE_EX_MIXEDBUTTONS；

Create(CBRS_LEFT  ControlBar Styles  对齐/边框/ CBRS_TOOLTIPS/。。)
EnableCustomizeButton 工具条最后的Add or Remove Buttons按钮；
Insert。。   LoadBitmap。。


CMFCMenuBar : public CMFCToolBar

CMFCToolBarButton ：CObject
你在LoadToolBar的时候指定 lock（一般的，它可以被拖拽）；
它的图片来自CMFCToolBar，比如成员CImageList；
如果按钮有ID， toolbar会把点击等消息发送给 frame；

CMFCToolBarMenuButton ：CMFCToolBarButton
构造指定 HMENU；



CMFCCaptionBar
a button, a text label, and a bitmap ，只显示一个。


CMFCRibbonBar

CMFCStatusBar 
比CStatusBar更厉害的选件，显示images, animations, and progress bars，还有相应消息如，单击双击。

CDockSite
就是自动隐藏到边上的那些东西。
CFrameWndEx::EnableDocking  时创建。
CAutoHideDockSite
调用 CFrameWndEx::EnableAutoHidePanes 时创建的。

CPaneDivider


CReBarCtrl
rebar 控件充当子窗口的容器
 
手柄栏、文本标签、组合框。手柄栏。。。



CRichEditCtrl
格式化文本编辑器，还可以包含embedded OLE objects，你需要自己实现一些。
注意AfxInitRichEdit一次，CRichEditView就不用。

CScrollBar
滚动条，msdn的Remarks。

CButton
样式
BS_AUTOCHECKBOX 
BS_AUTO3STATE     第三种是这样的
在onclick处理中，int ck = m_pBtnTest->GetCheck();获取，0（未选中），1（打勾），2（第三）

BS_AUTORADIOBUTTON
一般用在Group里使用。
Ctrl + D，调整Tab键顺序，使一组的顺序挨着；

用向导添加变量，每组只能有一个，可以有一个BOOL m_Radio1 和一个CButton m_btnRadio；m_Radio = -1表示一个都没选，0选了第一个,1，2。。。

BS_COMMANDLINK
 
BS_DEFPUSHBUTTON
普通按钮，带DEF的，你按Enter键就会发送CLICK消息的。

BS_DEFSPLITBUTTON 对话框中按enter，即使没有焦点，也执行它的BN_CLICK
 
分隔按钮
typedef struct {
  UINT       mask; 设置哪些字段有用BCSIF_GLYPH himlGlyph有用
  HIMAGELIST himlGlyph;
  UINT       uSplitStyle;  BCSS_NOSPLIT 
  SIZE       size;  glyph大小
} BUTTON_SPLITINFO, *PBUTTON_SPLITINFO;
split就是那个倒三角，对应字符’6’，9是小三角。
SetSplitGlyph(_T(‘’)); 
 Unicode 特殊字符码表 U+25A0 to U+25FF 
SetSplitInfo()
赋值BUTTON_SPLITINFO。

SetSplitImageList()
设置mask= BCSIF_IMAGE，himlGlyph=图像列表

BS_GROUPBOX 、BS_OWNERDRAW、BS_PUSHBUTTON、BS_RADIOBUTTON、BS_SPLITBUTTON）

CSplitButton
pBtn->Create(g_btnText[t], WS_CHILD | WS_VISIBLE | BS_SPLITBUTTON,
					CRect(0,0,0,0), this, t+100); //风格，区域
spBtn->SetDropDownMenu(IDR_MENU1, 0);
spBtn->MoveWindow(rcEdit.left, rcEdit.bottom + 10, w, h);//布局

CMFCMenuButton
一个pop-up 菜单。
m_hMenu  m_nMenuResult  等。
m_btnMenu.m_bOSMenu = FALSE;  //由框架调用CContextMenuManager::TrackPopupMenu 管理。
按钮单击事件处理m_nMenuResult
Create 。。。
CMenu* pMenu = new CMenu;  注意局部变量弹不出菜单。
pMenu->LoadMenuW(IDR_MENU_MFCMenuButton);
m_btnMenuEdit.m_hMenu = pMenu->GetSubMenu(0)->GetSafeHmenu();
m_btnMenuEdit.SizeToContent();
m_btnMenuEdit.m_bOSMenu = FALSE;
 


CBitmapButton
有4张图，正常，按下，焦点，不可用，后三个可选。
winbtn.cpp , wincore.cpp在CStatic中创建，一开始被遮挡，鼠标放上去才出现；
在window’s客户区创建，略。
在对话框中创建：
m_bmpBtn.Create(_T(""),WS_CHILD|WS_VISIBLE|BS_OWNERDRAW|WS_TABSTOP,
		CRect(100,100,0,0), this, CTRL_TEST_BTN);
	m_bmpBtn.LoadBitmaps(IDB_0, IDB_1, IDB_2, IDB_3); //加载4中状态，后三种可选;
	m_bmpBtn.SizeToContent();//按钮适应图片
m_bmpBtn.ShowWindow(SW_NORMAL);

如果在对话框上拖了一个控件了，可以给它指定一个文本“TEST”，然后import图片，取名“TESTU/D/F/X”，是字符串哦！对应正常，选中，获得焦点，失去焦点（要有BS_TABSTOP）
一定要bmp，ico是不行的！
用处：
只提供前2张图，那么鼠标长按可以看到“隐藏“内容，可能是答案（ps可以做得很复杂）。

作为成员，BS_OWNERDRAW一定要有；

CMFCButton
比CButton多了几个功能：对其文本，同时显示文本和图片，选择光标，提示；
样式可以3D，无边框的；
向导创建的默认是CButton，你可以改掉它；

有一个严重的问题： CMFCButton会失去光泽！
  很难看！
用图片去填会好看一点
 
m_pBtnTest->SetFaceColor(RGB(0, 255, 0));
m_pBtnTest->SetImage(IDB_0);
 
	m_pBtnTest->m_nFlatStyle = CMFCButton::BUTTONSTYLE_NOBORDERS;  //设置没有边框风格
	m_pBtnTest->m_bDrawFocus = FALSE; //设置不要获得焦点的虚线
m_pBtnTest->m_bTopImage = TRUE;  //图片在上

CMFCColorButton
默认打开颜色拾取对话框。
m_colorBtn.Create(…)
m_colorBtn.EnableAutomaticButton(_T("默认"), afxGlobalData.clrBtnText);
m_colorBtn.EnableOtherButton(_T("其它..."));
m_colorBtn.SetColor(RGB(255,0,0));设置当前颜色
m_colorBtn.SetColumnsNumber(5); 设置列
设置最近使用的颜色
CList<COLORREF,COLORREF> colorList;
	colorList.AddTail(RGB(255, 0, 0));
	colorList.AddTail(RGB(0, 255, 0));
	colorList.AddTail(RGB(0, 0, 255));
	m_colorBtn.SetDocumentColors(_T("最近使用"), colorList);
 


CMFCDesktopAlertWndButton
用在屏幕上显示通知事件的用户无模式对话框上的按钮。

CMFCLinkCtrl
超链接按钮，方法很简单。
m_btnLink.Create(_T("abc"), WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,  CRect(10,10,0,0),
this, CTRL_TEST_BTN);
	m_btnLink.SetURL(_T("www.baidu.com"));
	m_btnLink.SizeToContent();




CMFCColorPickerCtrl 一点不实用，不如CMFCColorButton
 
LUMINANCE, PICKER, HEX and HEX_GREYSCALE. The default type is PICKER. 六角和六角灰度；拾取和线性。SetType(CMFCColorPickerCtrl::LUMINANCE);
m_btnColorPick.SetPalette(&m_palSys);  //CPalette m_palSys; 必须有！


CComboBox
三种：Simple（没鸟用），Drop-down（可以编辑），Drop-down list（只能选）。
Combo-Box Styles，CBS_XX，WS_CHILD ,WS_VISIBLE, WS_VSCROLL, WS_HSCROLL, WS_GROUP, WS_TABSTOP…
CBS_AUTOHSCROLL编辑框文字自动滚动，WS_HSCROLL | WS_VSCROLL 下拉框水平滚动，水平滚动不会自己出来 ，下面的方法可以
  循环列表取最长的文本，记录索引；
TEXTMETRIC tm;
	CDC* pDC = m_combo.GetDC();
	pDC->GetTextMetrics(&tm);
	CString str;
	m_combo.GetLBText(maxLenIdx, str);
	len = pDC->GetTextExtent(str).cx;
	len += ::GetSystemMetrics(SM_CXVSCROLL) + 2 * ::GetSystemMetrics(SM_CXEDGE);
	m_combo.SetDroppedWidth(len); 
 

SetMinVisibleItems 设置显示多少个；
Create ，AddString /InsertString/DeleteString，SetCurSel
FindString(-1,..) 从头开始，返回-1是没找到。
SelectString 找到然后选择。
SetEditSel + Copy/Cut/Paste 复制剪切到剪贴板。
Dir(DDL_READWRITE  / DDL_DIRECTORY   …，过滤);
SetCueBanner( 默认的提示字符)
SetItemData/SetItemDataPtr(UINT, void*)  关联32位的值或一个指针；

消息响应仿照 向导的写。


CComboBoxEx
支持图像，CComboBox要CBS_OWNERDRAWFIXED and CBS_HASSTRINGS然后自己绘制，Ex只要提供CImageList，一个Item支持选择，未选择，overlay三种图片。
CreateEx可以带WS_EX样式，如WS_EX_CONTEXTHELP；用SetExtendedStyle. 设置其它样式（基本的三个+WS_CHILD除外），如CBES_EX_CASESENSITIVE。搜索ComboBoxEx Control Extended Styles。

SetImageList、SetItem、COMBOBOXEXITEM
typedef struct {
  UINT    mask; 指定用哪些参数，如CBEIF_IMAGE
  INT_PTR iItem; 索引
  LPTSTR  pszText; 文本
  int     cchTextMax; 文本长度
  int     iImage; image list中的图片索引（0开始）
  int     iSelectedImage;
  int     iOverlay;
  int     iIndent; 缩进 1=10pix
  LPARAM  lParam; 32位值
} COMBOBOXEXITEM, *PCOMBOBOXEXITEM;
	m_imgList.Create(16, 16, ILC_COLOR32, 3, 1);
	m_imgList.Add(AfxGetApp()->LoadIconW(IDI_ICON1));
	m_imgList.Add(AfxGetApp()->LoadIconW(IDI_ICON2));
	m_imgList.Add(AfxGetApp()->LoadIconW(IDI_ICON3));
m_comboxEx.Create(WS_CHILD | CBS_AUTOHSCROLL | CBS_DROPDOWN,
		CRect(10, 10, 100, 10), this, ID_COMBO_1);
	m_comboxEx.SetImageList(&m_imgList);
COMBOBOXEXITEM item = { 0 };
item.mask = CBEIF_IMAGE |
		CBEIF_SELECTEDIMAGE;  //这个一定要有！
m_comboxEx.SetExtendedStyle(0, WS_VSCROLL|WS_VISIBLE); //设置Ex风格
。。。
图像失真问题：
m_imgList.Create(16,16,ILC_COLOR24,3,1);  //用这种方法指定颜色位数！
	CBitmap bmp;
	bmp.LoadBitmapW(IDB_comboxEx);
	m_imgList.Add(&bmp, RGB(0,0,0));

下拉框显示不出来：
m_comboxEx.Create(WS_CHILD | CBS_AUTOHSCROLL | CBS_DROPDOWN,
		CRect(10, 10, 100, 200), this, ID_COMBO_1); //这里200 是自己试出来的
肯定和对话框坐标有关，不过现在不清楚。

这个
	m_comboxEx.SetExtendedStyle(0, WS_VSCROLL| CBS_OWNERDRAWVARIABLE);
	m_comboxEx.SetItemHeight(0, 10);
	m_comboxEx.SetItemHeight(-1, 10);
 


CMFCFontComboBox
 



CDateTimeCtrl
 
      BOOL SetFormat(
   LPCTSTR pstrFormat 
); 用它可以设置 “2016/10/19” 这里的显示。
m_DateTimeCtrl.SetFormat(_T("Today is dd-MMM-yy"));

格式：
d 1-2位的日， dd 2位日  ， ddd星期缩写， dddd全写
h 1-2位12制的小时，  hh 2位12制小时，  H ，HH 同前
m ，mm 分钟 ，  M，MM 月  ，MMM月缩写，MMMM 全写  s,ss秒
tt AM/PM
yy 后两位年，yyyy4位年

错误写法：
m_ctrlDatetime.SetFormat(_T("Today is yyyy - M - d dddd  h:m:s"));
这是给Picker！不是给你显示的。所以秒是不会动的。



CEdit
样式
ES_AUTOHSCROLL、ES_CENTER、ES_LOWERCASE、ES_NUMBER、ES_PASSWORD、ES_READONLY、
ES_MULTILINE 默认单行
ES_NOHIDESEL 默认 是失去焦点，选择丢失
ES_WANTRETURN 按enter输入回车符，否则就像点了ok按钮一样
代码修改多行样式不行，不知道是不是重载了OnOK，改属性可以；

其他
按enter或esc退出对话框
按下enter，windows自动找输入焦点的按钮执行，如果都没有，那OnOK函数也会自动调用，你可以重载对话框的OnOK为空函数，esc就是OnCancel；
但是edit还是不能回车，打开类向导，输入控件ID，原来edit不会响应WM_CHAR消息，只有EN_CHANGE，但是enter是不激发该消息的，edit也是窗口，能收到WM_CHAR消息，可能是Translate和Dispatch掉了，我们可以在PreTranslateMessage处拦截；

用Get/SetWindowText获取文本，’\r\n’是换行GetLine获取一行；
默认可以撤销一次操作，可以copy，cut，paste；

HLOCAL h = m_myEdit.GetHandle();
LPCTSTR lpszText = (LPCTSTR) ::LocalLock(h);
//操作文本，对话框必须有DS_LOCALEDIT样式；
::LocalUnlock(h);
你可以用GetHandle，把一块内存块设置进去，避免\r\n；

LineFromChar(int)   字符 所在的行，-1 当前行
LineIndex(n)  第n行的第一个字符索引，\r\n算两个，第一个字符索引为0；
LineFromChar(n) LineIndex的逆过程；
LineLength(n) 第n个字符所在行的长度；

注意\r\n ， 它算两个字符；


CMFCEditBrowseCtrl 
多一个“Browse”按钮，自定义dlg，标准filedialog，标准folderdialog。
自定义dlg：继承， 重写CMFCEditBrowseCtrl::OnBrowse。
EnableFolderBrowseButton, EnableFileBrowseButton, or EnableBrowseButton 显示按钮。
SetBrowseButtonImage 设置按钮图片。
 

EnableFolderBrowseButton崩溃问题
将你的程序继承自 CWinAppEx；

继承CMFCEditBrowseCtrl，重写OnBrowse，和 OnDrawBrowseButton ，可以让你有更灵活的功能和界面。


CMFCMaskedEdit
4步走：
void EnableMask(
   LPCTSTR lpszMask,  格式_T(" ddd  ddd dddd")
   LPCTSTR lpszInputTemplate, 模板_T("(___) ___-____") ，’_’代替
   TCHAR chMaskInputTemplate=_T('_'),
   LPCTSTR lpszValid=NULL  有效字符
);
m_editMask.SetValidChars(NULL);
m_editMask.SetWindowText(_T("(123) 123-1212"));
GetWindowText();


设置格式化的输入：
D 数字， d 数字+空格，+ ‘+’/’-‘/空格，
C字符，c字符+空格，A 字母数字 a加空格 ，
*可打印字符

很死板的，(123)，括号占两位，所以ddd 前后要空开，而且你不能混有其它文本，因为它的GetWindowText和SetWindowText都和格式有关，没有regex灵活。



CNetAddressCtrl 
校验IPv4，IPv6，DNS域名，比CMFCMaskedEdit更专一点。
msdn有sample。




CHtmlEditCtrl
很多html相关的方法在CHtmlEditCtrlBase中，它也继承自CWnd；
会自动将hosted WebBrowser ActiveX 控件放进去；
。。。



CHotKeyCtrl
不知道有什么消息，公司的vs2015，类向导会崩溃；


CLinkCtrl
和Link Button挺像的。

CListBox 
展示和选择的, CComboBox就有它，相应方法差不多；
CCheckListBox 后面多了个checkbox；
CDragListBox  item可以drag；


CPagerCtrl
一个窗口，可以容纳另一个比它大的窗口，你可以滚动；比如你的工具条很长，但你只想在固定长度里显示；
style：
PGS_AUTOSCROLL 鼠标放在scroll button上自动scroll；
PGS_DRAGNDROP 拖动可以scroll；
PGS_HORZ /PGS_VERT 水平/垂直；


CHeaderCtrl 
样式
HDS_BUTTONS    像按钮，美观
HDS_DRAGDROP  item可以拖来拖去
HDS_FILTERBAR 过滤小箭头，HDM_LAYOUT
HDS_FULLDRAG 拖拽也显示列内容
HDS_HIDDEN 隐藏 HDM_LAYOUT, WINDOWPOS
HDS_HORZ ，HDS_FLAT 默认
HDS_HOTTRACK 热点追踪
HDS_CHECKBOXES  左边，HDITEM
HDS_NOSIZING 固定大小
HDS_OVERFLOW 头部显示不全，出现一个按钮，点击发送HDN_OVERFLOWCLICK
。。。
还要响应各种消息，你才能像 资源管理器那样，有刷选，有下拉，有排序，有固定宽度。。。
常用在ListView和TabCtrl里。
Header Control Notifications

HDITEM
fmt 
HDF_RIGHT 对齐
HDF_BITMAP_ON_RIGHT ，HDF_IMAGE 图
HDF_OWNERDRAW自绘、
HDF_SORTDOWN 排序小箭头
HDF_CHECKBOX，HDF_CHECKED  checkbox
HDF_SPLITBUTTON 分隔按钮 HDN_DROPDOWN


CMFCHeaderCtrl
支持多列排序；

CListCtrl
样式
LVS_ALIGNLEFT/top/mask当前对齐/autoarrange 左/上/自动对齐（图标）
LVS_EDITLABELS 文本可编辑，父窗口必须处理LVN_ENDLABELEDIT通知
LVS_ICON /LVS_SMALLICON/ LVS_LIST /LVS_REPORT四种：1）icon 32*32；2）small icon 16*16；3）list 小icon+label；4）report CHeadCtrl控件

LVS_NOCOLUMNHEADER  reportview不显示headers
LVS_NOLABELWRAP  iconview 文本不换行
LVS_NOSORTHEADER  header没有类似按钮的功能
LVS_NOSCROLL  list和report不能用，item只在客户区不能滚动
LVS_OWNERDATA  a virtual list-view control 待看
LVS_OWNERDRAWFIXED 自绘 WM_DRAWITEM ， drawitemstruct
LVS_REPORT reportview的第一列总是左对齐
LVS_SHAREIMAGELISTS 共享imagelist，引用计数
LVS_SHOWSELALWAYS 即使控件失去焦点，也高亮选择
LVS_SINGLESEL 只能选一行，默认多行
LVS_SORTASCENDING 排序LVS_SORTDESCENDING
LVS_TYPEMASK控件当前窗口样式
LVS_TYPESTYLEMASK控件对齐和header样式
三个掩码的使用：

扩展：
LVS_EX_AUTOCHECKSELECT 点击自动选择checkbox；
LVS_EX_AUTOSIZECOLUMNS 自动调整列；
LVS_EX_BORDERSELECT 选中item改边框颜色 代替高亮
LVS_EX_CHECKBOXES  list-view 前面有checkbox
LVS_EX_COLUMNOVERFLOW 客户区溢出，会有一个overflow button，点击发送LVN_COLUMNOVERFLOWCLICK通知，LVS_EX_HEADERINALLVIEWS要有
LVS_EX_COLUMNSNAPPOINTS   resize列，只能到最小宽度；
LVS_EX_DOUBLEBUFFER 双buff绘图，减少闪烁，也加强alpha性能；
LVS_EX_FLATSB 加入滚动条，Flat Scroll Bar APIs.更多的滚动条操作；
LVS_EX_FULLROWSELECT 选取item时选取包含subitems的整行；report风格；
LVS_EX_GRIDLINES 显示网格；report风格；
LVS_EX_HEADERDRAGDROP  表头拖拽，report；
LVS_EX_HEADERINALLVIEWS  4中模式都有表头
LVS_EX_HIDELABELS 隐藏label； icon风格；
LVS_EX_JUSTIFYCOLUMNS  icon对齐表头
LVS_EX_LABELTIP  隐藏标签的small-icon可以有提示，默认只有icon有
LVS_EX_MULTIWORKAREAS 设置了lvs_autoarrange直到定义了workarea才有效
LVS_EX_INFOTIP  在显示item-tooltip之前，给父窗口发送 LVN_GETINFOTIP通知；
LVS_EX_ONECLICKACTIVATE点击item发送LVN_ITEMACTIVATE给父窗口，同时使Hot tracking可用（鼠标移动上去会高亮）；
LVS_EX_SIMPLESELECT   icon-view可以用空格反转选择
LVS_EX_SNAPTOGRID  icon自动到网格
LVS_EX_SUBITEMIMAGES 子项也有image；report风格；
LVS_EX_TRACKSELECT Hot tracking选择，鼠标放上去一段时间，自动选择，LVM_SETHOVERTIME ；
LVS_EX_TWOCLICKACTIVATE  双击发送LVN_ITEMACTIVATE给父窗口，同时热点跟踪可用；
LVS_EX_UNDERLINECOLD  TWO样式要有，非热点item以下划线显示
LVS_EX_UNDERLINEHOT  ONE或TWO样式要有，热点以下划线显示


组
SetRedraw(FALSE);

LVGROUP
mask  LVGF_HEADER。。。  
state LVGS_NORMAL。。。 stateMask
创建一个组 就要绑定一匹item，可以事先记录在map中；


列
LVCOLUMN
mask LVCF_FMT。。。
fmt  LVCFMT_LEFT。。。
第一列总是left-align，make a dummy column；


item
LVITEM
mask  LVIF_COLFMT。。。
state item's state, state image, and overlay image，
0-7位，item state，LVIS_CUT 剪切、高亮、焦点、选择、overlay和state 图像掩码



stateMask  state的哪些位有效



CMFCShellListCtrl  /  CMFCShellTreeCtrl  组成资源管理器

 
CMFCTabCtrl
可以单独创建，也可以配合Dock类使用；



CMFCPropertyGridCtrl
属性控件；
有四种属性：CMFCPropertyGridProperty、CMFCPropertyGridColorProperty颜色 ，CMFCPropertyGridFileProperty 文件、CMFCPropertyGridFontProperty 字体；
  
EnableHeaderCtrl   
EnableDescriptionArea 
它和 TabCtrl 一样，配合Dock类使用，达到丰富多样的视觉；

//CMFCPropertyGridProperty 属性都要new，不会内存泄露；
CMFCPropertyGridProperty* pGroup1 = new CMFCPropertyGridProperty(_T("Appearance"));
	COleVariant var3DLook((short)VARIANT_FALSE, VT_BOOL);
//因为有AddSubItem了，所以Appearance会有展开收缩图标；
	pGroup1->AddSubItem(new CMFCPropertyGridProperty(_T("3D Look"), var3DLook,
		_T("Specifies the dialog's font will be nonbold and controls will have a 3D border")));

	CMFCPropertyGridProperty* pProp = new CMFCPropertyGridProperty(_T("Border"),
		_T("Dialog Frame"), _T("One of: None, Thin, Resizable, or Dialog Frame"));
	pProp->AddOption(_T("None"));
	pProp->AddOption(_T("Thin"));
	pProp->AddOption(_T("Resizable"));
	pProp->AddOption(_T("Dialog Frame"));
	pProp->AllowEdit(FALSE);
//添加颜色属性，字体，文件类似；
	CMFCPropertyGridColorProperty* pColorProp = new CMFCPropertyGridColorProperty(_T("Window Color"), RGB(210, 192, 254), NULL, _T("Specifies the default dialog color"));
	pColorProp->EnableOtherButton(_T("Other..."));
	pColorProp->EnableAutomaticButton(_T("Default"), ::GetSysColor(COLOR_3DFACE));
	pColorProp->SetColor(RGB(255, 0, 0));
	pColorProp->SetColumnsNumber(3);
	pGroup1->AddSubItem(pColorProp);
//挂到控件上；
m_propertyCtrl.AddProperty(pGroup1);

COleVariant
 
详见msdn；


CMonthCalCtrl
 
DateTimeCtrl 也有；


CProgressCtrl
进度条 样式：PBS_VERTICAL，默认是水平的；PBS_SMOOTH  平滑，默认是方格；
	m_progressCtrl.Create(WS_VISIBLE | WS_CHILD | PBS_SMOOTH,
		CRect(10, 10, 100, 30), this, ID_PROGRESS_1);

	m_progressCtrl.SetRange(0, 100);
	m_progressCtrl.SetPos(40);


CRichEditCtrl
可以内嵌OLE对象，单独用要调用AfxInitRichEdit，你用了CRichEditView就不用了；
DisplayBand 显示部分区域
FindWordBreak 查找
GetIRichEditOle 获取IRichEditOle接口



CSpinButtonCtrl
样式：
UDS_ARROWKEYS 按上下箭头
UDS_ALIGNRIGHT 对齐
UDS_HORZ 水平的箭头
UDS_HOTTRACK 热追踪
UDS_NOTHOUSANDS 无千分符
UDS_WRAP 循环
UDS_SETBUDDYINT 设置伙伴窗口的text

消息响应；



CStatic
属性一览
client edge边框下凹、end ellipsis省略号、modal frame 3D、no prefix不使用&、group组tab键切换组，方向键切换组内控件、tabstop按tab能否获得焦点、no wrap文本不换行、transparent透明、accept files收到WM_DROPFILES，notify响应控件通知消息，msdn查找CStatic都是有的，如SS_BITMAP，SS_OWNERDRAW，WS_CHILD,WS_VISIBLE,WS_DISABLED等通常也要；
metafile是图元文件；

对话框移动
//这个只能点击在dlg的客户区移动，移动标题没用
void Cowndraw_ctrlDlg::OnMouseMove(UINT nFlags, CPoint point)
{
	static CPoint PrePoint = CPoint(0, 0);
	if (MK_LBUTTON == nFlags)
	{
		if (point != PrePoint)
		{
			CPoint ptTemp = point - PrePoint;
			CRect rcWindow;
			GetWindowRect(&rcWindow);
			rcWindow.OffsetRect(ptTemp.x, ptTemp.y);
			MoveWindow(&rcWindow);
			return;
		}
	}
	PrePoint = point;

	CDialogEx::OnMouseMove(nFlags, point);
}

//写在控件消息内 ,只是处理父窗口的移动
CMyStatic1::OnMouseMove
GetParent()->GetWindowRect(&rcWindow);

SetCapture();//左键按下消息，不然鼠标移动太快出去了
ReleaseCapture();//左键弹起，不然一直捕获，其它消息阻塞

鼠标悬停
在mousemove消息追踪悬停
//鼠标悬停
	if (g_bMouseTrack)
	{
		g_bMouseTrack = false;
		TRACKMOUSEEVENT tme;
		tme.cbSize = sizeof(TRACKMOUSEEVENT);
		tme.dwFlags = TME_HOVER | TME_LEAVE;
		//tme.dwHoverTime = HOVER_DEFAULT;  
		tme.dwHoverTime = 50;//多久才发送悬停消息ms
		tme.hwndTrack = GetSafeHwnd();
		TrackMouseEvent(&tme);
	}
在mouseover和mouseleave消息改变ui属性
void CMyStatic1::OnMouseHover(UINT nFlags, CPoint point)
{
	g_color = m_colorText;//保存原来的文本颜色
	m_colorText = COLOR_RED;
	Invalidate();
}
void CMyStatic1::OnMouseLeave()
{
	g_bMouseTrack = true;
	m_colorText = g_color;
	Invalidate();
}


CVSListBox
 
CVSListBoxBase  去重载；



CToolTipCtrl
TTS_ALWAYSTIP 激活tip，TTS_NOPREFIX 解析&；
typedef struct {
  UINT      cbSize;
  UINT      uFlags; TTF_ABSOLUTE(TTF_TRACK配合)、TTF_CENTERTIP(uid)、TTF_IDISHWND(uid)、TTF_PARSELINKS(解析link)、TTF_SUBCLASS、TTF_TRACK、TTF_TRANSPARENT
  HWND      hwnd;
  UINT_PTR  uId;  tool的id
  RECT      rect;
  HINSTANCE hinst;
  LPTSTR    lpszText;
#if (_WIN32_IE >= 0x0300)
  LPARAM    lParam;
#endif 
#if (_WIN32_WINNT >= Ox0501)
  void      *lpReserved;
#endif 
} TOOLINFO, *PTOOLINFO, *LPTOOLINFO;
code：
	EnableToolTips();
	m_tipCtrl.Create(this);
	m_tipCtrl.Activate(TRUE);
	m_tipCtrl.AddTool(m_pBtnTest, _T("click the button..."));

BOOL CAboutDlg::PreTranslateMessage(MSG* pMsg)
{
	m_tipCtrl.RelayEvent(pMsg);
	return CDialogEx::PreTranslateMessage(pMsg);
}

CMFCToolTipCtrl 
扩展了：can display an icon, a label, and a description. You can customize its visual appearance by using a gradient fill, custom text and border colors, bold text, rounded corners, or a balloon style.

CTreeCtrl
style：
TVS_CHECKBOXES、TVS_DISABLEDRAGDROP拖拽无效、TVS_EDITLABELS可编辑、TVS_FULLROWSELECT、TVS_HASBUTTONS＋－符号、TVS_HASLINES虚线、TVS_INFOTIP、TVS_LINESATROOT(TVS_HASLINES配合)、TVS_NOHSCROLL、TVS_NONEVENHEIGHT item高度、TVS_NOSCROLL、TVS_NOTOOLTIPS、TVS_SHOWSELALWAYS总是选取、TVS_SINGLEEXPAND点击和ctrl点击、TVS_TRACKSELECT


公共对话框
CColorDialog

CHOOSECOLOR  结构体
typedef struct {
  DWORD        lStructSize; 结构体长度
  HWND         hwndOwner; 颜色对话框所有者
  HWND         hInstance;//看Flags，有CC_ENABLETEMPLATEHANDLE，就是一个memory object包含对话框模板；有CC_ENABLETEMPLATE，a module包含对话框模板，都没有忽略。
  COLORREF     rgbResult; //Flags有CC_RGBINIT，就是初始显示颜色，默认是黑色，也是点击ok后选择的颜色。
  COLORREF     *lpCustColors; 指向16个颜色的指针ChooseColor，static颜色
  DWORD        Flags; //MSDN
  LPARAM       lCustData;钩子参数
  LPCCHOOKPROC lpfnHook; CCHookProc指针，要设置CC_ENABLEHOOK
  LPCTSTR      lpTemplateName; 自定义模板 CC_ENABLETEMPLATE
} CHOOSECOLOR, *LPCHOOSECOLOR;

使用：
CColorDialog colorDlg;
if (IDOK == colorDlg.DoModal()) 。。。
 

自定义颜色有16个：
COLORREF* arrCr = CColorDialog::GetSavedCustomColors();
for (int i = 0; i < 16; i++)  GetRValue(arrCr[i])。。。
程序退出就没了，程序运行着就一直在。
获取选择的颜色：COLORREF cr = colorDlg.GetColor();

自定义你要继承CColorDialog，提供对话框资源，消息map，一般都够用的。



CFileDialog
explicit CFileDialog(
   BOOL bOpenFileDialog,  TRUE是打开，FALSE是另存为
   LPCTSTR lpszDefExt = NULL, 默认后缀（程序关联）
   LPCTSTR lpszFileName = NULL, 初始显示的文件名
   DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, 6UL
   LPCTSTR lpszFilter = NULL, 过滤字符串
   CWnd* pParentWnd = NULL,
   DWORD dwSize = 0, 忽略
   BOOL bVistaStyle = TRUE  忽略
);
OFN_ALLOWMULTISELECT  DoModal之前设置，buf你要自己分配，并赋值m_ofn.lpstrFile和m_ofn.nMaxFile，n*MAX_PATH ) 。

void Cmfc_toolsDlg::OnBnClickedButton1()
{
	static int nMaxFileNum = 50;//最多50个文件

	//获取编辑框后缀名
	CEdit* pEdit = (CEdit*)GetDlgItem(IDC_EDIT1);
	CString strExt;
	pEdit->GetWindowText(strExt);
	if (strExt.IsEmpty()) return;

	//去掉输入的'.'
	strExt.Trim(_T('.'));

	CFileDialog fileDlg(TRUE);
	OPENFILENAME& ofn = fileDlg.GetOFN();
	ofn.Flags |= OFN_ALLOWMULTISELECT;
	CString strBuf;//存储文件列表的buf
	LPTSTR pBuf = strBuf.GetBuffer(nMaxFileNum * MAX_PATH);
	ofn.lpstrFile = pBuf;
	ofn.nMaxFile = nMaxFileNum * MAX_PATH;

	if (IDOK == fileDlg.DoModal()) {
		//多选之后，pathName是上层文件夹
		CString& pathName = fileDlg.GetPathName();

		int ptPos = 0;//'.'位置
		POSITION pos = fileDlg.GetStartPosition();		
		while (pos) {
			pathName = fileDlg.GetNextPathName(pos);
			ptPos = pathName.Find(_T('.'));//查找第一个'.'
			if (-1 == ptPos)
				continue;
			//构造新文件名
			CString tmpStr = pathName.Left(ptPos + 1);
			tmpStr += strExt;
			CFile::Rename(pathName, tmpStr);
		}
	}
	strBuf.ReleaseBuffer();
}

过滤字符串：
static TCHAR BASED_CODE szFilter[] = _T("Chart Files (*.xlc)|*.xlc|")
   _T("Worksheet Files (*.xls)|*.xls|Data Files (*.xlc;*.xls)|")
   _T("*.xlc; *.xls|All Files (*.*)|*.*||");
说明			过滤   其它      结束
Chart Files (*.xlc) |*.xlc | 。。。 ||
CFileDialog fileDlg(TRUE,nullptr,nullptr,6UL, szFilter);

添加控件
 

让对话框下次打开在之前的位置：
ApplyOFNToShellDialog  保存状态。
CFolderPickerDialog  选择文件夹的对话框


CFindReplaceDialog
它是无模态的，必须new，别在栈上，析构的时候，框架会delete this的。
      virtual BOOL Create(
   BOOL bFindDialogOnly, TRUE只是Find,FALSE 查找替换
   LPCTSTR lpszFindWhat, 默认的查找字符串
   LPCTSTR lpszReplaceWith = NULL, 默认的替换字符串
   DWORD dwFlags = FR_DOWN,
   CWnd* pParentWnd = NULL 
);
查找和替换函数你是要加的。
Create之前用m_fr初始化。

typedef struct {
  DWORD        lStructSize; 
  HWND         hwndOwner; 不能为NULL，它会收到对话框的FINDMSGSTRING消息
  HINSTANCE    hInstance; 看Flags，和模板有关
  DWORD        Flags;
  LPTSTR       lpstrFindWhat;  必须动态分配或是全局static的，至少80字节长。
  LPTSTR       lpstrReplaceWith; 同上
  WORD         wFindWhatLen;
  WORD         wReplaceWithLen;
  LPARAM       lCustData; hook参数
  LPFRHOOKPROC lpfnHook; hook
  LPCTSTR      lpTemplateName; 模板
} FINDREPLACE, *LPFINDREPLACE;

想让父窗口收到“查找替换”通知，你必须用RegisterWindowMessage和ON_REGISTERED_MESSAGE处理消息。

http://blog.sina.com.cn/s/blog_9cd8465f01010cwe.html

实际编程
简要
Windows提供了上百个win32 API，但开发效率太低，实际编程常使用类库等一些已经成熟的框架，MFC封装了win32 API，程序执行效率下降了，但是开发效率高，前提条件是“你知道MFC的来龙去脉”。
现在一个程序不是简单的界面编程，还要有db，dll，hook，serialize，网络，COM，控件，消息，Web（html/css/js），移动端通信，Mac/Unix。。。每一个都是大头，开发过程要心里有底，预见这种困难性。

新东西
ATOM m_atomApp = ::GlobalAddAtom(strFileName); 向全局原子表添加一个字符串，并返回这个字符串的唯一标识符，GlobalGetAtomName，GlobalDeleteAtom，如果字符串已存在，引用计数+1；全局原子程序结束不会自动删除；lpString可以是”#1234”，原子值=0x04D2；



游戏内存修改器
修改游戏属性：生命值，金钱等；
原理：数据都在内存中保留着，遍历进程的地址空间，搜索在哪一个内存地址中保存着这些数据，然后写入你的数据。
API：ReadProcessMemory，GetVersionEx；


配置管理器
动态创建对话框，DLGTEMPLATE构造不好；
包含windowsx.h 简化switch-case；
win32对话框控件太丑？
#ifdef _UNICODE
#if defined _M_IX86
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker,"/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif
#endif


字符和字符串
简要
Unicode
UTF-8，1-4字节表示一个字符：
0xxxxxxx
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
UTF-16，2字节， UTF-32，4字节
在windows下，unicode用UTF-16编码，而在网页上通常用UTF-8编码；
COM, 资源文件中的字符串等，统一unicode；
c库
tchar.h ,  strsafe.h(包含string.h, 在包含所有文件后包含) ;  _tcsXXX_s, 验证参数，debug弹框，release终止进程;
_countof,  stdlib.h
StringCchCat/Ex, StringCbCopy/Ex,  strisafe.h 更多控制， P42；
Unicode与ANSI转换， P47，笔记：字符串处理；
字符串处理
分割字符串
AfxExtractSubString(strTmp, line, i++, _T(' '));
找到后缀
TCHAR* szExt = PathFindExtension(szPath);  //D:\vsprj\mfc.exe
      “.exe”                       D:\vsprj\mfc  会修改szPath
CString strFileName = ::PathFindFileName(strShortName);

找到exe，只保留exe名
	CString str1;
	AfxGetModuleFileName(AfxGetInstanceHandle(), str1);  H:\\..\\XX.exe
	str = PathFindFileName(str1); 	 XX.exe
	LPTSTR pszFilename = str.GetBuffer();
	PathRemoveExtension(pszFilename); 		XX
	str.ReleaseBuffer();

查找子串
d:\\abc.txt
PCTSTR psz = _tcsrchr(sz,  _T(‘\\’));   //返回\\agc.txt

Unicode
c运行期库对Unicode的支持：
增加了wchar_t；
char* str开头增加wcs开头的版本；

<tchar.h>  TCHAR类型； _T();   _tcs替换开头；

Microsoft的<StrSafe.h>中定义了_s 安全函数； _tcs…_s;   比c库安全的地方就是会检查参数； _countof
c库  StringCchCat()等更多控制

字符串分割
void SplitString(string line, char ch, vector<string>& vec)
{
	vec.clear(); 
	line += ch;
	
	size_t pos(0),prev(0);
	pos = line.find_first_of(ch, prev);
	while(pos != string::npos){
		string& str = line.substr(prev, pos - prev);
		vec.push_back(str);
		prev = pos + 1;
		pos = line.find_first_of(ch, prev);
	}
}

格式化字符串
_stprintf_s(pTTT->szText, _countof(pTTT->szText),
				_T("Control ID = %d"), nID);格式化的消息框
int CDECL MessageBoxFormat(TCHAR* szCaption, TCHAR* szFormat, ...) 
{
	TCHAR szBuffer[1024] ;
	va_list pArgList ; //char*
	va_start(pArgList, szFormat) ; //将指针与最后一个固定参数关联
	
	//专门写进szBuffer的函数
	_vsntprintf_s(szBuffer, _countof(szBuffer), szFormat, pArgList) ;
	va_end(pArgList) ; //清理

	return MessageBox(NULL, szBuffer, szCaption, 0) ;
}


多字节/Unicode 转换
windows
wchar/char字符数 = MultiByteToWideChar(代码页,0,多字节,字节数(-1),输出,长度(字符数,0会获取));
	char* text = "fuck u!卵蛋！";
	int len = strlen(text);  //13

	int wNeedLen = MultiByteToWideChar(CP_ACP, 0, text, -1, NULL, 0); //11 包含’/0’
	wchar_t* wtext = new wchar_t[wNeedLen];
	MultiByteToWideChar(CP_ACP, 0, text, -1, wtext, wNeedLen);

	wtext[0] = L'R';
	int cNeedLen = WideCharToMultiByte(CP_ACP, 0, wtext, -1, NULL, 0, 0, 0);
	text = new char[cNeedLen];
	WideCharToMultiByte(CP_ACP, 0, wtext, -1, text, cNeedLen, 0, 0);

delete …

c库函数
mbstowcs， wcstombs；
   std::string str = "test1";
	TCHAR tc[8] = { 0 };
	mbstowcs_s(0, tc, str.c_str(), 8);

ATL
#include <...atlmfc/include/atlconv.h>
ATL 3.0 字符串转换宏	ATL7.0 字符串转换类
在栈上分配内存	对于短字符串使用栈上的内存，如果内存不够使用堆内存
在函数退出时字符串占用的内存被释放	当变量超出作用域后内存被释放
不能在异常处理代码中使用	可以在异常处理代码中使用
不适用于循环，内存会一直增长直到函数退出	可以在循环中使用，每次迭代分配的内存都会被释放
不适用于太长的字符串，栈内存是有限的	可以处理长字符串，在堆中分配内存
通常需要定义 USES_CONVERSION	不需要定义USES_CONVERSION
OLE的含义取决于OLE2ANSI的定义	OLE 等同于W

vs2010都 ATL10.0了；
常用：CA2W , CW2A , CW2T, CA2T
CT2A pszA(item.pszText);
l = strlen(pszA);


数据库
SQL Server 2008 R2
基础
三大范式：1，字段拆成原子；2，每一记录只和主键相关；3，是直接相关，不是间接；

08系统的体系结构：4种服务
数据库引擎、Analysis Services、Reporting Services、Integration Services；
数据库引擎（核心服务）：对数据的存储、处理和管理；
其它略；

SQL Server Management Studio 
4个系统db；
主数据文件.mdf，辅助数据文件.mdf（可无）；事物日志文件.ldf；放在不同路径下；

数据类型
 
 
     


T-SQL
Microsoft在SQL Server中使用的；Transact-SQL；SQL是有国际标准的，T-SQL的扩展包括自己的数据类型、表达式和关键字等；
三类： 
DDL data definition Language : CREATE、ALTER、DROP；
DDM Manipulation : SELECT、INSERT、UPDATE、DELETE；
DCL Control：sysadmin、dbcreator、db_owner或db_securityadmin等角色有权限；GRANT、REVOKE、DENY

常量
  

系统全局变量
 

定义变量
DECLARE @变量名 变量类型
不能声明text、ntext、image；
赋值变量
SET @变量名 = 值
运算符
+ - * / %
=、<、>、 !=、  返回Boolean类型：TRUE,FALSE,UNKNOWN
位：&、|、^、~
逻辑
 
NOT 可以配合：NOT IN、NOT LIKE、NOT BETWEEN…
LIKE通配符：
IN: WHERE Author IN(‘a’, ‘b’, ‘c’)  列表中不允许有NULL值
IS NULL也是逻辑操作


函数
聚合函数，与GROUP BY、HAVING子句一起使用；除了COUNT，都会忽略空值；
    
SQL Server 2008 中比较字符串不区分大小写！
charindex(expr1, expr2, [start]) expr1在expr2中开始位置(不是索引值)
如: set @stagePos1 = charindex(',',@stagelist)
set @tmp = convert(int,substring(@upgradelist, @stagePos1 + 1, @stagePos2 - @stagePos1 - 1)) 开始位置，长度

类型转换：隐式
显示： CAST(表达式 AS 类型[(长度)])
CONVERT(类型[(length)], 表达式[, style])
   
时间
sql ：Convert(varchar(10),getdate(),112)   变成 ‘20170210’
sql 前2天，dateadd(day,-2,getdate())  20170208  


自定义函数
可以接受多个输入参数；返回值可以是数值、表；但不支持输出参数；
CREATE  FUNCTION  函数名
( [ { @参数名 参数类型[ = default] } [,...n] ] )
RETURNS 返回值类型
[WITH ENCRYPTION]
[AS]
BEGIN
	函数体
	RETURN 表达式
END

返回表类型
CREATE  FUNCTION  函数名
( [ { @参数名 参数类型[ = default] } [,...n] ] )
RETURNS TABLE   
[WITH ENCRYPTION]
[AS]
RETURN (SELECT 语句)


控制语句
BEGIN...END  T-SQL语句块 下面提到的“语句块|SQL语句”都要用到；

IF bool表达式
	语句块|SQL语句
[ELSE ...]

简单CASE语句：匹配就返回
CASE 表达式
	WHEN 与表达式比较的表达式或值 THEN 返回的表达式
	[,...n]
	[ELSE 返回的表达式]
END
注意它是有返回的！ 所以可以这样用 SELECT CASET...
搜索CASE语句：找到第一个TRUE就返回
CASE
	WHEN bool表达式 THEN 返回的表达式
	[,...n]
	[ELSE 返回的表达式]
END

WHILE bool表达式
	语句块|SQL语句
	[BREAK]
	[CONTINUE]

创建数据库
CREATE  DATABASE [数据库名]
[ ON PRIMARY  (  主数据文件.mdf，PRIMARY是主数据文件
NAME = 文件名, 			N’db_books’
FILENAME = 文件路径, 		N’E:\db_books.mdf’
[SIZE = 文件初始大小,]		10240KB(10M)
[MAXSIZE = 文件最大容量,] 	102400KB
[FILEGROWTH = 文件增量]  )] 10240KB 或者写 10%
[, ...n]  辅助数据文件(.mdf有逗号)
[ LOG ON (  事务日志文件.ldf
NAME = 文件名,
FILENAME = 文件路径,
[SIZE = 文件初始大小,]
[MAXSIZE = 文件最大容量,]
[FILEGROWTH = 文件增量]  )]

CREATE  DATABASE  [name]，使用默认设置创建db；

选择数据库
USE 数据库名
GO

删除数据库
DROP DATABASE 数据库名[, ...n]

创建表
CREATE TABLE [ 数据库名.[ owner]. | owner] 表名 
(
{ <列定义:{列名 数据类型}> | 
<约束 [ 默认值] | [自动编号 IDENTITY[ (seed起始值, increment) ] ]> | 
列名 AS 计算列的表达式 } [, ...n] 
| 或上的意思， BookNumber VARCHAR(10)  NOT NULL  PRIMARY KEY,
创建主键更灵活的方式： PRIMARY KEY(列名)，好多都可以这样用
创建自动编号：ID INT IDENTITY(1,1) NOT NULL,
创建外键： FOREIGN KEY REFERENCES(哪张表哪个列)
创建默认值： DEFAULT(值)
CHECK约束：CHECK(条件)
唯一性约束：UNIQUE，该列不允许重复
)
[ ON {filegroup | DEFAULT} ]  数据表所存储的文件组
[ TEXTIMAGE_ON { filegroup | DEFAULT }] 数据表的Text和Image文件所在的文件组


添加/删除/修改列
ALTER  TABLE 表名 ADD 列名 列属性(类型，约束等)
ALTER  TABLE 表名 DROP COLUMN 列名

ALTER TABLE 表名
ALTER COLUMN 列名 列属性

删除表
DROP TABLE 表名

插入数据
INSERT [INTO] 表 [( 列_list  )] VALUES( 值_list )
如果没有指定列，那值要和列一一对上，自动编号的不用；
如果遗落了，会用默认值，如果没有默认值就设为NULL，如果不能为NULL，报错；

将一个表插入另一个表
INSERT...SELECT
INSERT表必须存在，数据类型，顺序一致；
INSERT  表名  SELECT 列_list FROM 表_list WHERE 条件

更新数据
UPDATE [TOP] 表名 
SET { 列名 = 表达式 | DEFAULT | NULL } [,  …n]
[WHERE 条件]

指定行
TOP(代表行的表达式) [PERCENT][WITH TIES]
WITH TIES用于返回额外的数据行
SELECT  TOP n * FROM
n 如果是变量  就要拼接了
	declare @str varchar(1000)
	set @str = ''
set @str = 'select top '+cast(10 as varchar(10))+' * into #temp_table_user_loginFailed from t_user_loginFailed where userID=@userID order by loginTime desc'
select @str


删除数据行
DELETE 表名 WHERE 条件
只删除行；注意参照完整性；没有WHERE就是清空表；
TRUNCATE  TABLE[[database.]owner.] 表名 清空表；
区别：一个写日志，可以ROLLBACK，一个不写；

SELECT
SELECT [ALL | DISTINCT] 列_list  all默认，distinct去重
FROM 表名
[WHERE 条件]
[GROUP BY 表达式] 对查询结果分组
[HAVING 条件] 与GROUP BY配合，如筛选>2的图书分类
[ORDER BY 表达式 [ASC | DESC]]

WHERE 配合逻辑操作符
order 可以别名；多个排序逗号隔开，可以跟DESC；NULL值最大；
GROUP BY 表达式 [WITH ROLLUP | CUBE]

SELECT Author,COUNT(*) AS ‘Number’ FROM BookInfo GROUP BY Author 它会GROUP BY，同时也COUNT了，这个神奇；
其实是这样的：我要显示Author和Number，这两个要对上，COUNT正好对上；
SELECT 返回一张虚拟的表！

取别名
列/表名 [AS] 别名

子查询
SELECT list FROM 表名 WHERE 表达式 IN | NOT IN (子查询结果select)
									EXISTS | NOT EXISTS(子查询结果)
								ID = ANY(子查询结果) 或 单值子查询结果
					
SELECT * FROM UserInfo AS UI WHERE EXISTS( SELECT UserID FROM CardInfo AS CI WHERE UI.ID = CI.UserID)  WHERE好像可以循环一样，这个神奇；

select userid, pass from t_au_userinfo where userid in (select cardid from t_au_userlist where userid=%d and parterid=%d)

临时表
select roomid into #t1 from t_chnl_roominfo
select distinct * from #t1
drop table #t1


多表查询
内连接
SELECT select_list FROM 表1 INNER JOIN(或JOIN)  表2 ON 连接条件
[WHERE 条件]
[ORDER BY 条件]
列名重复了可以加表前缀，UI,CI是两张表
SELECT UI.*, CI.* FROM CardInfo CI  INNER JOIN UserInfo UI ON CI.UserID = UI.ID AND CI.CreateTime < ‘2011—6-01’    别名可以先用，这个神奇；

外连接
如果数据表中一些行在其他表中不存在匹配行，内连接通常会忽略，而外连接至少要返回一个表的全部，因此有主从之分；
左外连接：左全匹配，右边填NULL
SELECT select_list FROM t1   LEFT(RIGHT/FULL) OUTER JOIN  t2  ON 条件
[WHERE 条件]
[ORDER BY 条件]

交叉连接
CROSS JOIN  返回所有行的可能组合

自连接
一个表的字段间有关系；
SELECT p1.UserName ‘父亲’, p2.UserName ‘儿子’
FROM People p1, People p2
WHERE p1.ID = p2.FatherID

联合，交，差查询
将两个或两个以上SELECT结果合并
SELECT list FROM t [WHERE 条件] { UNION [ALL包括重复] SELECT list FROM t [WHERE] }  [ORDER BY]
列名在第一个查询中指定；行不匹配报错；

INTERSECT 交查询
EXCEPT 差查询


索引
加快查询速度；
表的存储由两部分组成，表页面和索引页面；当检索数据时，系统先搜索索引页面，找到数据指针，再获取数据，对编写T-SQL没有任何影响；
将表和索引分别存储在不同的文件组中，会大大提高数据操作速度；
细节：《轻松学》P191

存储过程
T-SQL语句集合
执行语法：
[[EXE[CUTE]]
{ 
[@返回状态=] { 过程名[;number] | @局部变量名}
[[@参数=] {value | @variable[OUTPUT] | [DEFAULT] } [, …n]
[WITH RECOMPILE]
}
number 同名过程的分组号
@参数 显示指定可以不按顺序给实参

自定义存储过程
下面的语句不能用：

CREATE  PROC[EDURE] 过程名[;number]
[{@参数 类型} [VARYING] [=default] [OUTPUT]] [,… n]
[WITH { RECOMPILE | ENCRYPTION}]
[FOR REPLICATION]
AS 
SQL语句
VARYING 游标使用
default 参数默认值 
RECOMPILE、ENCRYPTION、FOR..高级

加密、临时、嵌套

CREATE PROC Proc_FindBooks
@classify VARCHAR(50)  = ‘unknown’ OUTPUT,
@author …
AS
BEGIN ..
END


触发器
分类
DML：对表或视图的改动INSERT、UPDATE、DELETE；
DDL：CREATE、ALTER、DROP、GRANT、DENY、REVOKE等；
登录触发器

08为每个DML触发器创建：deleted和inserted表，系统维护，触发完删除；

创建
DML
CREATE TRIGGER 名
ON { 表｜视图 }
{
	{ FOR | AFTER | INSTEAD OF }  触发时机
	{ [DELETE], [INSERT],[UPDATE] }
	AS
		sql
}
INSTEAD OF :当进行INSERT、UPDATE、DELETE操作时，系统给触发器，可以定义更复杂的约束；

DDL
CREATE  TRIGGER 名
ON { ALL SERVER | DATABASE } 作用域
WITH ENCRYPTION
{ FOR | AFTER | { event_type }}
AS sql
Event_type:
CREATE_TABLE  CREATE_DATABASE  

嵌套、递归触发器； P241
修改、启禁用、删除；


事务
一组T-SQL命令，要么全部成功，要么撤销；
BEGIN   TRANSACTION
COMMIT
ROLLBACK

BEGIN  TRANSACTION
	Sql
IF @ERROR = 0
BEGIN
	COMMIT TRANSCATION
	PRINT ‘成功’
END
ELSE
BEGIN
	ROLLBACK TRANSCATION
END


数据锁
不同用户同时修改同一个数据；


游标
操作查询结果的一种常用方式；
DECLARE 游标名 CURSOR [LOCAL | GLOBAL]
[FORWARD_ONLY | SCROLL] 
[static | keyset | dynamic | fast_forward]
[READ_ONLY | SCROLL_LOCKS | OPTIMISTIC]
[TYPE_WARNING]
FOR select语句
[FOR UPDATE [OF 列名[, …n]] 可更新的列

打开游标
OPEN{{  [GLOBAL] 游标名}  ｜ 游标变量名 }
检索数据
FETCH[[ NEXT | PRIOR | FIRST | LAST | ABSOLUTE {n | @nvar} | RELATIVE {n | @nvar} ] FROM ]
{{ [GLOBAL] 游标名} | @游标变量名}
[INTO @变量名[, … n]]
@@FETCH_STATUS  0 成功 -1失败 -2 行不存在
配合INTO 修改字段值，配合@@FETCH_STATUS遍历；
关闭游标
CLOSE {{[GLOBAL] 游标名} | 游标变量名}
释放游标
DEALLOCATE {{[GLOBAL] 游标名} | 游标变量名}


架构
对象的容器，名字空间；



ODBC
ODBC-Open Database Connectivity，微软开放式数据互联。是一组访问和操作数据库的API。可以使用相同的API访问不同的数据库，前提是需要将数据库设置为ODBC数据源。只能访问关系型数据库。

配置ODBC数据库：
“控制面板（小图标显示）-管理工具-数据源32位（如果Access是32位的）-系统DSN-添加”，选择“Microsoft Access Driver(*.mdb)”，输入数据源名称并找到数据库文件，确定。
如果没有找到驱动的话，详见《遇到的问题》。

在mfc中添加class CMedicSet : public CRecordset
打开类向导，发现没有CRecordset基类。
选择MFC ODBC Consumer，选择数据源，机器数据源（首先要配置ODBC数据库，sql server的配置类似）。

ADO
ADO是一组动态链接库，在使用之前必须导入ADO并且初始化。
在stdafx.h中:
#import “c:\program files (或者x86)\common files\system\ado\msado15.dll” no_namespace rename(“EOF”,”adoEOF”)
编译后系统生成msado15.tlh、msado15.tli两个C++头文件来定义ADO库，将其放在cpp目录(默认生成在Debug目录下)。为了避免常数冲突，将EOF改名adoEOF。
Mfc中初始化OLE/COM库环境比较简单，在InitInstance中 if(! AfxOleInit()){ return FALSE; }

ADO库包含三个基本接口:_ConnectionPtr接口、_CommandPtr接口和_RecordsetPtr接口。 
_ConnectionPtr
使用它创建一个数据连接，然后使用其它对象执行数据输入输出操作。
_CommandPtr
它提供了一种简单的方法来执行返回记录集的存储过程和SQL语句。
_RecordsetPtr
它对记录集提供了更多的控制功能

基本流程
 (1)初始化COM库，引入ADO库定义文件
(2)用Connection对象连接数据库
(3)利用建立好的连接，通过Connection、Command对象执行SQL命令，或利用Recordset对象取得结果记
   录集进行查询、处理。
(4)使用完毕后关闭连接释放对象。

详见网页：用ADO操作数据库的方法步骤(转载) - 长寿梦的编程手记 - C++博客.html。


为了便于操作数据库，定义派生自CADORecordBinding的类，用于程序与数据库字段的交互(绑定)。
#include <icrsint.h>
Class CDevCodeRs : public CADORecordBinding
{
	InstrumentManage  <DataBinding.h>
}

C++ 基础知识
简要
c++内置类型范围；
printf, I/O流格式控制；
静态存储区：编译时已分配好，静态数据、全局数据和常量；栈：局部/临时变量；堆；
char* p = “hello”; char a[] = “world”; p和a 都在栈中，p[2]=’A’;是错的，因为p[2]在静态存储区中；
初始化：创建变量时赋予初始值，赋值：擦除对象赋予新值；
连续定义：int i=1024, &r=I，读取复杂声明；
变量定义：一次，但可以声明多次，用extern；const定义的变量默认只在文件内有效，要想不同文件共享，解决办法就是声明定义的时候都用extern；
移位，逗号，c++ primer运算符优先级；
数组之间不允许拷贝和赋值，通常用指针操作
auto，decltype，尾置声明，using（typedef），constexpr（将typedef，const定义在类内部），set<string>::value_type，。。。尽量写一些“需求变化之后”改动最小的代码；
函数重载，除了返回类型，顶层const；const_cast利用重载版本
shared_ptr，引用计数为0，自动调用析构/delete等清理操作，异常了也会释放；还可以指定删除器，对于操作绑定的如connect忘了disconnect（就像new忘了delete一样）；unique_ptr独占指针（锁）；weak_ptr（伴随）；
类的设计，拷贝，操作符，函数对象；
模板，命名空间，异常，STL；
RTTI，enum，union（节省空间的类），位域（一定数量的位）；

实用
size_t offsetof(struct node_t, c);



ASCII表
ASCII控制字符
二进制	十进制	十六进制	缩写	名称/意义
0000 0000	0	00	NUL	空字符（Null）
0000 0001	1	01	SOH	标题开始
0000 0010	2	02	STX	本文开始
0000 0011	3	03	ETX	本文结束
0000 0100	4	04	EOT	传输结束
0000 0101	5	05	ENQ	请求
0000 0110	6	06	ACK	确认回应
0000 0111	7	07	BEL	响铃
0000 1000	8	08	BS	退格
0000 1001	9	09	HT	水平定位符号
0000 1010	10	0A	LF	换行键
0000 1011	11	0B	VT	垂直定位符号
0000 1100	12	0C	FF	换页键
0000 1101	13	0D	CR	归位键
0000 1110	14	0E	SO	取消变换（Shift out）
0000 1111	15	0F	SI	启用变换（Shift in）
0001 0000	16	10	DLE	跳出数据通讯
0001 0001	17	11	DC1	设备控制一（XON 启用软件速度控制）
0001 0010	18	12	DC2	设备控制二
0001 0011	19	13	DC3	设备控制三（XOFF 停用软件速度控制）
0001 0100	20	14	DC4	设备控制四
0001 0101	21	15	NAK	确认失败回应
0001 0110	22	16	SYN	同步用暂停
0001 0111	23	17	ETB	区块传输结束
0001 1000	24	18	CAN	取消
0001 1001	25	19	EM	连接介质中断
0001 1010	26	1A	SUB	替换
0001 1011	27	1B	ESC	跳出
0001 1100	28	1C	FS	文件分割符
0001 1101	29	1D	GS	组群分隔符
0001 1110	30	1E	RS	记录分隔符
0001 1111	31	1F	US	单元分隔符
0111 1111	127	7F	DEL	删除

ASCII可显示字符

二进制	十进制	十六进制	图形
0010 0000	32	20	（空格）(␠)
0010 0001	33	21	!
0010 0010	34	22	"
0010 0011	35	23	#
0010 0100	36	24	$
0010 0101	37	25	 %
0010 0110	38	26	&
0010 0111	39	27	'
0010 1000	40	28	(
0010 1001	41	29	)
0010 1010	42	2A	*
0010 1011	43	2B	+
0010 1100	44	2C	,
0010 1101	45	2D	-
0010 1110	46	2E	.
0010 1111	47	2F	/
0011 0000	48	30	0
0011 0001	49	31	1
0011 0010	50	32	2
0011 0011	51	33	3
0011 0100	52	34	4
0011 0101	53	35	5
0011 0110	54	36	6
0011 0111	55	37	7
0011 1000	56	38	8
0011 1001	57	39	9
0011 1010	58	3A	:
0011 1011	59	3B	;
0011 1100	60	3C	<
0011 1101	61	3D	=
0011 1110	62	3E	>
0011 1111	63	3F	?
	 	二进制	十进制	十六进制	图形
0100 0000	64	40	@
0100 0001	65	41	A
0100 0010	66	42	B
0100 0011	67	43	C
0100 0100	68	44	D
0100 0101	69	45	E
0100 0110	70	46	F
0100 0111	71	47	G
0100 1000	72	48	H
0100 1001	73	49	I
0100 1010	74	4A	J
0100 1011	75	4B	K
0100 1100	76	4C	L
0100 1101	77	4D	M
0100 1110	78	4E	N
0100 1111	79	4F	O
0101 0000	80	50	P
0101 0001	81	51	Q
0101 0010	82	52	R
0101 0011	83	53	S
0101 0100	84	54	T
0101 0101	85	55	U
0101 0110	86	56	V
0101 0111	87	57	W
0101 1000	88	58	X
0101 1001	89	59	Y
0101 1010	90	5A	Z
0101 1011	91	5B	[
0101 1100	92	5C	\
0101 1101	93	5D	]
0101 1110	94	5E	^
0101 1111	95	5F	_
	 	二进制	十进制	十六进制	图形
0110 0000	96	60	`
0110 0001	97	61	a
0110 0010	98	62	b
0110 0011	99	63	c
0110 0100	100	64	d
0110 0101	101	65	e
0110 0110	102	66	f
0110 0111	103	67	g
0110 1000	104	68	h
0110 1001	105	69	i
0110 1010	106	6A	j
0110 1011	107	6B	k
0110 1100	108	6C	l
0110 1101	109	6D	m
0110 1110	110	6E	n
0110 1111	111	6F	o
0111 0000	112	70	p
0111 0001	113	71	q
0111 0010	114	72	r
0111 0011	115	73	s
0111 0100	116	74	t
0111 0101	117	75	u
0111 0110	118	76	v
0111 0111	119	77	w
0111 1000	120	78	x
0111 1001	121	79	y
0111 1010	122	7A	z
0111 1011	123	7B	{
0111 1100	124	7C	|
0111 1101	125	7D	}
0111 1110	126	7E	~



读取复杂声明
内->外，右->左
int *&r = p;  //r是指针p的引用;
int* p[10];  //10个int*
int (*P)[10]  //一个*
int(*fun(int i))[10]; 函数返回一个*，指向int[10]
int* (&array)[10] = ptr;  引用，10个元素，int*

流
io流状态
cin>>a; 返回流，while(cin>>a) 可以直接判断流的状态，当流无效时就是false（无效输入/输入错误/文件结束符等）；
io流格式控制
c++有两种方法控制流的格式：1，格式控制符#include<iomanip>，2，流对象的成员函数；
格式控制符
cout << oct << setiosflags(ios::showbase | ios::uppercase);
dec/hex/oct/setbase(n=8,10,16)设置整数的基数、setfill(c)填充字符、setprecision(n有效位数或小数位数)设置精度、setw(n)设置宽度、setiosflags(ios::fixed/scientific/left/right/shipws忽略前导空格/uppercase大写E和X/showpos显示+号/internal符号左填充字符中间数值右边/dec/oct/hex/unitbuf输出后刷新所有流)、resetiosflags；
成员函数
precision(n), width(n), fill(c),setf(ios::), unsetf(ios::);
setw,left等不会改变流的状态，所以对连续输出的内容可以用ostringstream
oss.str("");//清空
		oss << "round_" << i + 1;
		cout << std::setw(8) << std::left << oss.str();

C++文件流
未格式化的输入输出操作
char ch;
while(cin.get(ch))   //不会忽略空白，应用格式控制等
get从流中读取指定字节的字符，
put、putback、unget、peek。。。

多字节底层操作
is.get(sink,size,delim) 读取size个字节到sink中，直到遇到delim字符（is从分隔符继续,getline从分隔符之后继续）或size(size-1?)个或文件尾，
is.getline(sink,size,delim)同get，但会读取delim并丢弃它，
is.read(sink,size) 读取size个返回is，
is.gcount() 返回上一个未格式化读取操作的字节数，
os.write(source,size)写入os，

流随机访问
tell当前流位置
seek重定位流位置
tellg seekp  g对应is流，p对应os流，


向流中写入结构体
struct StgCfg {};

struct StgCfgNormal : StgCfg {
	bool bInfo = true;
	TCHAR* szName = nullptr;
	int cbName = 0;

	StgCfgNormal(){}
	StgCfgNormal(bool b,TCHAR* p,int n)
		:bInfo(b),szName(p),cbName(n){}
};
ofstream& operator<<(ofstream& wofs, const StgCfgNormal& cfg)
{
	wofs.write((char*)&cfg.bInfo, sizeof(decltype(cfg.bInfo)));
	wofs.write((char*)&cfg.cbName, sizeof(decltype(cfg.cbName)));
	wofs.write((char*)cfg.szName, cfg.cbName * 2);
	return wofs;
}
ifstream& operator>> (ifstream& wifs, StgCfgNormal& cfg)
{
	//wifs >> cfg.bInfo; //读03mao肯定读不到bInfo里
	//wifstream::iostate state = wifs.rdstate();
	//int n = state & ifstream::failbit; //n=2
	wifs.read((char*)&cfg.bInfo, sizeof(decltype(cfg.bInfo)));
	wifs.read((char*)&cfg.cbName, sizeof(decltype(cfg.cbName)));
	wifs.read((char*)cfg.szName, cfg.cbName * 2);
	return wifs;
}

main
TCHAR* szName = _T("毛");
	int len = _tcslen(szName);
	//StgCfg* pCfg = new StgCfgNormal(true, szName, len);
	StgCfgNormal cfg(false, szName, len);

	ofstream wofs(_T("abc"),wios::binary);
	if (wofs) {
		wofs << cfg;
	}
	wofs.close();

	ifstream wifs("abc");
	if (wifs) {
		StgCfgNormal st;
		TCHAR ch[3] = { 0 };
		st.szName = ch;
		wifs >> st;
	}


C文件流
#include <stdio.h>
FILE* fopen、 r,r+,w,w+,a,a+,b, wb+,...  fclose，
fprintf格式化输出到文件，fscanf，
clearerr清除文件流的错误标识，
feof 是否到文件尾，
fflush，
fgetc读取一个字符，fgets读取多个，fputs，fread，fwrite，
fileno返回文件流使用的文件描述符，
ftell当前文件流读取位置，
fseek，SEEK_SET、SEEK_CUR，


将结构体读取到C文件流
struct CFG {
	//int nSize;
	TCHAR* szName = nullptr;
	//int cbName = 0;  //都不需要！
	int nValue = 0;
	TCHAR* szShortName = nullptr;
	//int cbShortName = 0;

	CFG() {}
	CFG(/*int sz,*/TCHAR* pName,/*int nLen,*/int nValue)
		:szName(pName), /*cbName(nLen),*/nValue(nValue){}
};

CFG cfg(_T("爱彼此"), 3);
	cfg.szShortName = _T("abc爱彼此");

	//CFG cfg( 3, 3);
	
	FILE* pfile = nullptr;
	fopen_s(&pfile, "abc", "wb");
	int len = sizeof(CFG);
	//int nWritten = 0;
	if (pfile) {
		fwrite(&cfg, len, 1, pfile); //直接能将TCHAR*写入
	}
	fclose(pfile);

	CFG rcfg;
	fopen_s(&pfile, "abc", "rb");
	int nRead = 0;
	if (pfile) {
		fread(&rcfg, len, 1, pfile); //好像TCHAR*是在栈上分配的delete会崩溃
	}
 

类型
类型转换
内置类型强转，负数的二进制表示；
reinterpret_cast运算对象在位模式上的重解释，如int *p; char *pc = reinterpret_cast<char*>(p); 骗过编译器，但不能当char*使用；
单参构造，类型 –》 类类型，只能一步；

类型分类
枚举
不限作用域
enum color{red,...}; //color以后就是一种类型了color eyes = green;
enum {red,...};
enum {red,...} eyes; //
限定作用域（c++11）
enum class/struct color{red,...};//color eyes = color::red;要加作用域

enum class intType{charType = 8, shortType = 16,...};// 默认0递增1
枚举值必须是constexpr，枚举变量必须是枚举值，枚举成员类型默认是int；

指定成员类型
enum intType : unsigned long long{ longType = 4294967295UL };

前置声明
enum color : int;//必须指明类型
enum class color;//默认int

enum可以给int赋值；

类成员指针
数据成员
class Screen {
public:
	typedef std::string::size_type pos;
	char get_cursor() const { return contents[cursor]; }
	char get() const{}
	char get(pos ht, pos wd)const{}

private:
	string contents;
	pos cursor;
	pos height, width;
};

const string Screen::*pdata = &Screen::contents;
pdata只是指向类的成员，并没有指向实际数据，只有解引用时才提供对象的信息；
static const std::string Screen::*data() { return &Screen::contents; }//返回成员指针
普通的是返回类的实际数据，所以不一样；
使用
auto s = Screen::data();
const string& str = myScreen.*pdata; //获取实际数据，注意myScreen可以是不同的

函数成员
	char (Screen::*pmf)(Screen::pos, Screen::pos)const;
	pmf = &Screen::get;

	Screen myScreen, *pScreen = &myScreen;
	char c = (pScreen->*pmf)(0,0);
   c = (myScreen.*pmf)(0,0);
类型别名
using Action = char (Screen::*)(Screen::pos, Screen::pos)const;
	Action pmf = &Screen::get;
一般应用如下
class Screen {
public:
	typedef std::string::size_type pos;
	using Action = Screen& (Screen::*)();
	enum Directions { HOME, BACK, FORWARD };
	Screen& move(Directions){ return (this->*Menu[cm])(); }

	Screen& home(){}
	Screen& back() {}
	Screen& forward() {}

private:
	static Action Menu[];
};

Screen::Action Screen::Menu[] = { &Screen::home, ... };
myScreen.move(Screen::Home);//调用

将类成员函数用作可调用对象
调用成员函数必须要用类对象或指针操作，所以它不是一个可调用对象，但可以用function/mem_fn/bind生成一个；
成员函数被隐式传递this形参，而算法经常是这样的：if(Pred(*it))，而function/mem_fn/bind让算法解释为 if(((*it).*p)())调用成员函数，
	
class Screen {
public:
	Screen(int n=0):m_size(n){}
	bool fun_callback() { return /*n > m_size*/true; }

private:
	int m_size = 3;
};
main:
   Screen s1(1),s2(2),s3(3);
	vector<Screen> vs = { s1,s2,s3 };//元素类型必须是Screen，不是很有用，fun_callback也不能有参数
	auto it = find_if(vs.begin(), vs.end(), mem_fn(&Screen::fun_callback));

   vector<int> v = { 1,2,3,4,5 };
	Screen a;
	using std::placeholders::_1;
	auto it = find_if(v.begin(), v.end(), bind(&Screen::fun_callback,&a,_1));//新函数的第一个参数（*it）传递给旧函数的第二个，旧函数的第一个绑定对象；
这样的话，就可以更灵活地使用类成员了
bool fun_callback(const int n) { return n > m_size; }

位域
程序向其它程序或硬件传递二进制数据时用到，位域在内存中的布局以及二进制能否压缩到一个整数，如何压缩都与机器相关；
typedef unsigned int Bit;
class File {
	Bit mode : 2;
	Bit modified : 1;

public:
	enum modes { READ = 01, WRITE = 02, EXECUTE = 03 };
	File& open(modes m) {
		mode |= READ;  if (m & WRITE) { return *this; }
	}
};

volatile
确切含义与机器相关，一般处理硬件的程序使用，这些变量的值在程序外可能改变，比如有个变量由系统时钟定时更新，volatile告诉编译器不要对它进行优化；

union
互斥值，任意时刻只有一个成员有值，不能有引用，不能继承自和做基类；
	union Token {
		int a;
	} token = { 1 }; 类内初始化
	union {//作用域内直接访问，不能包含访控属性和成语函数
		int n;
		float f;
		char c;
	};  f = 3.14;
c++11可以有类类型的成员了；
将union的值改为类成员或将类成员改为其他，都要显示调用构造和析构；
通常把含类成员的union内嵌到一个类中管理：

C++异常
try{
  throw 异常对象，如runtime_error(“a==b”);
  throw后面的代码不会执行，注意资源回收；
}catch(异常对象类型 runtime_error e){ e.what();
}catch(...)
catch到了，从catch之后的代码继续执行；
找不到catch，终止函数，向上一级匹配catch，知道找到，如果都没有，调用标准库的terminate，终止程序；
局部对象自动销毁，对象的析构自动调用；
继续向外抛出： catch(...) {  处理一些校验等操作；throw;  }
catch里的“异常声明”是通过异常对象初始化的，如果有多态用引用，否则会是基类，捕获时注意几个catch的排序；
捕获所有：catch(...) { }
构造函数的异常，P689；
noexcept异常说明，P690；

异常对象
标准库异常对象，P693；
自定义异常体系，P693；


STL/boost
手册 http://www.cplusplus.com/reference/
简要
序列（数组，容器。。）操作统一，begin，end，iterator，性能比内置数组快；
可变参数
getline要include<string>
算法
accumulate，equal。。。上百个
back_inserter插入迭代器
lambda，可调用对象
参数绑定
关联容器的key，无序容器的hash key，P626；
allocator类，内存分配和初始化分离；
vector是如何增长的，P317；
容器适配器就是STL实现的三种适配器模式：底层接口-》适配器接口-》客户使用；

算法
谓词
可调用的表达式，返回能用作条件的值；有一元（单参）和二元（接受两个参数）；算法对序列的元素调用谓词；
如，bool isShorter(const string& s1, const string& s2){ return ..}
sort(word.begin(), word.end(), isShorter);//算法接受二元谓词
find_if(..);//接受一元谓词
c++中有：函数，函数指针，bind创建的对象，重载了“()”运算符的类，lambda表达式（未命名的内联函数）等；

lambda
语法：[捕获列表](参数列表) -> 返回类型 {函数体}，定义了一个类类型的未命名对象，捕获列表是它的数据成员，如
	auto wc = find_if(v.begin(), v.end(),
		[sz](const string& s) {return s.size() >= sz; });
	//lambda产生如下类
	class SizeComp {
		SizeComp(size_t n):sz(n){}
		bool operator()(const string& s)const {
			return s.size() >= sz;
		}
	private:
		size_t sz;
	};
捕获列表只捕获函数中的局部非static变量，形参也是，创建lambda时拷贝值；返回类型只能尾置，函数体包含return之外的语句，则返回类型为void；
如，auto it = find_if(w.begin(),w.end(),[sz](const string& s){return s.size()>=sz;});
[v1]值捕获，[&v1]引用捕获，[=/&]隐式值/引用捕获，[=/&,v1..]混合，=/&必须在第一个；
参数绑定
多次编写重复lambda不是好的设计，但是捕获局部变量又不容易，于是出现bind，<functional>
auto newf = bind(f, arg_list);
arg_list中的_1是代表newf中的第一个参数，
如
bool check_size(const string& s, const string::size_type sz){
	return s.size() > sz; }
auto it = find_if(w.begin(),w.end(),bind(check_size,_1, sz));
占位符可以重排顺序；
绑定引用参数
默认bind是拷贝参数的，使用ref(参数)，返回可拷贝的对象；
如， for_each(b, e, bind(print, ref(os), _1, ‘ ‘)); //流不能拷贝;


tansform(v.begin, v.end, v.begin, [](){});改变每个元素；

标准库函数对象，P510，可以替换算法的默认运算符；
function模板，定义一类相同函数声明，P512；

迭代器
很多算法都有的入参，它是使算法不依赖容器的机制，有输入、输出、前向、双向、随机访问等迭代器类别，cplusplus官网上有它们支持的操作；
下面是生成一些迭代器的操作
插入迭代器
back_inserter，front_inserter，inserter，它们是谓词，返回迭代器，所以可以用在算法上；
流迭代器
	istream_iterator<int> it(cin), eof;
	vector<int> v(it, eof); //空格，tab，回车等分隔
	//while (it != eof) {
	//	v.push_back(*it++); //*int_it从流中获取值,++读取下一个
	//}
	for (auto& elm : v) {
		cout << elm << ' ';
	}
cout << accumulate(it, eof, 0) << endl;
标准库只保证在第一次解引用迭代器之前，完成读取操作；
vector<int> v = { 1,2,3,4 };
	ostream_iterator<int> oit(cout, "");//追加字符串””
	for (auto& e : v) {
		oit = e;//用<<写入到oit;
	}
任何定义了>>和<<操作的类型都可以定义迭代器；
class Sale {
public:
	string isbn;//编号
	float price;//单价
	int num;//数量
};
istream& operator >> (istream& is, Sale& sl)
{
	is >> sl.isbn >> sl.price >> sl.num;
	return is;
} 
main:
   cout << "isbn\tprice\tnumber" << endl;
	istream_iterator<Sale> it(cin), eof;
	vector<Sale> v(it, eof);

它和序列化的区别是，istream_iterator<Sale>模板类型，而序列化是每个类重写Serialize，所以后者可以灵活地写复杂对象；

反向迭代器
vec.rbegin(), rend(), rcbegin()...；

容器.begin()，end()，rbegin，cbegin。。。

容器
自定义key
set<T,Compare>，自定义类的话，提供<比较；
如，bool cmpIsbn(const Sale& s1, const Sale& s2) {
	return s1.isbn < s2.isbn;
}
main：istream_iterator<Sale> it(cin), eof;
	set<Sale,decltype(cmpIsbn)*> setSale(it, eof, cmpIsbn);

无序容器
它们不是使用<来组织元素，而是使用哈希函数和==运算符，容器将元素组织为一组桶，每个桶保存若干个元素，哈希函数hash<key_type>将元素映射到桶，空间换时间；
标准库提供了内置类型（包括string、指针、智能指针等）的哈希模板，自定义类型必须提供自己的hash模板类；
使用自定义类型
定义hash模板的一个特例化，
class Sale {
public:
	string isbn;//编号
	float price;//单价
	int num;//数量
   //friend class std::hash<Sale>;如果访问了私有成员
};
istream& operator >> (istream& is, Sale& sl) {
	is >> sl.isbn >> sl.price >> sl.num;
	return is;
}
bool operator==(const Sale& s1, const Sale& s2) {
	return s1.isbn == s2.isbn;
}
namespace std {
	template<>
	struct hash<Sale> {//特例化
		typedef size_t result_type;//返回类型
		typedef Sale argument_type;//参数类型
		size_t operator()(const Sale& s)const;//重载
	};

	size_t hash<Sale>::operator()(const Sale& s)const {
		return hash<string>()(s.isbn) ^ hash<float>()(s.price) ^ hash<int>()(s.num);
	}//使用内置hash模板生成hash值
};
main() ：cout << "isbn\tprice\tnumber" << endl;
	istream_iterator<Sale> it(cin), eof;
	unordered_set<Sale> setSale(it, eof);

tuple
“快速而随意”的struct；
	//struct{ string str; vector<double> vec; int n; list<int> li; };
	tuple<string, vector<double>, int, list<int>>
		someVal("abc", { 3,14,2.7 }, 42, { 0,1,2,3 });
	size_t sz = tuple_size<decltype(someVal)>::value;
	auto& v = get<1>(someVal);
//常见用途是从一个函数返回多个值

bitset
更容易使用的位运算；

其他
remove_if 删除vector
	int a[] = { 1,2,33,54,12 };
	std::vector<int> v(a, a+sizeof(a)/sizeof(a[0]));
	v.erase(std::remove_if(v.begin(), v.end(),
		[](int i) { return i == 33;  }), v.end());

boost
简要
结合boost文档和《boost程序库完全开发指南》；
官网下载www.boost.org；;
STLport
高效的可移植的c++标准库，它比VS实现的版本优秀不少；
www.stlport.org下载 STLport-5.2.1, vs2015编译不了；

boost
没有GUI库，RPC库，COM+，数据库，xml解析，高级网络通信协议库。。。日臻完美；
有些不需要库，有些需要，boost在VS下有自动链接技术（就是编译器自动添加#pragma comment(lib, XXX)），把lib放到vs能找到的地方；
还有一种嵌入工程编译：
#define BOOST_SYSTEM_NO_LIB  //去掉自动链接
#include <libs/system/src/error_code.cpp> 把代码拿来编译
工程配置C/C++   ->  General  ->  Include  :  D/Boost；

编译库
boost根目录，cmd：bootstrap ->  .\b2；
如果要分开编译，index.html手册；
编译好之后， 将stage\lib配置到工程链接库即可（自动链接技术）；
头文件包含目录；


时间
计时器
原始的Timer
工程配置include目录后，#include <boost\timer.hpp>,<progress.hpp>；
timer t; 开始计时，成员顾名思义；
F12转定义，clock() 返回自进程启动以来的clock数，由宏CLOCKS_PER_SEC定义，随系统不同；
_min , _max 说明了计时能力——只适合低精度，小跨度的时间测量；

progress_timer 加了个析构，自动输出（cout, stringstream, ofstream） ；
 多了一个换行问题 和 更改输出精度： 改源码（不建议）； 继承重写模板，P38；

progress_display d(v.size()); ++d; d += n;  显示进度，让用户有底，operator++ 和 operator+= 调用了显示函数；
如果有其它输出，会打乱进度显示，一个麻烦的手段就是restart，operator+= n，重新输出；

CPU Timer
boost已废弃原始的Timer库，改用CPU timer库；
编译不过；

date_time
时间点，时间段，时长，无限时间（pos_infin等枚举），无效时间（NADT）；
日期
1400-01-01 ~ 9999-12-31，基于格里高利厉；
boost::gregorian  <boost/date_time/gregorian/gregorian.hpp>
date d1(2017,3,28);
date d2(from_string("2015/1/1"));
date d3 = from_undelimited_string("20100708");
date d4(min_date_time);
date d5(100000, 1, 1);  //抛异常;
to_iso_extended_string(d1) //转字符串；
to_tm()  ,   date_from_tm() ;
day_clock::local_day() 本地时间;
时长
date_duration dd(2); //以天为单位的时长，别名days，还有weeks,months,years;
d1 -= days(1); //月末加减月也是到月末，时间点，时长，时间段之间的运算；
时段
date_period dp(date(2010,1,1),days(10)); //左闭右开，左>右：无效，api，P54或者F12顾名思义；
日期迭代器
day_iterator、week_iterator… 
时分秒
#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/date_time/posix_time/posix_time_types.hpp>
using namespace boost::posix_time;
微秒，纳秒（宏P60），time_duration，hours，minutes，seconds…；
hours h(1);
time_duration td = h + seconds(10);
td = duration_from_string("1 10 30 001");
//取负，特殊值，四则，精度...
ptime
ptime p(date(2010, 3, 5), hours(1));
time_from_string;
ptime p1 = second_clock::local_time(); //本地当前时间, universal_time() UTC时间
//四则，to_iso_extended_string(ptime)，转换tm, time_t，时间段，迭代器;

常用
你能想到的库里基本都有；
星期和中国的星期不一样，boost库以Sunday作为第一天；
高级
宏配置，P71；
格式化时间，P71；
世界各地的本地时间，P72；
序列化，P74；

内存管理
智能指针
shared_ptr 、 shared_array  ->  new  new[];
weak_ptr  shared_ptr的旁观者，不加引用计数，但可以获取资源；
内存池
pool库
析构释放资源，大量分配/释放小对象时使用，不用考虑delete；
pool，object_pool，singleton_pool（线程安全）;
#include <boost/pool/object_pool.hpp>
using namespace boost;
{
	pool<> p1(sizeof(int));
	int* p = (int*)p1.malloc();
	*p = 3;
}
{
	object_pool<demo> objp1;
	demo* d = objp1.construct(1, 2, 3);
   //目前最多支持3个参数，扩展，P105；
}
//单例，除非手动释放，程序生命周期，tag就是个标签；
typedef singleton_pool<struct tag, sizeof(int)> sp1;
int* p = (int*)sp1::malloc();
sp1::release_memory();

实用工具
定义不可拷贝赋值的类
#include <boost/noncopyable.hpp>
struct demo : boost::noncopyable

optional库
无效值管理，P116；

assign库
容器拷贝赋值初始化简化；
vector<int> v1;
push_back(v1), 1, 2, 3; //赋值初始化
map<int, int> m1 = map_list_of(1, 2)(3, 4); //拷贝初始化
初始化重复数据简化，P185；
vector<int> v1;
push_back(v1)(1).repeat(2, 2)(3).repeat(4, 4);
嵌套
int a = 1, b = 2;
vector<vector<int>> v1;
v1 += list_of(5)(6), list_of(7)(8);
引用初始化
vector<int> v2 = ref_list_of<2>(a)(b);

swap库
交换数组；
boost::swap(obj1, obj2);
struct demo {
	int a;
	demo(int x) : a(x){}
	void swap(demo& d) {
		std::swap(a, d.a);
	}
};

void swap(demo& d1, demo& d2){
	d1.swap(d2);
}
boost::swap(d1, d2); //可以找到特例化的高效swap版本（自己实现）

单例库
boost.pool ,  boost.serialzation P132;

操作符库
有operator+ 就有-，有小于，就有大于，等于，这些都可以自动实现，operators库， #include <boost/operators.hpp>  p141;
class demo : 
	boost::less_than_comparable<demo>,
	boost::equality_comparable<demo> //T=demo，自动实现！=
{
	int a,b;
public:
	demo(int x,int y) : a(x),b(y){}

	friend bool operator<(const demo& l, const demo& r){
		return (l.a + l.b) < (r.a + r.b);
	}

	friend bool operator==(const demo& l, const demo& r){
		return (l.a == r.a && l.b == r.b);
	}
};
基类链的写法
多重继承转为链式的单继承，解决钻石继承问题；
class demo : 
	less_than_comparable<demo,
	equality_comparable<demo,
	addable<demo
	>>>
{};
复合运算，P145
基类链太长，operators库提供常用的复合运算基类链：
totally_ordered 全序，组合了== 和 <;
additive 可加减   multiplicative 可乘除   arithmetic 加减乘除  unit_stoppable  ++ --;
class demo : 
	totally_ordered<demo,
	additive<demo
	>>
{};
相等和等价不一样，P146；
解引用，P148；
下标。。。

boost异常
P151，存在一些缺陷：自定义异常类冗余代码太多 ，异常对象不够灵活，输出异常信息不全 等；

uuid
P161；


字符串
字符与文本处理一直是std的弱项，正则、分词等高级特性；
lexical_cast库
#include <boost/lexical_cast.hpp>
str = lexical_cast<string>(d); //a100, 0x100, 123L等非数字字符不支持，自定义类要满足的要求，P181；
format库
#include <boost/format.hpp>
string str = "100";
cout << format("%s\n") % str; //匿名构造

format fmt("(%1% + %2%) * %2%\n"); //格式和printf一样，%05d, %-8.3f, %10s…  %|05d|%  ,  %N%占位符
fmt % 2; //灵活赋值
fmt % 5;
cout << fmt.str();
速度比printf慢 2~5倍；
参数绑定api：P189；
string_algo库
算法库，#include <boost/algorithm/string.hpp>
90%的功能都能满足，自己去找api， 前缀i：大小写不敏感，后缀copy：返回结果拷贝，后缀if：需要判断式谓词对象；
大致五类api：大小写，判断式与分类，修剪，查找与替换，分割与合并， P192；
tokenizer库
分词：把字符串分割成若干单词，P204，有缺陷，了解即可；
xpressive库
比regex更好，结合了boost.regex正则表达式解析器和boost.spirit语法分析器，P212，一个动态，一个静态（编译期进行语法检查）；
#include <boost/xpressive/xpressive.hpp>
using namespace boost::xpressive;
P214；
单元测试
test库
容器与数据结构
array，ref_array，multi_array；
dynamic_bitset，P259，
unordered 散列表替代二叉树，查找复杂度由对数降为常数；
bimap 双向映射容器，P275；
circular_buffer 循环使用的缓冲区， P285；
tuple；
any，可以被赋值任意类型的单个元素；
variant，可变类型，对union的增强；
property_tree，属性树，可以解析xml、ini、json、info等格式的文本数据；
算法
新增了 graph基于图数据结构的算法，gil图像处理算法，string_algo；
minmax， minmax_element  同时获取min，max值；
数学库
P351；
操作系统相关
io_state_savers库
流的状态管理，自动恢复或控制恢复时机，P385；

system库
操作系统api处理错误使用错误代码，system封装了底层的错误代码和错误信息；
#include <boost/system/error_code.hpp>
using namespace boost::system;
P389；

filesystem库
c++缺少文件处理，这往往需要shell、python、perl等脚本语言，filesystem在底层做了大量工作，使用POSIX标准，使c++拥有了类似功能，P394；
#include <boost/filesystem.hpp>
using namespace boost::filesystem;
base_path类操作 ， P395，path/wpath是它的别名；
   path p1("./");
	p1 /= "stdafx.h";//追加
	cout << system_complete(p1) << endl;//完整路径
	str = p1.string();
	bool b = windows_name(p1.string());
	b = portable_directory_name("abc.txt"); 
	b = portable_file_name("abc.txt");
	/*path成员: stem()不含扩展名的全路径.. is_complete()是否是绝对路径
	root_name(),  .....
	*/
filesystem 异常， P401；
file_status 文件状态， P403；
是否存在，文件类型。。。
文件属性，P404；
很多文件属性不是平台通用的，因此filesystem库只提供了少量的操作：current_path(),  file_size(),  last_write_time() ….
文件操作
	namespace fs = boost::filesystem;
	path p1("./");
	if (exists(p1))
		create_directories(p1 / "sub_dir1"/ "sub_dir1");//类似的工厂函数
递归遍历
recursive_directory_iterator end;//空的是逾尾
	for (recursive_directory_iterator pos(p1/"sub_dir1"); 
		pos != end; ++pos){
		cout << "level" << pos.level() << ":" << *pos << endl;
	}
实例：P408；

program_options库
命令行参数解析，程序配置选项，定制程序行为，用于编写脚本，执行复杂功能，P414；

函数与回调
bind，function等，已纳入c++11；
signals2,
线程安全的观察者模式，被称为信号/插槽signals and slots或 事件处理机制，一种函数回调机制，当信号发出时，所有关联的插槽都被调用；
#include <boost/signals2.hpp>
using namespace boost::signals2;
P460；

并发编程
Python库
序列化
把对象保存到文件中或通过网络发送，序列化-》二进制字节流；
简单应用
friend 和 serialize；

序列化多态
虚析构，BOOST_CLASS_EXPORT_GUID(derived_one, "derived_one")
给派生类取一个key，反序列化的时候就知道是什么类了；

序列化数组
boost会识别；

版本
如果类有了更新，之前的序列化如何兼容？

save和load分开
并不是所有序列和反序列是一样的操作；


RTTI
typeid(e) e可以是任意表达式或类型，<typeinfo>，返回常量对象的引用，其类型为type_info或其派生类，有成员name()；
忽略顶层const；数组或函数不是指针类型，有相应的类型；没有virtual的类就是静态类型，有的话运行时求得；
它的一个应用就是“类型敏感的operator==”
bool operator==(const Base& lhs, const Base& rhs){
  return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);
}

模板
简要
OOP是动态识别，模板是编译时；
编写类型无关的代码，两条重要原则：1，函数参数是const T&或T&&，这样你就可以传给它任何类型的实参（const或非const，临时对象，字面值常量）；2， 函数条件判断只用<符号；
编译器遇到模板定义时，并不生成代码，实例化的时候生成，编译器需要掌握函数或类模板成员函数的定义（通常放在头文件中），在多个.o文件中实例化相同的类型，会造成比较大的系统开销；
模板实例化可以写出来，如果脑子不够用了，void flip1(void(*fun)(int,int), int, int);


函数模板
template<typename T> 模板参数
T compare (const T& a, const T& b) ...
compare(1, 0); 实例化函数模板，编译器推断类型

非类型模板参数
template<unsigned N, unsigned M>
inline int compare(const char (&p1)[N], const char (&p2)[M]){ //... }

尾置返回类型
template<typename It>
auto fcn(It beg, It end) -> decltype(*beg) {//…} //返回类型的引用
如何返回类型而不是引用？
标准库的类型转换模板，P605；
template<typename It>
auto fcn(It beg, It end) -> typename remove_reference<decltype(*beg) >::type {//…} //返回类型的引用


类模板
编译器无法推断实参类型，要<TYPE>指定，编译器为每一种类型生成一个类，也是在调用的时候实例化；
类外定义
template<typename T>
ret-type  Blob<T>::Func-name( param-list) { }
简化 Blob<T>的使用
在类作用域内 Blob::， Blob& 和 Blob<T>&, Blob 和 Blob<T> 是一样的；
模板和友元
模板类对模板
template <typename> class BlobPtr; //T可以省略；
template<typename> class Blob;
template<typename T> bool operator==(const Blob<T>&, const Blob<T>&);// 因为参数要T，一个作用域内类型不重复，所以这里的T和下面的T不是一个；
template <typename T> class Blob{
  friend class BlobPtr<T>;
  friend bool operator==<T>(…);   //权限限制在相同类型；（相同类型）
  template<typename X> friend class Pal2;  //Pal2所有实例都是它的友元；（所有类型）
  friend class Pal3;
  friend T; //类型作为友元;
};
非模板类对模板
template<typename T> class Pal; //对特定模板的都要前置声明
class C{
  friend class Pal<C>; //权限限制在 以C实例化的Pal；（特定类型）
  template <typename T> friend class Pal2; //权限限制在Pal2的所有实例，无须前置声明；（所有类型）
};
模板类型别名
typedef Blob<string>  StrBlob，但是不能用在 Blob<T>，
新标准允许： template<typename T> using twn = pair<T, T>;
这样的话： twin<string>就是 pair<string, string>。。。
新标准可以说 加入了很多“需求变化之后”改动最小的代码；
模板静态数据
相同类型的对象共享一份，不同类型各一份；
模板参数
T::size_type * p，在定义一个变量p，还是在使用static 乘以 p？
template <typename T>
typename T::value_type  top(const T& c) { //…} //typename说明T是一个类型；
默认模板实参
template<typename T, typename F = less<T>>
int compare(const T& v1, const T& v2, F f = F()) { //… }
模板默认实参
template <typename T = int> …   Numbers<> N; //使用默认int类型;
成员模板
非模板类对模板
对于模板函数，就像普通的函数模板定义；
模板类对模板
template <typename T> class Blob{
  template < typename It> Blob( It b, It e);
};
template<typename T>
template < typename It> Blob<T>::Blob(It b, It e) { } //类外定义，类和成员有各自独立的模板参数；
Blob<int> a1(begin(a), end(a)); //实例化，函数模板编译器可以推断；
控制实例化
在实例化之前，声明extern template  declaration;  //否则编译器自动实例化;
在实例化的地方提供定义，template  declaration;
extern template class Blob<string>; //保证有一个.o 里面实例化过;
template  class Blob<string>;  //实例化;
模板实参推断
推断 T 的类型
忽略顶层const；
template <typename T> void f(T&&);  f(42);可以  f(i) 也可以；
引用折叠
将左值传递给右值参数，编译器推断类型为“类型的引用”，int& &&；
新标准规定：X& &，X& &&, X&& &都折叠成 X&；X&& &&折叠成 X&&；
右值引用通常用于：模板转发实参或模板重载；
转发
std::forward，保存实参类型的所有细节，const，左右值。。。；
template<typename F, typename T1, typename T2>
void flip1(F f, T1&& t1, T2&& t2)
{
	//forward保存实参类型的所有细节
	//T1int&,T2int
	f(std::forward<T2>(t2), std::forward<T1>(t1));
}
重载与模板
优先级：精确匹配 > 非模板 > 更特例化 > 转换

可变参数模板
可变数目的参数称为参数包（它是一种类型），分模板参数包，函数参数包；
template<typename... Args>//模板参数包，0~n个模板参数
void foo(const Args&... rest)//函数参数包,0~n个函数参数
{
	cout << sizeof...(Args/rest) << endl;
}
foo(i, d);
实例
template<typename T>
ostream& print(ostream& os, const T& t)
{
	return os << t;
}

template<typename T, typename... Args>
ostream& print(ostream& os, const T& t, const Args&... rest)
{
	os << t << ",";
	return print(os, rest...);//包扩展
}
main:
   int i = -1;
	string s = "hello";
	print(cout, i, s, 32);
包扩展
分解为构成元素，对每个元素应用“模式”，获取扩展后的列表，在“模式”后边放一个(...)触发扩展；
ostream& print(ostream& os, const T& t, const Args&... rest)
const Args& 是一种“模式”，(...)扩展为函数参数列表；
return print(os, rest...)
rest是实参“模式”，(...)扩展为实参列表；
return print(os, func(rest)...)
func(rest)是调用实参“模式”，(...)扩展为为每个实参调用func

模板特例化
通用模板并不对所有类型通用，可能编译失败或做得不正确，而且有时候为了高效，不希望使用通用的；
模板特例化就是将其中一个或多个模板参数指定为特定类型；
template<>
...
部分特例化，P628；


对象移动
左值：返回左值引用的函数， 连同= , [], 解引用, 前++/--等表达式，变量；
右值：返回非引用的函数，连同算术，关系，位运算，后++/--，取地址&p；
const int& r1 = i*2;  // 右值可以赋值给const左值引用
int&& r2 = i*2; // 正常的右值引用
int&& r3 = std::move(左值);  <utility> 移动左值（我们保证不再使用它了！）

	//拷贝构造
Foo();  Foo(const Foo&);  Foo(const Foo&, int a);
基本就是 bookNo(rhs.bookNo)....
直接初始化
string s(dots);  //匹配参数，选择构造
拷贝初始化
1,string s2 = s; //拷贝右侧对象，还有一次构造对象的机会，s2 = “99”, s2 = string(100,’9’);
2, 传入实参s1：Func(string s1,  const string&  s2/*只是个别名，什么也不调*/) {}
3，返回非引用类型：string Func(...){
	string nRet;
	return nRet; 
}
4，	标准库的列表初始化，push_back。。。


	//拷贝赋值
Sales s1 = accum  这是拷贝初始化，是初始化，
s1 = trans 这是赋值！
Foo& operator=(const Foo&);

	//移动构造
	//移动赋值
	//析构


移动构造和移动赋值
HasPtr(HasPtr&& h) noexcept : ms(h.ms)这里没有拷贝，是移动 { h.ms = nullptr; }
//标准库默认认为移动对象可能有异常，所以会有一些额外工作，noexcept指定没有，定义也要
//标准库只有在类没有定义任何拷贝控制成员时才合成移动操作，否则它们是=delete的
HasPtr hp2(std::move(hp)); //没有移动构造，右值也被拷贝

Foo operator+(const Foo& f1, const Foo& f2) {
	Foo f = f1;
	f += f2;
	return f;//返回即将销毁的变量，如果定义了移动构造就调用移动版本；
//非引用实参同理
}
StrVec& StrVec::operator=(StrVec&& rhs) noexcept{
///
}

类内swap的应用：swap笔记；

移动迭代器
标准库没有移动对象的操作，但是有移动迭代器，一些copy算法可以使用；
copy_if(make_move_iterator(v.begin()), 
		make_move_iterator(v.end()), 
		back_inserter(v2), [](string* i) {return true; });

移动函数
一般参数定义,const X&& 和 &&X;
   string s1 = "a value", s2 = "another";
	s1 + s2 = "wow";//右值被赋值了！
在自定义类中，可以通过在函数最后加 &或&&阻止给右值赋值；
class Foo {
public:
	Foo mem() const &{}//修饰this，它可以指向一个左值、&&右值
};
操作符重载
能重载的运算符
+-*/%^+= -=/=*=%=^=&=|=<<=>>=   [] () -> ->* new new[] delete delete[] &|~!  ,=<><= >=++ -- == !=  << >> &&||
不能重载的
::  .*  .  ?:

作为成员还是非成员
输入输出
class Foo {
public:
	Foo mem() const &{}

	int a = 1;
};
ostream& operator<<(ostream& os, const Foo& foo) {
	os << foo.a;
	return os;
}
   Foo foo;
	cout << foo << endl;
如果作为成员，那就是foo << cout << endl;
operator>>类似，不过读取操作多了错误处理；
复合、赋值
大多会修改源对象，一般是成员；
算术、关系
大多不太修改源对象，一般是非成员；
递增递减
前++大多修改源，一般是成员；
后++会调用前++，但是返回源（配合移动）
	Foo& operator++() {
		//检查是否可以加
		++a;
		return *this;
	}
	Foo operator++(int) {
		Foo ret = *this;
		++*this;//调用了前++
		return ret;//但是返回了之前的值
	}
成员访问*，->，下标
大多是返回类成员引用，一般是成员；
	string& operator[](size_t n) {
		return s[n];
	}	
   string& operator*()const {
		//检查指针
		return (*s)[a];
	}
	string* operator->()const {
		return &this->operator*();
	}
函数调用()
如果类定义了调用运算符，则该类的对象称为函数对象；lambda就是；
标准库定义了一些函数对象，<functional>中，如less<T>,logical_and<T>...常用来替换算法中默认的比较运算符；
可调用对象：函数、函数指针、lambda、bind创建的对象、重载了operator()的类，它们都有各自的类型，但是可以共享同一种调用形式（返回类型+实参类型个数），如
   int add(int a, int b) { return a + b; }
   auto mod = [](int i, int j) {return i%j; };
   struct divide {
  	   int operator()(int a, int b) { return a / b; }
   };
main()：
   map<string, int(*)(int, int)> binops;
	binops.insert({ "+", add });
	binops.insert({ "%",mod });
	binops.insert({ "/",divide() });//int(*)(int,int)是函数指针类型，和函数对象类型不同
<functional> ， function类型（调用形式类型）；
   map<string, function<int(int,int)>> binops;
   binops.insert({ "-",minus<int>() });
	binops.insert({ "*",[](int i,int j) {return i*j; } });

类的设计
分析
设计一个类与使用一个类，谁先？
对于一个项目，你会先进行需求分析，用例图，流程图，开发工具环境，类设计，数据库。。。同样的，在具体实现一个类之前，我们也应给出这个类的使用场景，应该怎么用，接口好用不?
你可以这样：
列举程序的功能
当程序读文件时，CXX类，调用XX接口...
2）分析数据流
	我们用vector<string>保存整个文件的输入...
3）类的设计
c++11/boost 提供了许多新特性，大部分是简化、清晰代码的，也有很多最大化代码复用的特性，要时时回头迭代；


基本数据类型的设计
范围，越界size_t
是否要和系统结构，数据类型结合使用，WSABUF char* 
潜在的类型转换，计算u+i，传参，。。。
float，double精度问题
前后缀 primerP37  L’a’  42u, 1e-3f....
//其它

类的成员设计
形参加const；&
合理重载；const与非const的const_cast调用，重载操作符指导，P491，P493；
inline能够避免函数调用的开销，因为它直接“贴上代码”
constexpr常量表达式；
访控属性
把你的操作封装成“盒子”，防止用户修改。
类中的public/protected/private是决定派生类/外界能不能访问；继承方式是决定父类中方法或属性在子类中的访控。
final成员函数，阻止覆盖，P538；


需要类自己的类型成员吗？ typedef...  public or private
需要可变数据成员吗？ mutable
需要static成员吗？static在整个继承体系中只有一份，派生类也能继承，遵循通用的访问控制， P271；
要与类之间共享数据吗？ shared_ptr
需要操作符重载吗？ 《primer》P491 P493
接口好用吗？
用模板是否可以更通用？
private:  do_XX小函数的技巧使用了没？
需要友元类/函数吗？友元是无法继承的。


构造，拷贝，赋值，析构，移动
默认构造=default，类没有任何构造，则编译器生成一个默认构造；若定义了其它构造，则不生成，要自己提供；=default的作用就是让编译器显示生成合成版本（这样类内成员初始化就可以用了、默认内联）；
=delete阻止拷贝，以前是private+只声明不定义；
委托构造（构造调构造）；
单参构造，在需要类的地方，用低一级的参数替代，只允许一步，explicit可以抑制，只能直接初始化（两种初始化：X x(直接), X x = 拷贝，都调用拷贝构造）；
直接初始化和拷贝初始化(operator=)；
是否需要swap，这样的话operator=，排序算法等就能受益；
移动构造，不必要的拷贝，流或unique_ptr等不能拷贝，std::move，P472接管资源，左值右值，配合operator=，P478； 
类类型  ->  其它类型，operator type() const，P514;
注意虚析构；


继承，多态，类之间的依赖
抽象基类
Impl方法解决依赖： private: shared_ptr<PersonImpl>  pImpl;  《Effictive C++》
访问控制，public（程序可访问数据），protect（派生类可访问），private（类可访问），friend（其它类或函数可访问private）；
派生说明符 :public/protect/private，并不会影响派生类访问基类，而是影响使用派生类的用户的访问权限；
友元关系无法传递和继承；
阻止继承：class CAbc final{//...};
静态类型与动态类型：print(Quote& q); Quote是个基类，我们说q的静态类型是Quote& ，如果传给参数一个派生类Bulk_quote&，则q的动态类型是Bulk_quote&；
虚函数机制
每个类都有一张vtbl虚函数表，静态的，保存了所有类成员函数的地址；每个类的对象都有一个vptr虚函数表指针，指向vtbl；
对于class Deive : public Base1, public Base2,public Base3{};  Deive 有4个vptr，3个指向基类的vtbl；
对于虚函数，子类如果重载了，就替换父类版本放在前面，未重载的放在虚函数后面；
 
 
Derive d;  Base1* b1 = &d;  Base* b2 = &d;//使用b1的vptr
b1->f(); //派生   b1->g();//基类
dynamic_cast(QueryInterface)
	Derive d;
	Base1* b1 = &d;
	b1->g();//b1
	Derive* p = dynamic_cast<Derive*>(b1);
	p->h();//b1中也有h,但是转成子类后调了子类的h

	Base2* b2 = dynamic_cast<Base2*>(b1);
	b2->g();//b1也有g,但是调了b2的
前提条件是， b1（基类指针或引用） = &d（子类指针或引用），然后dynamic_cast在转这个b1！


CAbc* p = new CAbcd;  p->普通成员函数，调用CAbc的；p->虚函数，调用new对象实例的；
override
class CAbc{
public:
	virtual int f() { return 1; }
};
class CAbcd : public CAbc {
public:
	virtual int f(int a) { return a; }//不小心写错形参列表，这是可以的（返回值不行）
};
在子类中加上virtual int f(int a) override { return a; }//报错
名字查找与继承
对于p->mem()或obj.mem()，解析过程如下：1，确定p或obj的静态类型，在静态类型的类中查找mem，如果找不到，一直向上查找基类；2，找不到mem报错，找到则检查能否调用，如果能，编译器执行动态分析（虚函数）；
虚析构
多重继承与虚继承
多重继承和单基类类似，虚继承为解决一个问题：钻石继承，则派生类中将包含该类的多个子对象；
class Bear : virtual public ZooAnimal{//... } //承诺派生类共享一份ZooAnimal；
class Raccoon : virtual public ZooAnimal {//...}
class Panda : public Bear, public Raccoon, public Endangered{ //.. }
虚继承构造顺序：虚基类ZooAnimal，Bear，Raccoon，Endangered，Panda；



设计模式的使用
良好的设计与高效的代码
表驱动
今天是这个月的哪一期
int nSession = 0;
	int arrSession[] = { 1,2,3 };//期数;
	int upLimit[3] = {10,20}; //上限;
	upLimit[2] = DAY_OF_MONTH[p->tm_mon];
	while(arrSession[nSession] != 3)
	{
		if(p->tm_mon > upLimit[nSession])
			++nSession;
		else
			break;
	}

优化代码
	 if (@nStarLevel>=1 and @nStarLevel<6)
	   set @nDotPrice=10000
	 if (@nStarLevel>=6 and @nStarLevel<11)
       set @nDotPrice=20000
	 if (@nStarLevel>=11 and @nStarLevel<21)
       set @nDotPrice=30000	
     if (@nStarLevel>=21 and @nStarLevel<31)
       set @nDotPrice=40000
     if @nStarLevel=31
	   set @nDotPrice=50000

	int nLevel[] = {1,6,11,21,31};
	int nDot[] = {0,10000,20000,30000,40000,50000};
	int nLen = sizeof(nLevel)/sizeof(nLevel[0]);

	int i = 0;
	int l = 31;
	while(nLevel[i] <= l && i < nLen)
	{
		++i;
	}
	
	l = nDot[i];

constexpr常量表达式
在编译过程就能算出来的常量，如果不是则编译报错；编译时处理能减少运行时开销，如果你认定变量是常量表达式，就用constexpr；
和const的区别：const是运行时不被修改，constexpr是修饰“那段代码”的；
constexpr函数，P214；
字面值常量类，P267；
decltype/const
decltype(变量)  不忽略顶层const
 顶层const 指针本身； int* const p1 = &i;
 底层cosnt 所指对象；const int* p2 = &i;
const int ci = 32; 一层是顶层
auto忽略顶层，手动加const，引用；
decltype(表达式)  求值结果是左值得引用类型，右值就是结果类型；
decltype((表达式)) 得引用类型

int odd[] = {1,3,4};
decltype(odd)  int[5]
decltype(odd)* int(*)[5]
int fun(int);
decltype(fun)*  int(*)(int) 函数指针
文件包含
任何包含了.h的文件(.h或.cpp)，只要该.h发生了变化，依赖就要重编。
如果你只是需要一种关系而不用访问定义，使用前置声明代替#include。

文件包含顺序
同名.h
c系统文件
c++系统文件
其它库文件
本项目内文件

STL
顺序容器emplace_X比push_X快一点；
map.insert({“+”, add}); //

swap
自赋值
T& T::operator=(const T& t){  delete ps;  ps = new string(*(t.ps)); //... }//如果t和*this是同一个对象，那就崩了；
标准库的swap
T temp = v1;  v1 = v2;  v2 = temp; //两次拷贝
自定义类swap
class HasPtr {
	string* ms;
	int mn = 0;

	friend void swap(HasPtr& h1, HasPtr& h2);
public:
	HasPtr(const string& s = "") : ms(new string(s)){}
	HasPtr(const HasPtr& h) : ms(h.ms){}
	HasPtr& operator=(HasPtr h) { //HasPtr& 则会改变源，如果传入std::move(hp2);则优先调用HasPtr(HasPtr&& h)noexcept:ms(h.ms){}
      swap(*this, h); //没有自赋值
      return *this; }
};
inline void swap(HasPtr& h1, HasPtr& h2)
{
	using std::swap;
	swap(h1.ms, h2.ms);
	swap(h1.mn, h2.mn);
}
功能函数
取值抉择
template<typename TV, typename TM>
inline TV chROUNDDOWN(TV value, TM Multiple>{
  return ((value/Multiple)*Multiple);
}
15, 73  ->  0  向下取最近的一个73

template<typename ...>
inline TV chROUNDUP(...){
  return (chROUNDDOWN(value,Multiple) + (((value%Multiple)>0) ? Multiple : 0));
}
132, 65536  ->  0 + 132%65536>0 = 65536
向上取最近一个65536

判断标志位
bool IsBitSet(const long& flag, const size_t pos) {
	const bitset<32> bs(flag); //const才会返回bool
	if (pos >= 0 && pos < bs.size()) {
		return(bs[pos]);
	}
	return false;
}


正则表达式
概念
Partial Matches
匹配正则的一部分，输入可能还没有完全（比如键盘输入，正在读取文件，内存映射文件，socket等等），
ECMAScript 语法
字符
.  任意单个字符（除位置字符，换行符）
\t tab  \n换行  \r回车 \0 null字符
\0ddd  \xhh  \uhhhh UNICODE字符
\int		引用，和匹配结果一模一样
\d 数字  \D非。。
\s 空白符 \S 非。。
\w 单词		\W。。
\l [a-z] \L， \u[A-Z] \U， \h 水平空白符 \H，\v，\V
\character 转义字符  
[] 字符集合
[[:name:]] 字符类blank/alnum/cntrl/digit/graph/print/punct/unicode/。。。
[[.col.]] 集合元素 ?
[[=col=]] 等价元素，如[[=a=]]，匹配a, À, Á, Â, Ã, Ä, Å, A, à, á, â, ã, ä and å
元字符： ^ $ \ . * + ? () [] {} |，即特殊含义字符，要转义
-	[a-z]
^   [^a-z]
|  或
\pX 匹配有X属性的字符, \PX，\p{name}X属性名，\P{name}，如\pd->[[:digit:]];
\G 只在开始匹配之前和最后一个匹配之后?；
\Q*+\Ea+，\Q后面字符没有特殊含义，\E结束；

注意：c++中\\d 才是\d！

数量
*     	0,more
+		1,more
?		0,1
{int}		int个
{int,}		int, more
{min, max}  	[min, max]

注意：默认是贪婪匹配(匹配最多)，数量后加”?”，非贪婪；
数量后加”+”，贪婪匹配，不回溯；


位置
^	行首
$	行尾
\b	单词边界 \B 非。。。
<单词开始，>单词结束
\`或\A  buffer边界开始，\’或\z结束，buffer就是用来匹配的整段文本
\1-9，回溯引用，和匹配结果一模一样，\g{n}一个意思，\g{11},\g{-2},\g{name}


组
(subpattern)    子表达式，可以被引用或重复
(?:subpattern)   不创建
(?<name> subpattern) 命名子表达式
(?#...) 注释
(?|subpattern)  在每个”|”重置子表达式序号
# before  ---------------branch-reset----------- after
/ ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
# 1            2         2  3        2     3     4

 (?= subpattern)   前边查找：前边字符必须满足subpattern，后边才会匹配；
(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,} 密码
(?! subpattern)    必须不满足；
(?<=subpattern)   后边查找：后边字符必须满足；
(?<!subpattern)
(?>subpattern)  不回溯，引擎找最匹配的结果，提高性能的；
(?’NAME’ subpattern)  命名组，\g{NAME}回溯，Format，search，replace，match_result等都能使用；
(?N)，(?-N)，(?+N)，(?R)，(?0) ，(?&NAME) 递归
(?(condition)yes-pattern|no-pattern) 条件
格式化的时候，"(?1<font color=\"#008040\">$&</font>)"


组件
regex 
regex r(string, f); f语法控制标志，默认ECMA，还有regex::icase，nosubs不保存匹配的子表达式，optimize执行速度优于构造速度；
r = re;  r.assign(re,f);  r.mark_count();子表达式数  r.flags()标志集  
boost 语法控制标志
regex_constants::normal
在手册syntax_option_type下

regex_match/regex_search方法
整个序列匹配,true/有子序列匹配,true；
(string, smatch, regex, mft);
(string, regex, mft);
mft 匹配控制标志，默认format_default用ECMA，还有match_not_bol(begin of line)不将首字符作为行首处理，match_not_eol，match_not_bow不将首字符作为单词首处理，match_not_eow，match_any返回任意一个匹配，match_not_null不匹配空序列，match_continuous匹配必须从输入的首字符开始，match_prev_avail输入序列包含第一个匹配之前的内容，format_no_copy不输出未匹配的内容，format_first_only只替换第一个子表达式；
boost在手册match_flag_type下

regex_grep
bool grep_callback(const boost::match_results<const char*>& m)
{
	if (m[0].matched == false)
	{
		// save position and return:
		next_pos = m[0].first;
	}
	else
		++tags;
	return true;
}
boost::regex_grep<bool(*)(const boost::cmatch&), const char*>(grep_callback,
		static_cast<const char*>(buf),
		static_cast<const char*>(buf + read + leftover),
		e,
		boost::match_default | boost::match_partial);


sregex_iterator
sregex_iterator it(b,e,r);将it定位到第一个匹配位置，sregex_iterator end尾后，*it;const smatch对象引用，it-> 非const的；

boost::sregex_token_iterator
匹配符号
boost::regex e("<\\s*A\\s+[^>]*href\\s*=\\s*\"([^\"]*)\"",
	boost::regex::normal | boost::regbase::icase);

string s = "< a href = \"www.baidu.com\" > abc  < a href = \"www.sina.com\" > abc";
	const int subs[] = { 1, 0, };

	boost::sregex_token_iterator i(s.begin(), s.end(), e, subs);
	boost::sregex_token_iterator j;
	unsigned count = 0;
	while (i != j)
	{
		std::cout << *i++ << std::endl;
		++count;//有4个
	}


bool regex_callback(const boost::match_results<std::string::const_iterator>& what)
{
	// what[0] contains the whole string
	// what[5] contains the class name.
	// what[6] contains the template specialisation if any.
	// add class name and position to map:
	class_index[what[5].str() + what[6].str()] = what.position(5);
	return true;
}
	boost::sregex_iterator m1(text.begin(), text.end(), expression);
	boost::sregex_iterator m2;
	std::for_each(m1, m2, &regex_callback);//对每个匹配

smatch
m.size()上次匹配的子表达式数，整个算一个，m.empty()，m.prefix()一个ssub_match对象，匹配之前的序列，m.suffix()匹配之后的序列，m.format(string)，m.length(n)第n个匹配的子表达式大小，越界不会挂，m.position(n)距离序列开始的距离，m.str(n)匹配的字符，m[n]对应ssub_match对象，m.begin(()/m.end()m中sub_match元素范围的迭代器；
注意：索引为0是整个匹配；prefix/suffix保存全部；
m.end() – m.begin() == m.size(); 

ssub_match
子表达式的匹配，matched是否匹配，first/second匹配序列的首/尾后元素，注意它们是属性，length()匹配大小，str()；



regex_replace方法
(dest输出迭代器, seq, r, fmt, mft); //格式化替换
string  (seq, r, fmt, mft);
string fmt = “$2.$4..”; // match_results::format : $n,$&,$`,$’,$$
match_results
$` -> m.prefix() 前缀
$& -> m[0] 全部
$n -> m[n] 子表达式n
$’ -> m.suffix() 后缀
\\ 和 $是一个意思；
boost手册format syntax上有；

m.format(dest,fmt,mft);//匹配在m里
string  m.format(fmt,mft);
vs2015都不支持这种格式化，还是boost好	
   boost::regex e1;
	const char* pre_format = "(?1mynew)(?2mydelete)";
	try {
		e1.assign("(new)|(delete)");

		const string filename = "testRegex.txt";
		string test;
		load_file(filename, test);

		std::ostringstream t(std::ios::out | std::ios::binary);
		std::ostream_iterator<char, char> oi(t);
		boost::regex_replace(oi, test.begin(), test.end(),
			e1, pre_format, boost::match_default | boost::format_all);
		string str = t.str();
		str = "";
	}
	catch (...)
	{
		return -1;
	}

实例
笔记
正则的编译是非常慢的，构造和赋值可能都非常耗时，所以注意权衡；
c++11支持得不够完全，不建议使用，还是用boost的；
#include <boost/regex.hpp>

c++11
	string pattern("colou?rs?'?s?");
	regex r;
	try {
		r.assign(pattern);	//运行时才会解析语法是否正确
	}
	catch (regex_error e) {//cplusplus网站有code()从0开始
		cout << e.what() << ' ' << e.code();
	}

	string test = "color, colour, colors, ....";
	for (sregex_iterator it(test.begin(), test.end(), r), endIt;
		it != endIt; ++it) {
		string& result = it->str();
	}

"<[^>]*>" 匹配html标签

匹配类名
typedef std::map<std::string, std::string::difference_type, std::less<std::string> > map_type;

const char* re =
// possibly leading whitespace:   
"^[[:space:]]*"
// possible template declaration:
"(template[[:space:]]*<[^;:{]+>[[:space:]]*)?"
// class or struct:
"(class|struct)[[:space:]]*"
// leading declspec macros etc:
"("
"\\<\\w+\\>"
"("
"[[:blank:]]*\\([^)]*\\)"
")?"
"[[:space:]]*"
")*"
// the class name
"(\\<\\w*\\>)[[:space:]]*"
// template specialisation parameters
"(<[^;:{]+>)?[[:space:]]*"
// terminate in { or :
"(\\{|:[^;\\{()]*\\{)";


boost::regex expression(re);
map_type class_index;

bool regex_callback(const boost::match_results<std::string::const_iterator>& what)
{
	// what[0] contains the whole string
	// what[5] contains the class name.
	// what[6] contains the template specialisation if any.
	// add class name and position to map:
	class_index[what[5].str() + what[6].str()] = what.position(5);
	return true;
}
main：
boost::sregex_iterator m1(text.begin(), text.end(), expression);
	boost::sregex_iterator m2;
	std::for_each(m1, m2, &regex_callback);

Partial Mathces
boost::regex e("<[^>]*>");//匹配html标签
unsigned int tags = 0;
const char* next_pos = 0;
bool grep_callback(const boost::match_results<const char*>& m)
{
	if (m[0].matched == false)
	{
		// save position and return:
		next_pos = m[0].first;//只匹配到部分，文本就断了
	}
	else
		++tags;
	return true;
}
void search(std::istream& is)
{
	char buf[4096];
	auto len = sizeof(buf);
	next_pos = buf + sizeof(buf);
	bool have_more = true;
	while (have_more)
	{
		// how much do we copy forward from last try:
		std::ptrdiff_t leftover = (buf + sizeof(buf)) - next_pos;
		// and how much is left to fill:
		std::ptrdiff_t size = next_pos - buf;
		// copy forward whatever we have left:
		std::memmove(buf, next_pos, leftover);
		// fill the rest from the stream:
		is.read(buf + leftover, size);//读取size，凑4096
		std::streamsize read = is.gcount();
		// check to see if we've run out of text:
		have_more = read == size;
		// reset next_pos:
		len = sizeof(buf);
		next_pos = buf + sizeof(buf);
		// and then grep:
		boost::regex_grep<bool(*)(const boost::cmatch&), const char*>(grep_callback,//只匹配到部分就结束也会调用
			static_cast<const char*>(buf),
			static_cast<const char*>(buf + read + leftover),
			e,
			boost::match_default | boost::match_partial);
	}
}

ui属性正则
class CUICfg {
public:
	//设置ui属性
	virtual CUICfg& operator& (const std::string& s) = 0;

protected:

private:
	//ui正则回调
	virtual bool regex_callback(const boost::smatch& what) = 0;

public:
protected:
	std::shared_ptr<std::string>			m_uicfg;//ui配置
private:

};
boost::regex g_regexUI(
	"textpoint\\s*[-:,./]\\s*([0-9]+)|"//字体大小
	"textcolor\\s*[-:,./]\\s*(RGB[^@]+)|"//字体颜色	
	"ctrlbgcolor\\s*[-:,./]\\s*(RGB[^@]+)"//控件背景色
);
CMyStatic1& CMyStatic1::operator & (const std::string& s)
{

	if (!m_uicfg)
		m_uicfg = std::make_shared<std::string>();

	(*m_uicfg) += s + '@';

	boost::sregex_iterator it(m_uicfg->begin(), m_uicfg->end(), g_regexUI), itend;
	//对每一个匹配结果，虽然会有重复调用，但是对于ui配置这种次数不影响效率
	//std::for_each(it, itend, &CMyStatic1::regex_callback);如果要使用类成员就要static，使用了static就用不了数据成员
	for (; it != itend; ++it) {
		regex_callback(*it);
	}

	return(*this);
}
bool CMyStatic1::regex_callback(const boost::smatch& what)
{
	//what[1] 字体大小
	//what[2] 字体颜色
	const int uicfgCnt = 3;//ui配置项数
	//std::bitset<uicfgCnt> bts;
	
	int i = 0;//匹配的属性
	for (i = 1; i < uicfgCnt; ++i) {
		if (what[i].matched)
			break;
	}

	switch (i) {
	case 1:
	{
		LOGFONT ft;
		m_font.GetLogFont(&ft);
		ft.lfHeight = stoi(what[1].str());
		m_font.DeleteObject();
		m_font.CreateFontIndirect(&ft);
		break;
	}
	case 2:
	{
		m_colorText = GetRGBfromString(what[2].str());
		break;
	}
	case 3:
		m_colorCtrlBG = GetRGBfromString(what[3].str());
		break;
	}

	return true;
}
//控件自定义属性
	m_static1 & "textpoint,15" & "ctrlbgcolor-RGB(255,0,0)";

随机数
C
#include <ctime>
srand(unsigned(time(0)));

double CreateRandom(double start, double end)
{
	return start + (end – start) * rand() %  (RAND_MAX + 1.0);
}
rand() 产生 [0 ~ RAND_MAX) 之间的整数。

(a,b) (rand()%(b-a+1))+a-1
[a,b) (rand()%(b-a))+a
(a,b] (rand()%(b-a))+a+1
[a,b] (rand()%(b-a+1))+a
¬ 
C++新标准
rand的问题：1，随机浮点数；2，非均匀分布数；3，一些非随机性；
<random>
随机数引擎类：生成unsigned随机数；随机数分布类：生成服从特定分布的随机数；
default_random_engine + 合适的分布类 代替 rand；
default_random_engine e; 
for (int i = 0; i<10; ++i)
	cout << e() << endl;  //每次生成都一样
Engine e;  		 //构造引擎
Engine e(seed); 	 //种子
e.seed(s);
Engine::result_type //生成的随机数类型
e.discard()   e.min() e.max() 引擎随机数范围
配合分布类
default_random_engine e;
uniform_int_distribution<unsigned> u(0, 9); //均匀分布
for (int i = 0; i<10; ++i)
	cout << u(e) << endl;  //用引擎e生成均匀分布，每次一样
static  default_random_engine e;

INT_MIN  边界值

这样每次都不一样
设置种子也可以不一样，常用的是time(0)
随机实数
default_random_engine e((unsigned)time(0));
uniform_real_distribution<float> u(0, 1);
非均匀分布
P781 类似uniform_real_distribution的分布类型，



命名空间
//xx.h  #include <string>里有namespace std，所以不要包含
/*xx.cpp 可以有两种定义
1，直接打开namespace定义；
2，cplusplus_primer::Sale_data cplusplus_primer::operator+(...){//...}
template<> struct std::hash<Sale_data>{//...};
*/
namespace cplusplus_primer {
	/*
	1，它是一个作用域，不同域名字可不同，域内唯一
	2，可不连续
	3，可以有 类，变量，函数，模板，命名空间。。。 声明，定义
	*/
	//全局命名空间：在所有类、函数、namespace之外定义的名字，::访问
	/*内联命名空间：可以不加FifthEd前缀
	inline(写在第一次) namespace FifthEd{//...}
	有一种空间组织形式： 
	namespace cplusplus_primer{
	#include "FifthEd.h"
	#include "FourthEd.h"
	}
	*/
	//命名空间别名：namespace 别名 = 空间名;
	/*std::cin >> s;
	给函数传递一个类类型的对象时，除了常规查找外，还会查找实参类所属的命名空间；
   //匿名，namespace{};  本文件有效，其中的变量是static的
	*/
}



内存管理
直接管理内存
语法： new (地址) type [size] {初始化}

string* pstr = new string("hello");
三个操作，调用标准库operator new函数->构造->返回指针
我们可以重载标准库的new，也可以自定义，自定义new必须位于全局或类内，在类内隐式声明为static；
定位new
就是在内存中new一块地址，然后根据程序的需要，将大小适合的实例对象放到此内存块中操作的方法
char* buf = new char[sizeof(Foo) * 3];
Foo* pb3 = new (buf + (sizeof(Foo) * 2)) Foo(2);//使用已经new好的
pb3->writeFoo();
内部使用operator new(size_t , void*);

内存耗尽
int* n = new(nothrow)  int; 不抛出bad_alloc异常，返回nullptr；

自定义new
operator new(size_t,  Type…)
void* operator new(size_t size, const char* file, int line)//声明
Foo* p1 = new(__FILE__, __LINE__) Foo;//传递参数
全局可以，但是类内的话，delete调用有问题，一定要Foo::operator delete(p1, __FILE__, __LINE__);这样调；

new const对象
const string* pcs = new const string;

new数组
new T[N];
new string[10]{“a”,string(3,’x’)};

智能指针
shared_ptr
shared_ptr多个指针指向同一个对象 <memory>；
auto sp = make_shared<string>("abc");
shared_ptr<T> p(q);  p = q; //p，q的引用计数都会变

和new结合使用
auto sp(new int(5)); //必须直接初始化
sp(u); //接管unique_ptr
sp(q, d);//接管内置指针，并用可调用对象d代替delete
sp.reset();//若sp是唯一指向，则释放sp  sp.reset(q, d);

和动态数组配合
unique_ptr<int[]> up(new int[10]); //P425，shared_ptr要自定义删除器才能管理，好在标准库推荐使用vector，list等容器，实际并不常用这种管理；


unique_ptr
unique_ptr独占对象，某个时刻只能有一个unique_ptr指向一个对象；
	//只能直接初始化，不支持拷贝，赋值
	unique_ptr<double> up1(new double(3.14));
	auto up2(up1);//错误
	auto up3 = up1;//错误
unique_ptr<T, D> u(new T, d);
u.release();//u放弃控制权，返回指针，如果不接管，会有资源泄露！
u.reset();//u释放对象
u.reset(q);//u接管内置指针q

不支持拷贝和赋值规则有一个例外：我们可以拷贝和赋值一个将要被销毁的unique_ptr（即移动）；
unique_ptr<int> clone(int p) {
	unique_ptr<int> ret(new int(p));
	//...
	return ret;
}

weak_ptr
weak_ptr指向shared_ptr管理的对象，不改变引用计数；
weak_ptr<T> w(sp);
w.use_count() shared_ptr的数量，w.expired() use_count=0返回true，w.lock() expired返回true，则返回一个空shared_ptr，否则返回sp；
它的应用大概就是sp还存在吗？
if(auto sp = wp.lock()){  //...  }

智能指针的应用
1，对于那些没有析构如struct，结构类似于new，delete，如建立释放连接，将删除器定义为释放操作是很有效的方法
void f(destination& d, ...) {
	connection c = connect(&d);
	shared_ptr<connection> sp(&c, end_connection);
	//使用连接，f退出后也能释放连接
}

allocator类
	const int n = 10;
	string* const  p = new string[n];//默认构造一次
	string s;
	string* q = p;
	while (cin >> s && q != p + n) {//有时候并没有n个
		*q++ = s;//赋值构造一次
	}
	const size_t sz = q - p;
	delete[] p;
allocator类将内存分配和对象构造分离开，这样我们可以先分配大块内存，然后按需构造对象；
	allocator<string> alloc;
	auto const p = alloc.allocate(n);//分配大块内存，返回指针
	auto q = p;
	alloc.construct(q++,"hi");
	alloc.construct(q++, 5, 'c');

	while (q != p) {
		cout << *(--q) << ' ';//使用
	}

	while (q != p) {
		alloc.destroy(--q);
	}
	alloc.deallocate(p, n);//一定要先destroy

创建对象的一些算法
	uninitialized_copy(b,e,b2);//从迭代器b,e拷到b2
	uninitialized_copy_n(b,n,b2);//拷n个
	uninitialized_fill(b,e,t);//填充值t
	uninitialized_fill_n(b,n,t);

深入理解计算机系统
前言：
所有的计算机系统都有相似的硬件和软件组成，它们执行相似的功能。
					——因此，你只要学通这本书，^_^




概念
系统如何存储信息？
代码都是 像这样的:
#include …			一个字母就是 8 位字节
printf(..);
class XXX{};
<div …></div>
Python、Java、C#....
磁盘文件、程序、用户数据、网络数据… 系统的所有信息，都是一串位。
每一字节都是可寻址的内存，计算机用一个整数关联；

程序是如何运行的？
先生成.exe
	预处理器 把.h … 内容直接插入  ->  					.i
	编译器 把代码 翻译成 标准的描述机器语言的文本  ->  	.s
	汇编器 翻译成 机器指令并打包成 -> 					.o（可重定位）
	链接器 printf … 在 xx.o 中（c编译器提供），合并  ->		.exe

在了解下系统的硬件组成
 

最后，程序如何执行
cmd 里输入 hello.exe或者双击exe…  shell执行一系列指令把 磁盘中的程序加载到 主存（CPU是一直在运行主存中的指令的，exe已经是机器指令了）


缓存的重要性！
指令： 磁盘  ->  主存 ， 主存  ->  CPU
数据（”hello,world!”）： 磁盘 -> 主存，  主存   ->  显示器
避免无用的复制  ->  缓存
L0   寄存器
L1	 高速缓存		->  存放L0 近期可能用到的信息
L2	 高速缓存		-> 	…
L3   	…
主存
本地磁盘
远程磁盘


操作系统是什么？
应用程序  和  硬件  之间的一层软件；
多个进程的运行
操作系统跟踪进程运行的所有状态信息（上下文），CPU的上下文切换 造成多个进程同时运行的假象；
虚拟内存
每个进程都有4G地址空间，为什么？第九章
虚拟机
一台虚拟的机器 放在你的系统里：包括 操作系统、硬件；
作用：1，实验性地操作，因为它不会影响你原来的
	  2，装其它系统，UNIX… 
Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

信息的表示 和 程序的机器表示
进制转换 
	2/8/16转10 ：0x200   ->   2*16^2 + 0 * 16 + 0 * 16^0   
	10转2/8/16：43  ->  43除2/8/16 取余 
	8/16转2： 0327  ->  3是011,  2是010， 7是111
	
字长 
long 和 指针的大小 4/8 字节
字节序
w是8的倍数，最高有效位[x_(w-1)… x_(w-8)]，最低[x_7…x_0]；
小端（Intel兼容机，最低-最高），大端（最高-最低）；
	网络传输，小端机器发送给大端；
掩码
	一个位，选出相应的位集合；

COM
概述
1991年Microsoft引入OLE对象链接与嵌入技术（容器嵌入组件，容器链接文档），比如excel表格放到word中，OLE1版本推广了文档可以作为其他程序功能组件的容器的思想；
1993年Microsoft推出COM，并用COM重建了OLE，形成OLE2版本，从此OLE技术不再局限于对象链接与嵌入，功能逐渐强大，变成桌面系统上程序通信的一个技术统称了，比如OLE剪贴板、OLE可视化编辑、OLE拖放、OLE自动化、OLE控件；
1995年，Microsoft为Internet推出了ActiveX（把OLE技术作为ActiveX销售，ActiveX加入了对Internet的支持）；
1996年，Microsoft发布DCOM（分布式），为通过网络连接的计算机在二进制级别上提供对象通信服务；
1997年，COM和MTS（微软事务服务器）开发小组合并，发布COM+，增强了COM和DCOM；


组件的优势：
1，	二进制可重用，搭积木式开发
2，	分布式
3，	语言无关，用C++开发的COM，很容易在Java等其他语言中使用
4，	进程透明
5，	
想想看，现在的软件大多要多个产商互相配合，模块已不再是代码集了，而是自给自足的组件，它们可以在一台机器、局域网、Internet的任何机器上；


应用：
1，	Windows操作系统已经大量使用，如DirectX软件包，DAO数据访问对象（VS支持OLE DB/ADO开发），网络库。。。
2，	
组件化的思想
一个实例
假设有个类通过dll导出给客户使用，
class CDB;
首先，它的成员一览无余！
其次，类改变了数据成员，或者成员大小，虽然你给了dll拿去替换，但是.h没有进入exe中，会造成崩溃！

基础概念
将复杂的应用程序设计成一些小的、功能单一的组件模块，组件之间可以 跨进程、跨机器、跨语言、甚至跨操作平台 进行通信；

 
组件由接口构成，接口是一系列函数的集合，客户实际是与COM对象交互，COM对象就是继承接口，有属性接口的类实例，但是客户只知道接口；
CLSID，COM对象的标识；

 

 
客户创建组件并拿到接口（其实是创建COM对象），实例数据同vtbl指针一块保存，
 
pA1和pA2是同一个类（组件），
 
pA和pB不是同一个组件，但是都有同一个接口，


IUnknown
 
所有COM接口都继承自IUnknown，
 
CA::this和IX*是同一个，实现IUnknown的三个接口只实现一次，

最简单的QueryInterface实现：
HRESULT __stdcall CA::QueryInterface(const IID& iid, void** ppv)
{ 	
	if (iid == IID_IUnknown){
		*ppv = static_cast<IX*>(this) ;   //组件的IUnknown就是内存结构的首地址
	}
	else if (iid == IID_IX){
		*ppv = static_cast<IX*>(this) ;
	}
	else if (iid == IID_IY){
		*ppv = static_cast<IY*>(this) ;
	}
	else{
		*ppv = NULL ;
		return E_NOINTERFACE ;
	}
	reinterpret_cast<IUnknown*>(*ppv)->AddRef() ; //引用计数
	return S_OK ;
}
IX* pIX = NULL ; 
hr = pIUnknown->QueryInterface(IID_IX, (void**)&pIX) ; //引用计数非常合理，确实有人在引用
IY* pIYfromIX = NULL ;
hr = pIX->QueryInterface(IID_IY, (void**)&pIYfromIX) ;
从pIX请求IID_IY，其实不管哪个指针请求的，都是(IID_IY*)(this)，只要pIX是CA*，

 
接口的引用计数意味着要调用相应接口指针的AddRef/Release，
好处：1，便于程序调试（找到资源泄漏）；2，资源按需分配释放（不过聚合更优）


HRESULT
 
设备代码标识代表的操作系统部分，保证错误代码不冲突，而自定义代码就不保证了，
winerror.h包含所有错误码（包括COM及OLE等），如果HRESULT返回具有FACILITY_WIN32设备代码的值，那你可能找不到它的记录，因为它是win32错误代码映射成HRESULT的，如0x80070103，找它的低16位即可，
FormatMessage输出文本描述，
HRESULT注意：
成功和失败返回可能有多个，不要hr==S_OK，要SECCEEDED(hr)，
失败代码可能会变化，如将进程内组件升级为远程，会有网络错误，

自定义HRESULT
设置FACILITY_ITF，表示与接口相关的，
 
MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 100);



注册表
COM只使用HKEY_CLASSES_ROOT，
其下有：
CLSID
	InprocServer32
	ProgID
(ProgID)SAPI.SpPhraseBuilder.1

ProgID一般格式：<Program>.<Component>.<Version>
与版本无关的ProgID、与CLSID的转换，

自注册
dll导出 DllRegisterServer 和 DllUn...，
regsvr32.exe、安装程序等都调用它们，
使用：
对于dll组件，
regsvr32 组件路径 -》调用DllRegisterServer
Regsvr32 /u 组件路径
对于exe组件，程序必须支持/RegServer和/UnregServer命令行参数，大小写无关，’/’和’-‘一个意思，
MessageBox(0, L"hello", 0, MB_OK); 可以打日志，但是断点进不去；


组件类别
一个接口集合，CATID，方便客户找到所需组件，
实现：windows自带的Component Category Manager，CLSID_StdComponentCategoriesMgr，
OleView工具，vs2015-》tools-》，第一次运行要以管理员运行，
《Com技术内幕，chap06》，



进程内组件
	创建组件
CoCreateInstance  CLSCTX_INPROC_SERVER，创建组件并返回接口；它的不灵活性表现在：没有提供一种控制创建过程的方法（工厂，一调用就创建好了），
其封装了CoGetClassObject，
《COM技术内幕-》Chap7》简单的组件注册（不成功进步了断点）和使用CoCreateInstance的实例代码，

为了更灵活，引入类厂
CoGetClassObject(CLSID,IID,PVOID) 和 CoCreateInstance 类似，只是前者会创建组件的工厂和IClassFactory，IClassFactory2（具有安全性）；实际上后者用前者实现，想想就知道了，
灵活性：1）用其他IClassFactory；2）创建多个组件实例，只要创建类厂一次；3）创建的前后提供更多的控制；

CoGetClassObject伪代码：
if 进程内组件
	调用dll的DllGetClassObject
类厂-》类厂创建组件，
else if 进程外组件
	启动组件进程，带上”/Embedding”命令行参数，函数等待，直到组件将类厂注册到COM库，
-》返回类厂代理-》创建组件，

CoCreateInstanceEx，返回多接口，




包容与聚合
包容
再实现一个接口，调用另一个组件的接口，前后还可以加些控制，《技术内幕-》P144，chap8实例代码》，
对象的生存期控制：构造时创建包容对象，优化-》需要时创建，


聚合
看一个问题先：外部组件有IX，IY，内部组件有IY，IZ，如果客户查询IY接口时，只是 return m_pUnknownInner->QueryInterface(iid,ppv);当通过IY查询IX时，就会失败，有一条规则是：QI返回的总是同一个IUnknown*，不然接口无法互相获取；


聚合的实现
组件不用实现内部组件的接口，客户通过外部组件的QI同样可以查询内部组件接口：else if(iid == IID_SomeInterface){ return m_pUnknownInner->QueryInterface(iid,ppv); }

 
客户请求得到接口指针，但再QI->IUnknown确实不一样的，并且从ISomeInterface请求不到IOtherInterface，

CoCreateInstance等API有一个IUnknown* 指向外部组件，非空即表示组件被聚合，
对于支持聚合的组件，要实现两个IUnknown，代理和非代理（委托和非委托），直接使用的IUnknown为非委托，委托在不同情况下有不同表现：1）正常使用，把调用传给非委托IUnknown；2）聚合使用，把调用传给外部IUnknown；

代码：
1，	NondelegatingQueryInterface(...) 请求IID_IUnknown时，转成INondelegatingUnknown*，因为IUnknown只能有一个，且是外部的，
2，	委托IUnknown：
if m_pUnknownOuter != 0
return m_pUnknownOuter->QI / AddRef / Release。。。
   else return NondelegatingQI / AddRef /Release。。。 
3，	类厂创建外部组件时，Init初始化创建内部组件（优化：需要时创建）并将外部组件作为参数传入，并请求内部组件的IUnknown接口，
4，	聚合组件的构造，
5，	引用计数
《COM原理与应用》P108，chap4，

P139


进程外组件
	进程间通信方法：动态数据交换（DDE）、命名管道、共享内存等，COM使用本地过程调用（LPC），它基于RPC的一种“同一机器上进程间通信”的方法，RPC被DCOM用于跨网络进程通信，
	LPC由系统实现，因为系统知道进程的逻辑地址及对应的物理地址，
	大部分win32 API调用都用到LPC：调API-》客户与一个模仿组件的dll（代理）通信，调dll函数-》dll函数通过LPC调实际代码，因为跨进程，故系统代码非常安全，
	组件1 、 代理dll（同组件2行为相同） –》 代理dll能访问组件1进程空间，
组件2 、 残根dll  -》 残根dll能访问组件2进程空间，
所以除了CoGetClassObject需要额外参数外，客户调用进程外组件和进程内组件没什么区别；
	对跨越进程边界的接口，我们需要考虑的东西有：
1，	一个进程能调用另一个进程的函数；2，传递数据；3，客户用相同方法调用；
将函数参数传到另一个进程的地址空间中的方法叫做“调整”，IMarahal，即列集和散集；
 


IDL/MIDL
功能1：接口描述语言提供了一种不依赖任何语言的接口描述方法，因此可成为组件和客户之间的共同语言；
功能2：IDL对接口和组件描述之后，用MIDL编译即可得到相应的代理和残根dll（主要目的），所以很多地方都和“函数参数调整”有关，
语法
[
	object, //COM接口
	uuid(32bb..-b41b-...),
	helpstring(“IX Interface”),
	pointer_default(unique)
]
interface IX : IUnknown
{
	HRESULT Func([in, string] wchar_t* szIn);
	//...
};
学习标准COM接口的IDL定义是学习IDL编写的极好方法

	pointer_default
告诉编译器，在没有为指针指定其他属性时如何处理此指针，
ref 指针当成引用，总是指向合法地址，函数内部不能指定别名，
unique 指针可为空，不能别名，
ptr 指针就是一个c指针，

	in, out, [in,out] 输入输出参数

	string 字符串，MIDL查找末尾\0决定长度

	#import 同include，但不用担心重复包含问题，

	size_is数组元素个数
HRESULT  Fun([in] long sizeIn, [in, size_is(sizeIn)] long arr[]);
sizeIn必须是[in]或者[in,out]，尽量避免使用[in,out]参数，


	结构
可定义c++结构作参数，如 struct Point3d { double x,y,z; };
[out] Point3d*  pt
MIDL需要精确知道指针所指的内容，所以不要使用void*作参数，

	iid_is  告诉MIDL相应接口的IID为何
若要传递一个一般性的接口指针，可以使用IUnkown* + IID，如：
HRESULT GetIface( [in] const IID& iid,  [out, iid_is(iid)]IUnknown** ppI);


编译IDL
midl  foo.idl
如果idl中有library语句时，MIDL将生成类型库，
 
P225，makefile使用上面文件生成dll和exe组件的过程，
P226，生成并登记代理残根dll，


库定义
库定义可以把一组数据类型（interface，coclass，typedef等）组织到一个空间中，它们都将被符号化，放在类型库中；
一个IDL文件最多一个library语句;
import “xx.idl”; 导入其它声明
[
  uuid(...) 库GUID， version,  lcid地域,  helpstring库名。。
]
library XX
{
  importlib(“xx.tlb”); 导入类型库
  [[uuid(...)]
  coclass XX{  ...   }
  //其它
}

列集


安全性机制
windows平台上，COM使用windows NT的鉴定服务机制，NT系统上所有的资源都是受保护的，如文件、外设、进程、同步对象、注册表。。。受保护指的是它们与特定的访问权限关联，访问它们时，系统要验证权限，以便允许或禁止；
《VC++COM》，P108；


多线程



异常
COM提供api，SetErrorInfo 抛出， GetErrorInfo 捕获；
IErrorInfo， CreateErrorInfo， ICreateErrorInfo，MSDN；
抛出的异常，直到被捕获之前，COM库都会保存它的一份引用；
代码示例： P74；
把COM异常映射到c++异常，P77；

枚举器
class IEnum<T> : public IUnknown{
 Next(...);
 Skip(...);
 Reset();
 Clone(...);
};
是一个COM类，有具体的实现，如IEnumString，IEnumUnknown。。。

使用：
1，	获取枚举器；2）while遍历；3）释放；



可连接对象（源对象）
概念
客户请求的接口，这是入接口，这种单向通信功能单薄；组件主动与客户通信，这是出接口；

出接口由客户实现，实现的对象叫接收器sink；
 
 

源对象实现IConnectionPointContainer{ 枚举/获取连接点对象 }，获取不支持的连接点返回CONNECT_E_NOCONNECTION，

连接点枚举器：IEnumConnectionPoints{ Next, Skip, Reset, Clone  }

连接点：IConnectionPoint { 获取IID，获取容器，建立/取消连接，枚举连接 }

连接枚举器：IEnumConnections{ CONNECTDATA{ IUnknown*, DWORD}，4常客 }

建立连接的过程
1）	客户创建对象，QI(IID_IConnectionPointContainer...)，询问是否支持出接口
2）	pConnectionPointContainer->查找(IID_出接口,...)是否有出接口，pConnectionPointContainer->Release
3）	pConnectPoint->Advise(接收器sink, &dwCookie)建立sink与源对象的连接
4）	取消连接，释放对象。。。

COM已经提供了IDispatch的代理和存根对象，所以它可以直接用于进程外源对象的出接口；



实现
用IDispatch作为出接口，为什么？
1）	通常组件和客户是独立开发的，客户编译的时候并不知道对象支持哪些接口
2）	IDispatch可以用名字访问属性和方法，支持迟邦定（不用编译期）

        Invoke( 
            _In_  DISPID dispIdMember,分发ID
            _In_  REFIID riid,
            _In_  LCID lcid,
            _In_  WORD wFlags,属性还是方法
            _In_  DISPPARAMS *pDispParams,参数信息
            _Out_opt_  VARIANT *pVarResult,返回信息
            _Out_opt_  EXCEPINFO *pExcepInfo,
            _Out_opt_  UINT *puArgErr) = 0;

实现出接口
从IDispatch派生，把属性方法加入，并赋予分发ID；
源对象暴露出接口的类型信息，如类型库.tlb，或IProvideClassInfo接口；
源对象激发事件或请求，传入正确的入参和出参，调用Invoke即可；

事件映射表
如果编译时就知道客户应该响应哪些事件或请求，则可以建立一张表，把DISPID和接口方法放入表中，即“事件映射表”；
脚本语言的引擎用动态绑定的；

自动化
概念
实现IDispatch就是自动化对象；

COM库及COM API使用的一些数据类型在其他语言中很难表达，如结构体指针函数指针等，所以要想在其他语言比如VB中编写或使用COM对象常常非常困难，其次VBA（VB for Application）已经成为Microsoft程序如office的扩展，而VBA通过自动化访问程序的数据，所以程序要实现IDispatch，方便暴露内部数据和功能供客户访问；

类型库 & ODL
组件对象的类型信息有：CLSID、接口IID、接口成员函数、函数参数、返回值类型。。。，所有与外界交互的必要信息，客户知道了这些才能使用组件；

ODL是IDL的扩充，用来描述类型信息的；
接口描述同IDL，自定义数据类型可以用C，一个ODL可描述多个组件对象（通常放在一个ODL）；
经过MIDL或MkTypLib工具可编译得类型库；
《COM原理与应用》，P336，Point组件的ODL描述

类型库干嘛用的？
1）	VBA使用它浏览组件对象的属性和方法
2）	VS类向导读入可生成C++代码供客户使用




IDispatch
Invoke
牺牲速度与编译时类型检查，带来灵活性，对于进程内组件，vtbl接口比调度接口快100倍；C++开发用vtbl好，IDispatch只是更通用，VB和Java等都能用；

Invoke( 
 DISPID dispIdMember,分发ID，-7-0有特殊意义，
 REFIID riid, 必须IID_NULL
 LCID lcid,本地化标识
 WORD wFlags,属性还是方法 DISPATCH_METHOD
 DISPPARAMS *pDispParams,参数信息
 VARIANT *pVarResult,返回信息
 EXCEPINFO *pExcepInfo,异常信息
 UINT *puArgErr) = 0; 产生错误的参数索引

由于自动化对象提供DISPID机制，所以动态绑定属性和方法 并进行参数类型检查成为可能；

VARIANT
自动化的方法和属性必须使用VARIANT类型（VARIANTARG等价），虽然没c++好用，但它考虑了其他弱语言；
CY 货币类型、DATE日期（double整数1899/12/30至今的天数，小数为时间值）
BSTR 4B（字符长度）LPTSTR，SysAllocString系列API专门处理BSTR
SAFEARRAY 各种数组，SafeArrayAllocData系列20左右API
{
    USHORT cDims;维度
    USHORT fFeatures;标识
    ULONG cbElements;每个元素大小
    ULONG cLocks;锁个数
    PVOID pvData;数据
    SAFEARRAYBOUND rgsabound[ 1 ];每一维度的边界
  } 	SAFEARRAY;

参数类型转换
VariantChangeType(Ex)、Var<type>From<type>、DispGetParam

DISPPARAMS
    {
    VARIANTARG *rgvarg;参数数组类型
    DISPID *rgdispidNamedArgs;命名参数的ID
    UINT cArgs;参数个数
    UINT cNamedArgs;命名参数个数
    } 	DISPPARAMS;
对于属性，一般rgvarg就一个，方法0-n个；如果vt没有指定VT_BYREF，那就是只读的入参，否则是出参；

rgvarg参数顺序与客户调用相反：
Object.Method(arg1,arg2,arg3) –》rgvarg[0] = arg3...

可选参数
ODL用(optional)标记可选参数，它在DISPPARAMS中也会出现，Invoke检查vt是否为VT_ERROR ， scode 是否为DISP_E_PARAMNOTFOUND判断可选参数；

命名参数
不受次序约束，和定位参数不能交叉，对于客户调用，必须先指定定位参数了；
假设：BSTR CompareWord（int no，BSTR Word1，BSTR Word2，BSTR Word3）;
Obj. CompareWord（3，Word1=”dog”，Word2=”pig”，Word3=”elephant”）;

rgdispidNamedArgs
Invoke如何决定命名参数的参数顺序呢？
一旦函数声明了，类型库中每个方法的参数都有参数id，从0开始，如CompareWord，Word1参数id=0...，然后rgdispidNamedArgs = 0,1,2；

特例
Invoke执行属性设置时，DISPPARAM = { cArgs = 1,cNamedArgs = 1, rgdispidNamedArgs[0] = DISPID_PROPERTYPUT, rgvarg[0] = 属性值 }

IDispatchEx
IDispatch描述了静态的类型信息，对于一些脚本语言，我们需要动态提供类型信息，如VBScript、JavaScript；

实现自动化对象
客户是方便了，但实现者有一些工作要做；

提供类型库支持
编写ODL，《COM原理与应用》P346，有一个；
编译生成.h和.tlb，如：MIDL /h <header>.h /tlb <library>.tlb <file>.odl –》VS会生成在“中间目录”里；

实现IDispatch的GetTypeInfoCount和GetTypeInfo，《COM原理与应用》P347，大致就是：加载.tlb到内存-》通过GUID获取ITypeLib、ITypeInfo；

实现Invoke
实现GetIDsOfNames
if/switch或者表映射，或者用ITypeInfo::GetIDsOfNames，P350；

实现Invoke
P346把接口分为IPoint和DIPoit是为了分离“业务逻辑”和“IDispatch实现”，P352的伪代码有助于理解；
客户使用自动化对象的流程：
 
用CreateStdDispatch实现自动化对象
上面的方法是基于“tlb”类型信息的，而OLE是提供了一个标准IDispatch实现的，用CreateStdDispatch获取；

P356，大致流程：1）为我们的自动化对象添加Init，方便类厂调用，Init使用CreateStdDispatch获取IDispatch接口；2）为对象的QI添加IID_IDispatch；

异常
Invoke 出参，如果Invoke异常，会填充它；
对象要么填充该结构，要么交给客户提供的回调，回调的好处就是可以“只关心感兴趣的”，避免不必要的资源；

typedef struct tagEXCEPINFO {
    WORD  wCode; 错误码=(wCode==0?scode:wCode) 
    WORD  wReserved;
    BSTR  bstrSource;错误源ProgID
    BSTR  bstrDescription;错误描述
    BSTR  bstrHelpFile;帮助文件路径 WinHelp API
    DWORD dwHelpContext;帮助ContextID
    PVOID pvReserved;
    HRESULT (__stdcall *pfnDeferredFillIn)(struct tagEXCEPINFO *);
    SCODE scode;
} EXCEPINFO


Invoke通过类型库实现的话，P354，1）中间变量；2）OLE接口ICreateErrorInfo和IErrorInfo；


本地化
LCID，影响：1）字符串资源的表达、比较等；2）日期时间表达；3）货币格式；

每种语言的LCID与它的语言ID、子语言ID、排序ID及版本号有关，winnt.h列出了语言ID及LCID位结构说明；


自动化对象应用
双接口
客户通过IDispatch::Invoke能访问对象的所有方法和属性，但是Invoke内部有层层处理，如参数检查、类型信息处理等，效率损失很大，对于VB，Java等语言没办法，而对于C++的客户，他们是希望直接通过vtable调用对象成员的，因此有了“双接口”；
P358有一份参考；

自动化集合对象
一组同类对象（或数值）的容器对象，P360；

以IDispatch作出接口
ODL在coclass给出接口加上source属性；
大致过程：1）自动化对象调用IDispatch::Invoke激发事件；2）sink实现IDispatch::Invoke处理各种事件；

 自动化编程
实例：PointComp.sln；
新建MFC DLL工程-》类向导，添加MFC Class
如果我们的自动化对象要暴露到外面并能被类厂创建的话-》“Create by type ID即ProgID”；

CCmdTarget实现的IDispatch没有用到类型库，而是“分发映射表”，因此不支持多语种；

实例：MFCSampleExe.sln;
向导-》基于对话框-》除了Automation，其他都不勾-》删除主dlg和DlgProxy文件、IDD_资源、代码dlg相关的，如#include<dlg.h>、idl文件的IExe声明；
Per-User Rediection  Link->Gernel，再编译一次就没了；

添加属性和方法
打开Class View，右键类对象；

实例：MFCCALC.sln
 《COM原理与应用》，ch11
自动化组件 及其客户，整个逻辑非常清晰；


COleDispatchDriver
避免复杂的Invoke调用，方便客户使用；
两种用法：
1）	向导-》Add Class-》From a type library，选择.tlb文件，选择接口-》自动生成继承自 COleDispatchDriver的自动化接口；
2）	如果我们已经获取到一个IDispatch接口，那用AttachDispatch与COleDispatchDriver联系，调用InvokeHelper、Set/GetProperty；


多线程
窗口被创建线程所有，所以窗口过程按消息顺序执行，不用同步；
COM使用了win32线程模型：用户界面线程和工作线程，对应“套间线程”和“自由线程”，一个进程的用户界面线程可以有多个，一个用户界面线程关联着n个窗口，COM类似，区别在于：参数调整与线程同步；
一个套间是一个由用户界面风格的线程（套间线程）和一个消息循环构成的，它像“装饰模式”一样套在外面，圈定范围；
 
对于客户在进程内使用的组件，套间线程即被圈定在进程边界，使用COM库之前和之后调用Co(Un)Initialize即可，

 
一个套间只有一个套间线程，像用户界面拥有创建窗口一样，套间拥有组件；像消息一样，一个线程调用组件方法时，COM把调用请求放到组件的套间线程队列中执行，所以不用考虑同步问题，
自由线程创建的组件可以被任意线程访问，同步要组件自己控制，


P274
对编程有实际指导作用
概念


创建组件工程
简易数据库
接口文件一般提取到一个目录下，因为客户和组件都要包含；
因为不能用_declspec(dllexport)修饰DllGetClassObject等——在Objbase.h中已经使用了其他修饰，所以.def 要在工程属性-》链接中添加，否则没有.lib生成；

《visual c++》，P67，chap2,，DB组件，DBComp.sln，
新建dll工程，把文件拖进去稍加修改，组件类，组件工厂类，接口.h，
新建客户工程，main函数里一套流程：创建组件，使用，释放。。。
注意GUIDS.CPP的定义，INITGUID，DEFINE_GUID，公共文件提取出来，
注：如果创建win32 DLL工程，遇到编译时dllmain重定义，可以把_USRDLL预定义宏去掉；
extern “C” 没有写；


字典组件
《com原理与应用》，P87，chap3，流程介绍，
1）将接口声明提取到公共部分，如interface\...
2）GUID声明使用DEFINE_GUID
GUID一般放在组件主.cpp 和 客户要使用的地方定义，如：
// {54BF6567-1007-11D1-B0AA-444553540000}
extern "C" const GUID CLSID_Dictionary =  //客户那要定义，用到就要给定义，声明
		{ 0x54bf6567, 0x1007, 0x11d1,
		{ 0xb0, 0xaa, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00} } ;
在接口.h中声明，
// {54BF6569-1007-11D1-B0AA-444553540000}
extern "C" const GUID IID_SpellCheck;
在组件.sln中添加GUID.CPP，#define INITGUID，#include “接口.h”...
这样，只要在接口.h中使用一次DEFINE_GUID宏，在组件这里就是定义接口，而在客户那里，就是声明；

字典组件DictComp.sln
1)	接口.h，类厂.h，注册表.h，COM组件对象.h，其它GUIDS.CPP，.DEF，。。。
2)	调试组件注册过程，组件工程属性，debugging，command + Arguments（-u $(SolutionDir)$(Configuration)\$(TargetFileName)），regedit程序不能开着，否则DllRegister失败！ 但是用powershell命令行调用失败（其实是DictComp.dll，但我写了DBComp.dll，这个dll还没写好呢！）

客户程序
1），接口.h，GUIDS.CPP，。。。
2），使用组件：CoGetClassObject、CoCreateInstance的伪代码，
进程内：COM库优化结构-》CoLoadLibrary-》DllGetClassObject-》。。。
进程外：。。。


CoMath组件
MathComp.sln，详见笔记《使用向导》；


在MFC中使用COM
概述
	为什么MFC使用嵌套类？
1，	MFC尽量避免多继承
2，	遇到一些问题：1）接口函数重名，很难实现它们；2）继承一个接口实现有时不是想要的
3，	效率问题：1）vtable、pVtl必须开销；2）编译器为多继承生成隐藏代码；




头文件
<unknwn.h>  IUnknown、IClassFactory...
<Wtypes.h>  COM数据类型...
<objidl.h>  标准接口idl...
<comdef.h>  标准接口及COM和OLE内部对象的CLSID...
<objbase.h>  COM API...
<ole2.h>  ole辅助API...

宏
DECLARE_INTERFACE(iface) 声明接口，它不从其他接口继承
DECLARE_INTERFACE_(iface,baseiface) 从baseiface继承，
STDMETHOD(method)声明接口方法method，返回值HRESULT，
STDMETHOD(type, method)返回值type，


接口映射表
MFC使用嵌套类实现组件，在DictComp.sln中，我们可以通过宏一步步简化，这都是CCmdTarget类提供，《COM原理与应用》，P153；
1）接口映射表定义
DECLARE_INTERFACE_MAP() 类似消息映射表
定义“接口列表”, “接口表（基类+本类）”
“接口列表”元素 = { IID, 与this的偏移 }

BEGIN_INTERFACE_MAP(CDictionary组件对象类,基类CCmdTarget)
INTERFACE_PART(CDictionary组件对象类,IID_IDictionary,嵌套类名Dictionary)
嵌套类：
class XDictionary : public IDictionary{
//方法
}n)m_dictionaryObj;
END_INTERFACE_MAP()

2）嵌套类定义
BEGIN_INTERFACE_PART(嵌套类名Dictionary,接口名IDictionary)
INIT_INTERFACE_PART(CDictionary组件对象类, 嵌套类名Dictionary) //QI...
STDMETHOD_...
END_INTEFFACE_PART_STATIC(嵌套类名Dictionary)



聚合
CCmdTarget实现IUnknown，包括内部和外部IUnknown，<afxwin.h>，
使用COM聚合：
1）	声明聚合变量IUnknown*
2）	在接口映射表中加入INTERFACE_AGGREGATE宏
3）	在CCmdTarget::OnCreateAggregates()初始化成员变量
《MFC internal》P368，聚合实现，


COM引出函数与类厂
引出函数
如果在AppWizard中勾选了“Automation”，则自动生成DllGetClassObject，DllCanUnloadNow，DllRegisterServer，
DllUnRegisterServer要自己实现，


类厂
COleObjectFactory ： public CCmdTarget，MFC的通用类厂，实现了IClassFactory2；
AfxOleRegisterServerClass注册单个COM对象；COleObjectFactory::Register注册进程外组件类厂到全局对象表；
《MFC internal》，P381;
小技巧：用AfxOleRegisterHelper更新注册表；


3）为组件添加内嵌类厂
DECLARE_OLECREATE()
IMPLEMENT_OLECREATE()

DllGetClassObject如何找到类厂的？
在IMPLEMENT_OLECREATE中，COleObjectFactory的构造函数将类厂加入到“全局状态结构”的类厂表中（AFX_MODULE_STATE），然后根据GUID找到类厂；
oledll.cpp  有AfxDllGetClassObject实现；


使用向导
创建工程
MFC dll-》Automation；
如果要创建进程外COM，MFC exe-》基于对话框，把对话框部分删掉即可作为基础框架；

创建对象类
project-》向导，添加MFC Class，继承CCmdTarget，Automation支持自动化功能，
这样就创建了一个COM组件下对象类了，如CoMath；

 class CoMath : public CCmdTarget
{
	DECLARE_DYNAMIC(CoMath)

public:
	CoMath();
	virtual ~CoMath();

protected:
	DECLARE_MESSAGE_MAP()

	//定义嵌套类
	BEGIN_INTERFACE_PART(MathObj, IMath)
		virtual HRESULT Add(int, int, long&);
		virtual HRESULT Subtract(int, int, int&);
	END_INTERFACE_PART(MathObj)

	//声明接口映射表
	/*接口映射表如何工作？
	CCmdTarget::InternalQueryInterface()调用GetInterface，《MFC internal》P377
	*/
	DECLARE_INTERFACE_MAP()
	//声明通用类厂，CoMath是组件对象
	DECLARE_OLECREATE(CoMath)
};

完成服务器
1）	实现接口；2）分配GUID；3）提供类厂；
1）	METHOD_PROLOGUE() 将嵌套类的QI，Add，Release委托给外部类
STDMETHODIMP_(ULONG)
CoMath::XMathObj::AddRef() {
	METHOD_PROLOGUE(CoMath, MathObj);
	return pThis->ExternalAddRef();
}
MFC还没提供这部分的向导，可能还要麻烦一点地写它们；


问题
Pre-Use Redirction， 工程配置-》link-》Pre-Use。。。改为Yes；


智能接口指针
ATL的CComPtr和CComQIPtr，MFC的CIP类，


C++包装类
一个或多个COM接口的封装，简化COM接口的调用，类似MFC包装Win32 API，实际就是组件包容，
VS提供了可以为ActiveX及其他COM组件自动生成包装类的工具，


COM库的内存管理
《COM原理与应用》P74，


组件的卸载
《COM原理与应用》P78，
进程内
卸载条件：1）组件中对象数为0；2）类厂锁计数为0；
则DllCanUnloadNow返回true，
客户在空闲时调用，CoFreeUnusedLibraries，检查，

进程外
P78








COM核心编程

激活
简要
客户找到类对象（类厂）的机制；
COM有三种激活模型：1，绑定到给定类的类对象，2，根据CLSID创建一个新实例，3，从文件激活

SCM
COM服务控制管理器，每台机器都有，用于激活对象和绑定接口指针；
1）COM服务可以在你自己的进程内激活，这样就是映射dll代码了；
2）第三方不给你提供dll，但有exe，那就是进程外COM激活了；
3）别人只提供服务，不给你组件，那就是远程COM激活了；
SCM ：RPCSS.EXE + ORPC 本地/远程过程调用通信协议；
ROT（running object table）运行对象表，SCM的一个设施；


如何激活对象
请求SCM把一个指针绑定到客户请求的类对象上：
CoGetClassObject(
REFCLSID,  //哪个类的类对象
DWORD dwClsCtx,//在哪里激活
COSERVERINFO*//主机/安全信息
REFIID,
void**);
dwClsCtx是一个位掩码，
enum CLSCTX { CLSCTX_INPROC_SERVER进程内，LOCAL进程外，REMOTE远程}
多个标志组合，COM会选择最有效率的类型，SDK提供了组合宏：
CLSCTX_INPROC, CLSCTX_SERVER, CLSCTX_ALL
主机/安全信息
客户显示指定在哪台机器上激活对象，以及配置请求的安全属性；
struct COSERVERINFO{ 
DWORD = 0,
LPWSTR 主机名，
COAUTHINFO* 安全设定，
DWORD = 0
};

查找接口指针的过程
注册表在HKCU\Software\Classes\CLSID和HKCR\CLSID下将CLSID映射到实现文件名或远程主机名，找到-》加载dll，没找到-》把请求重定向到远程，然后下载dll到本地自注册；
自注册
导出 DllRegisterServer 和 DllUnRegisterServer，注册表下载远程服务，安装程序等会调用；
实现， P92；

加载dll之后，dl要导出一个函数，获取COM的接口指针：
DllGetClassObject(REFCLSID,  REFIID,  void**);//从dll获取类对象
CoGetClassObject的实现伪码：P95；
大致流程：
if(进程内) –》LookupInClassTable进程内COM服务表 –》GetFileFromClassStoreOrRegistry在COM库或注册表中找dll名-》LoadLibrary-》找到DllGetClassObject函数执行，获取接口指针；
一旦获取类对象完成，COM库和SCM不再介入通信过程，如果不是进程内激活，那COM将返回一个代理指针，客户通过它通信；

COM库的“对象发现和创建”标准接口
对象发现
IOleItemContainer，配合单项名字对象使用；


对象创建
IClassFactory –》CreateInstance，LockServer
类对象都要继承的，LockServer进程外激活，CreateInstance创建类的新实例；
class ChimpClass : public IClassFactory{//..};
class Chimp : public Ape{//...};
HRESULT CreateChimp(IApe* &rpApe)
{
	extern const CLSID CLSID_Chimp;
	rpApe = 0;
	IClassFactory* pcf = 0;
	HRESULT hr = CoGetClassObject(CLSID_Chimp, CLSCTX_All, 0,
		IID_IClassFactory, (void**)&pcf);
	if (SUCCEEDED(hr)) {
		hr = pcf->CreateInstance(0, IID_IApe, (void**)&rpApe);
		pcf->Release();
	}
	return hr;
}
上面的创建过程 对于进程外或远程激活，CoGetClassObject，CreateInstance，Release这些操作都要一次来回数据传输，于是api：
CoCreateInstanceEx( P99
REFCLSID ,实例化的对象
IUnknown* 聚合（父对象是谁）
DWORD 哪里激活,
COSERVERINFO* 主机/安全信息,
ULONG cmqi 接口数目   一个对象 可以有N多接口
MULTI_QI* 接口存放位置);
S_OK, CO_S_NOTALLINTERFACES，MULTI_QI的HRESULT，SERVERITY_ERROR基础的HRESULT（无法创建对象或接口都不提供）

如果只需要一个接口，api：CoCreateInstance更方便，P103；
COM库会缓存类对象，不用SCM，这是最快的；

名字对象
绑定到期望对象的过程， 上面的太麻烦了， COM提供了一种标准机制让激活对象更方便灵活，它就是名字对象， 一个支持IMoniker接口的COM对象；
api
运行你的查找或创建对象 的 算法， 返回接口指针；
IMoniker : BindToObject(
IBindCtx*,
IMoniker*, //复合
REFIID,
void**
)
那么现在的问题就是如何获取名字对象了，我们只需要一个字符串，它在注册表中配置，称为显示名，也就是说每一个名字对象都有一个显示名；
那如何把显示名对应到名字对象上呢？api：
MkParseDisplayName(
IBindCtx*, //绑定信息
const OLECHAR* //字符串
ULONG* //错误过程
IMoniker** //名字对象
)
方法使用解析器检查字符串前缀，匹配注册表信息找到对应的名字对象类型，创建名字对象，有了名字对象，就能绑定到对象了；
api：
CreateClassMoniker
创建类名字对象（创建类对象的）；
或者将类名字对象的显示名传给MkParseDisplayName，clsid:571F16...  这个clsid就是名字对象的ProgID；
绑定过程， P107，先定义一个显示名-》MkParseDisplayName找到名字对象-》BindToObject绑定到对象-》调用接口；
api：
CoGetObject，简化绑定过程，伪码，P108，
创建绑定环境-》将显示名转换为名字对象-》绑定对象；

如何绑定到接口？
上面只是绑定到类名字对象上， 可以创建对象了，绑定到哪个接口呢？
单项名字对象
clsid：571F168-...:!Ursus
类名字对象 与 单项名 “Ursus”，MkParseDisplayName会使用IParseDisplayName: ParseDisplayName 解析剩余的字符串，P110；



文件名字对象
api：
CoGetInstanceFromFile，P113；
GetClassFile；
CreateFileMoniker；
IPersistFile :: Load；
IRunningObjectTable* p = GetRunningObjectTable；



服务器生命周期
空闲的时候调用CoFreeUnusedLibraries，它会遍历每个dll，调用导出的DllCanUnloadNow，它的实现规则应该是这样：只要有接口在使用，或者 IClassFactory：：LockServer调用，就不能卸载dll，这个可以实现在AddRef 和 Release里， 每当创建或使用接口，计数加1；

类模仿
指定“老的CLSID已经被新的CLSID替换了”，接口没有变化，只是功能扩展了；
CoTreatAsClass， P122；

组件类别
有时候我们只是需要“某种功能”的类，COM把实现同一组接口的类称为一个类别（category），CATID类别id，每个类的属性，存在注册表中， 一个是HKCR\CLSID\...\Implemented Categories，一个是“Required Categories”，第二个类别是 “站点接口”，将客户提供的服务归类（只有客户提供了服务才能激活对象），对应HKCR\Component Categories；P124；
我们可以使用注册表函数来注册类别，也可以使用COM 组件类别管理器暴露的ICatRegister，ICatInformation接口，类别注册和查询；



书签： P129；



二进制复合
4.8节，多个接口方法冲突的解决办法，复合技术；
4.9节，短暂分配复合技术tearoff，动态按需分配vptr空间；
上面的复合技术是源码级的；

COM聚合
直接通过QueryInterfaceI 把一个子组件暴露给客户的技术；
class CarBoat : public IBoat {
	IUnknown* m_pUnkCar;
	//...
};
我们很少直接把另一个对象的接口当作自身的一部分暴露给客户，因为QueryInterface表达了“是一个is-a”的关系，自行车有时候不是一个轮子；

COM包容
把一个不可被聚合的类暴露成一个对象实体的一部分，外部对象提供内部对象已经实现的接口；

套间
概念
为了使用对象而不必关心并发，套间定义了一组对象的逻辑组合，它们共享同一组并发性；
线程创建时，没有关联的套间，线程调用：
CoInitialize(Ex)(0, DWORD flag COINIT_MULTITHREADED/ APARTMENTTHREADED)-》线程进入套间（要使用COM必须先进入套间，COM会把套间信息保存在TLS中），CoUnInitialize离开套间；
每个COM对象都属于某个套间，只有运行在对象套间中的线程才能访问该对象；
有2种套间，多线程MTA和单线程STA，进程有一个或多个套间，MTA最多一个，STA一个线程可以执行，意味着对象只有一个线程可以访问它们，不过将来有RTA租用模型；


线程模型
每一个CLSID都有自己独立的线程模型，注册表HKCR\CLSID\..\InprocServer32\ThreadingModel，Both，Free(MTA)，Apartment，无ThreadingModel（在进程的第一个初始化的STA中运行）；
如果客户的套间（代码所在线程) 与CLSID套间（注册表）不兼容，那么对CLSID进程内激活请求将使COM在另一个套间中构造对象，然后给客户返回一个代理；


跨套间访问
简要
为了允许对象驻留在不同套间中；
引出接口：从一个套间引出接口，并引入另一个套间 
引入接口：使套间内部也能看到外部的接口，引入的是代理，这个代理保证把控制传回给对象的套间，这个控制传递过程被称为方法远程传递，是COM中跨线程，进程，跨主机通信的基础，基于RPC/ORPC通信协议；

列集
COM使用列集（marshal）技术，允许接口指针被跨越套间传递，即把接口指针列集成字节流传输（唯一标识对象和它的套间），然后散集成客户套间的一个代理；
显示列集API：
CoMarshalInterface  P174，列集到一块内存中，它可以被传输到网络上任意一个套间中，MSHLFLAGS{ 常规列集，表格列集 ...}；
为了使接口指针可被列集到各种介质中，CoMarshalInterface  使用IStream接口作参数，P175例子，列集之后其它套间就能通过CoUnMarshalInterface访问这个接口；
对于在MTA或RTA中执行的线程，传递到另一个套间中去，并不需要散集，P181；

被列集对象的格式;
P178，OXID/OID/IPID组：唯一标识一个接口指针，OXID 对象引出ID，当代理第一次连接到对象上时，OXID可用来找到网络/IPC地址信息，OID 对象ID，唯一标识COM实体，IPID，接口指针ID；
OR，RPCSS，套间。。。

列集辅助函数
P179，简化列集/散集过程；
CoMarshalInterThreadInterfaceInStream
CoGetInterfaceAndReleaseStream

全局接口表（GIT）
常规列集（MSHLFLAGS_NORMAL）只能散集一次接口指针，很多情况下，多个辅助线程需要散集这个接口，如果辅助线程在MTA中，那没问题，但如果在任意套间中，就用表格列集（可以散集多次），不幸的是，如果接口是代理的话，不支持表格列集，因此出现了GIT；
允许接口指针被进程中所有的套间访问，COM内部为每个进程实现一个GIT，它包含所有列集的接口，可被散集多次；
接口：IGlobalInterfaceTable P182；
CLSID_StdGlobalInterfaceTable

标准列集结构
对象第一次调用CoMarshalInterface时，方法会询问是否使用自己的跨套间通信机制（就是QI(IMarsha)），大多对象没有实现IMarshal，所以使用默认的COM-ORPC；

当对象希望使用标准列集方式时，CoMarshalInterface创建一个特殊的COM对象：存根管理器（stub manager），它能唯一标识对象，而且它们是一一对应的，它跟踪记录未完结的外部引用，只要还有引用，资源就存在内存中，类似shared_ptr；

存根管理器了解“对象身份”，而并不了解通信，它的一个辅助对象：接口存根，它知道接口方法的所有细节,P184；

当CoUnMarshalInterface散集一个对象引用时，它返回一个代理管理器指针， 也是识别“对象身份”的，它的辅助对象：接口代理，处理通信的；

 
代理与存根之间 是 通过通道（channel）的COM对象通信的，通道封装了RPC运行时层，暴露IRpcChannelBuffer，接口存根暴露IRpcStubBuffer，接口代理暴露IRpcProxyBuffer，P187；

接口代理和存根是动态绑定到管理器上的，它们共享CLSID，这个包含两个分支实现的实体称为接口列集器（创建接口代理和接口存根的），它的类对象暴露IPSFactoryBuffer；
接口与CLSID映射关系：HKCR\Interface 和 HKCU\Software\Classes\Interface，P188；

标准列集、线程和协议

列集与生命周期

自定义列集
有些对象，ORPC提供的缺省行为不是很效率，需要自定义列集方式；

自由线程列集器



应用
进程内激活的缺陷
错误隔离性
COM对象访问违规，或其他运行时错误，客户进程将与对象一起被终止；同样，进程发生错误，或被关闭时，对象也都被销毁（毫无警告）；
安全环境问题
进程内激活的COM对象执行的是 客户的安全令牌，这意味着 特权用户可以做“危险”的事，低权限的用户无法访问“重要的操作”，我们没有办法让进程内对象拥有自己的安全环境；
分布式计算
在进程的地址空间中，就会共享客户的CPU和本地资源，无法提供分布式计算功能，而且也使“多个进程共享同一对象”非常困难；

进程外服务器
HKCR\CLSID\..\LocalServer32，类的代码被包装成exe（进程外服务器），这在安装程序的时候写到注册表中；
不导出DllRegisterServer，而是检查命令行是否有/RegServer 和 /UnregServer；

一个exe只要显示地把自己注册到SCM中，它就变成某个类的服务器进程了，以后对于这个类的进程外激活都将被分发到该exe，api：CoRegisterClassObject 注册服务器进程到SCM，P220，COM库会在内部维护表中关联类对象指针（第二个参数）与它的CLSID，局部特征与激活标志参数，P220；

进程外服务器的生命周期

应用id
GUID，被称为AppID，代表一个服务器进程，HKCR\CLSID\..\AppID 和 HKCR\AppID，大多数AppID可以使用DCOMCNFG.EXE设置远程和安全性，OLEVIEW.EXE还提供一个以COM为中心的注册表视图；

AppID的一项设置是 RemoteServerName，如果你没有指定COSERVERINFO的话，P230；
既没有指定主机名，也没有指定标志，SCM处理，P231；

COM支持三种进程模型：NT服务，普通进程，代理进程surrogate process，P232；

COM和安全性
简要
认证authentication：确保消息可信；
访问控制access control：允许谁访问服务器对象；
令牌管理token management：可执行哪些操作；

会有默认设置，大部分都可以在注册表中配置，一般系统管理员使用DCOMCNFG.EXE，显示使用api会灵活些；
P234，RPC的可装载模块：传输协议、安全包；
CoInitializeSecurity，P236；

自定义安全性
为小部分对象设定，IClientSecurity，P240；

访问控制


令牌管理

VC++实践与提高-COM和COM+篇
命名与绑定
概念
另一种创建对象的方法，名字对象（moniker），全面封装了组件对象，客户只需要创建相应的名字对象，它可以代表一个文件，一个单元格，一个数据表，一个COM对象等，它可以使被动的对象进入运行状态；
COM实现了一组名字对象，如，文件名字对象等等；
IMoniker接口，P140；
COM系统名字对象：文件、复合、单项、反-、指针和类 名字对象，以及不断更新的，如URL名字对象，广泛用于整个操作系统，文件复合单项最常用；
文件名字对象：CreateFileMoniker P142；
复合名字对象：不同类型的名字对象组合在一起，就是复合名字对象，有通用和特定组合方式，IMoniker::ComposeWith 实现组合过程，CreateGenericComposite创建通用，P143；
单项名字对象：标识一个包含在其他对象中的对象，容器对象决定名字空间，如：”C:\Data\MyReport.doc ! embedobj1” 标识文件中的embedobj1对象 CreateItemMoniker P144；
反、指针 P144；
类名字对象：更灵活创建类对象 P144；
以上都是同步名字对象（绑定过程中，必须等到所有数据和对象准备就绪后，才返回结果），网络中的是都是异步绑定的，异步实现IMoniker和IAsyncMoniker；
使用
1，获得名字对象
MkParseDisplayName通用，CreateFileMoniker特定，其它接口传递，数据传输机制得到（剪贴板或拖放）等
2，绑定
IMoniker::BindToObject 绑定，返回成功则获得对象；

统一数据传输
概念
数据对象 IDataObject接口，使数据交换同传输协议分离，最基本的传输协议有 剪贴板 和OLE拖放；
机制：所有传输协议只需交换一个IDataObject接口指针，一个实现数据对象，一个获取数据，不管使用什么协议；
数据格式和传输介质
FORMATETC 和 STGMEDIUM  P147；
IDataObject 接口 P51；
MFC对数据传输的支持，COleDataSource，COleDataObject P152；
剪贴板 传输 P154；
OLE拖放技术 P159；


COM应用
导读
实际开发中，很少直接用COM API 和 在COM接口上进行设计，我们直接用COM技术，包括：自动化技术，OLE文档，ActiveX文档，ActiveX控件等；

VC编译器提供了一些COM支持，如
_bstr_t，封装了BSTR类型，_variant_t 封装了VARIANT类型，_com_ptr_t 封装了COM接口指针，它会自动调用AddRef，Release和QueryInterface；

OLE/ActiveX文档
OLE文档包容器 和 OLE文档服务器
包容器是可以将OLE文档服务器以嵌入或链接方式合并的程序，服务器则是 创建OLE文档对象的程序，如word是包容器，word被嵌入就是服务器程序，大多数OLE服务器是独立的程序，叫full-servers，有的只能在包容器中运行，mini-servers，包容器对象不需要知道服务器的实现，只要是OLE组件，遵循COM规范即可；
站点对象：服务器对象通过它与包容器通信，每个OLE对象都有自己的站点对象；

ole技术用ActiveX商标销售，原来的链接、嵌入和现场激活技术转移到ole容器文档中；

嵌入与链接技术
链接，只是保存一个路径，如，双击会打开excel并调入原电子表格文档；
嵌入对象实现IOleObject  P297，包容器实现IOleClientSite  P299；

现场激活技术in-place
支持在包容器内部编辑， 除必要的OLE接口外，IOleInPlaceObject，还必须提供一个实现了IOleInPlaceActiveObject的对象，  P299，站点对象也要实现一些接口  P300， 包容器框架对象 IOleInPlaceFrame；

MFC对OLE的支持， P301；

ActiveX文档，P168， P328；
在OLE文档基础上，可以从web服务器下载的特殊文档类型，浏览器遇到ActiveX文档时，自动从硬盘装入ActiveX文档服务程序（word，excel等），并接管整个浏览器窗口，可编辑，但不能传回服务器；

开发ActiveX文档， P329；





ActiveX控件
应用最广泛的COM组件，图形图像处理，数据库。。。能快速建立起功能全面的应用系统；
一个真正有用的ActiveX控件，有：
属性和方法， 事件机制，用户界面特性，永久性，通常支持的接口，P340；
库存属性、方法和事件， P340；
IOleControl，IOleControlSite，  P342；

属性页技术， P344
当ActiveX控件处于设计模式时，用属性页修改属性比用接口现实；

MFC开发 ActiveX控件， P345；
ATL开发,  P373；

Internet与ActiveX控件
安全性 ， 权限，签名 P392，  安全设置，  P393； 使用许可， P398；
在ActiveX中访问DOM， P409；
IIS（Internet信息服务器）提供服务器功能， IE浏览器提供客户机功能；
ASP（活动服务器页面），是脚本文件，它在服务器上被分析处理，JavaScript，Perl等开发，当客户机（浏览器）请求ASP页面时，IIS发现是.asp，于是开始分析处理，发送http响应给客户机 P414；
ASP内建对象
不用创建，直接访问，可以获取http请求，存取对话信息，响应http等， P414；
在C++COM中访问ASP内建对象， P415；



企业应用模型
多层软件应用模型： 
界面交互，html，vc。。。
业务逻辑，COM，IIS（Internet Information Server），MTS（Microsoft Transaction Server）。。。
数据服务，db。。。


在VC中使用ActiveX控件
创建一个支持ActiveX控件的MFC包容器程序；
通过创建包含控件接口的类 把控件下载到项目中；
确定控件的属性和方法，并设置设计属性；
建立一个代表控件包装类的对象的成员变量；

MFC向导，基于对话框，支持ActiveX；
#include <afxdisp.h> 和 AfxEnableControlContainer，这样就创建了一个“支持ActiveX控件的MFC包容器程序”;

在VC中使用代码组件
三种方法：
1，直接用CoCreateInstance访问COM对象的方法和属性, P185；
2，使用MFC OLE向导，从对象的类型库中创建组件的包装类，VC程序通过包装类调用, ；
3，#import指令引入类型库，编译器从类型库中读出信息并创建包装类；

使用OLE/COM Object Viewer查看组件信息


COM+,DCOM,MTS
COM的新版本，更注重于分布式网络应用的设计和实现，继承COM，优化COM；
MTS运行时环境为开发人员提供了许多系统服务：分布式事务，图形化管理工具等，使只关注业务逻辑的解决；
COM+把COM,DCOM,MTS统一， 形成适用于企业的组件技术；

用vc开发com
MFC部分， P214；
ATL
随着Internet的发展，COM要在网络上传输，由于mfc的种种限制，微软推出了全新COM开发工具ATL；

模板类 和 多继承是主要技术；
不要同时使用MFC和ATL；

几个重要的类  P237
CComModule  
执着部分功能，引用技术，在本地服务器内类厂注册以及管理自动注册。。。一些COM 核心功能，类似CWinApp；

CComObjectRoot/ CComObjectRootEx 
ATL COM组件都 继承的，类似CCmdTarget；

CComCoClass
组件都 继承的，负责定义类厂；

CComObject
实现IUnKnown接口，聚合等；



书签：P73  Visual
P183  COM本质论
P425  VC++ 实践 COM和COM+  




设计模式
代码大全
1 基础知识
1.1	软件构建的过程
1.1.1过程：
1)	定义问题				
2)	需求分析
3)	规划构建
4)	软件架构
5)	详细设计
6)	编码与调试			占1/4
7)	单元测试
8)	集成测试
9)	集成
10)	系统测试
11)	保障维护
1.1.2 具体任务(task)
1)	验证有关的基础工作已经完成
2)	确定如何测试所写代码
3)	设计并编写类和子程序
a)	数据结构，内存占用
b)	代码执行效率，实现方法
4)	让他人评审你的代码
5)	单元测试和集成测试，找出问题
6)	优化，调整代码，让它更快、更省资源
注：软件构建能提高程序员10~20倍的效率！
注：一套100万行代码的软件系统，平均要69种文档(1998)。其需求文档一般要四五千页长，而设计文档常常是需求的两三倍长！不太可能有人能完全理解所有细节的。

1.2	软件架构
1.2.1 架构的典型组成部分
《代码大全》P45
      1.2.2 核对表
		《代码大全》 P42,P54,P69
2	高质量代码
2.1 设计目标
1)	最小复杂度：简单易于理解的设计
2)	低耦合：程序各个组成部分关联最小（类之间），减少关联也就减少集成，测试与维护的工作量
3)	可扩展性
4)	可重用性
5)	可移植性
2.2 设计层次
	2.2.1 层次：
软件系统->分解为子系统和包->分解为包中的类->分解为类中的数据和子程序
2.2.2 常见子系统
	子系统之间不能出现环形通信，编制简单易于维护的连接。
	常见子系统：
1)	业务规则
2)	用户界面
3)	数据库访问
4)	系统接口（方便移植）
5)	图形
6)	工具
 	2.3 类的设计
		2.3.1 参考《C++XXX》抽象，封装，继承。
		2.3.2 设计模式

	

 

创建型模式
抽象实例化过程，避开具体的类、隐藏创建过程（创建了什么、谁创建、怎样创建、何时创建。。。），



先来看一个“迷宫”的创建
我们将一个迷宫定义为一系列房间，一个房间知道它的邻居；可能的邻居要么是另一个房间，要么是一堵墙、或者是到另一个房间的一扇门。
我们的迷宫组件可能是下面这样的：
 
UML只列出主要内容，详细代码在algorithim.sln
然后我们封装一个“迷宫游戏”的类，
Maze* MazeGame::CreateMaze()
{
	//创建一个迷宫
	Maze* aMaze = new Maze;
	Room* r1 = new Room(1);
	Room* r2 = new Room(2);
	Door* theDoor = new Door(r1, r2);

	aMaze->AddRoom(r1);
	aMaze->AddRoom(r2);

	r1->SetSide(North, new Wall);
	r1->SetSide(East, theDoor);
	r1->SetSide(South, new Wall);
	r1->SetSide(West, new Wall);

	//r2...
return aMaze;
}
这里写死了具体的类，典型的硬编码！非常难扩展。
假设有新的构件如“施了魔法的”迷宫游戏，像DoorNeedingSpell，它是一扇仅随着一个咒语才能被锁上和打开的门；以及EnchantedRoom，一个可以有不寻常东西的房间，比如魔法钥匙或是咒语。你怎样才能较容易的改变CreateMaze以让它用这些新类型的对象创建迷宫呢？


再来看另一个应用：
一个有多种视感风格的界面，不同的视感风格为诸如滚动条、窗口和按钮等用户界面“窗口组件”定义不同的外观和行为，实际中若“硬编码”，写死固定风格的组件将很难再改变！

解决
从实例化“产品”的代码中除去对这些具体类的显式引用
创建型模式提供了多种不同的方法除去对具体类的引用：
Abstract Factory
 
扩展：
工厂通常是单例；
可扩展工厂，有新产品不用添加“创建产品”的接口；

builder
详见builder

factory
工厂是可以实例化的，抽象工厂不行，工厂方法提供部件的创建方式，子类继承返回不同的部件，看下代码示例即可，
产品id 和 模板等，都可以让创建产品更简洁，

Prototype
 
缺点：
子类 都要实现Clone方法，对已经存在的类，或 不支持拷贝的资源时，实现困难；
深浅拷贝；




建造者
 

上面这张图解决什么问题：
一个RTF阅读器，它能将RTF格式的文本转换为多种其他格式，而且格式是可扩展的，builder在这里是“部件组装者”，builder是创建型模式，那产品是什么？就是最终要转成的格式，

builder与factory的不同
一个builder对应具体风格的部件、构造顺序等，组建好返回产品，factory则立即返回部件/产品，
它可以将部件组装成新的产品，并提供更精细的控制，

对比两者在创建“迷宫”时的代码，相差不多，



Singleton
单例


结构型模式
如何组合类和对象，不是对接口和实现组合，是对一些对象组合，还可以在运行时刻改变组合关系，以获得更大的结构，


桥梁
如下图所示,抽象和实现有各自的继承层次,这样就解除了绑定关系,两者可以各自以子类扩充, 且隐藏了实现，
 
核心代码
class Window {
public:
	virtual void DrawLine(const Point&, const Point&);
	//其他抽象
protected:
	WindowImp* GetWindowImp();
	//...
private:
	WindowImp* _Imp;
	//...
};

class WindowImp {
public:
	virtual void ImpDrawMethod() = 0;
	//...
};

//两个继承体系下的子类，包含自己的数据成员，选择实现
void IconWindow::DrawContents() {
	WindowImp* imp = GetWindowImp();
	imp->XXX();
}
//工厂选择实现
WindowImp* Window::GetWindowImp() {
	_imp = WindowSystemFactory::Instance()->MakeWindowImp();
}




组合
如下图，Line、Text等是基本图元，Picture是组合图元，但客户不区分组合与单个对象，两者一样使用，详细内容看书，
 






装饰
给对象添加功能，而不是用一个子类继承，这种灵活的具体做法是：将组件嵌入另一个对象中，由这个对象添加功能，我们称这个对象为装饰，它的优点如下：
1）	比静态继承灵活，比如可滚动、有边框，装饰可以灵活组合，“即用即付”而且在装饰前后你可以添加任何其他代码，但继承就要多出许多子类，

 
为什么装饰要继承一个父类，因为装饰之后还是原来的类，
使用：
window->SetContents(
	new BorderDecorator(
		new ScrollDecorator(textView), 1) //先加个滚动条，再加个边框
);





享元
一个实际的应用：
 
逻辑上，每个字符对应一个对象，这能给程序极大的灵活性，但性能低下，flyweight共享对象，它分对象的内部状态和外部状态，对于上图就是字符代码和文档位置排版风格，
所以如果程序使用了大量重复对象，且对象状态可转为外部状态，那就尝试flyweight，
它的结构是这样的：
 
对应我们的实际应用，Character是flyweight对象，我们可能需要一个工厂获取享元、一个GlyphContext外部状态库。。。
详细还要参考下原文，
 







代理

先看一个例子：
pdf文档，它在打开的时候，有的元素对象创建开销很大，打开比较慢，但文档并不是要一次性打开所有的，一个解决方法是使用那些“大对象”的代理对象，
就像这样：
 
代理的接口是对象的超集，


代理就是能控制这个对象！
实际应用：
远程代理（隐藏对象存在于不同地址空间的事实）、虚代理（根据需要创建“大对象”）、保护代理（权限控制）、智能指引，



行为模式
描述类或对象的通信模式，这些模式刻划了在运行时难以跟踪的复杂的控制流，它们将控制流转移到对象之间，

职责链
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，
多个对象处理请求运行时刻动态确定，

看下面的应用：
界面中的帮助机制，用户点击请求帮助信息，而得到的帮助可能要按“职责链”向上搜索帮助上下文，

 
核心代码：
class Handler{
private:
	Handler* _successor;//后继
	CRequest* _req;//请求
public:
	virtual void SetHandler(Handler*, CRequest*);
	virtual void Handle();//处理
};



命令模式
将请求封装为对象，
动机如下：
 
有时候向MenuItem这样的对象发送请求时，并不知道请求的操作或接受者的任何信息，将“请求”与操作的接受者分离，可以使你用不同的请求对客户进行参数化，如下图，

 
实现考虑的问题：取消重做、复合命令、C++模板。。。


解释器
定义一种文法语言，并定义一个解释器，该解释器使用文法解释语言，regex就是，如果一类问题发生的频率很高，那么可以想想怎样定义一种文法来表达它，
模仿regex的一个例子：
定义文法， ‘|’ 可选，’&’序列，’*’重复，字符，而一个regex由它们构成比如：raining&(dogs|cats)*，
解释器用类来表示每一条文法规则，
 
上面的正则表示了一个抽象语法树：
 



迭代器
访问对象各元素而不暴露对象的内部细节，
 

中介者
考虑一个图形用户界面中对话框的实现，
 
通常对话框中的窗口组件间存在依赖关系。例如, 当一个特定的输入域为空时, 某个按钮
不能使用；在称为列表框的一列选项中选择一个表目可能会改变一个输入域的内容。。。
引入一个中介者，负责控制和协调一组对象间的交互，它适用于依赖关系混乱、通信复杂的情况，

书中有解决这种问题的代码，


备忘录
捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
 


观察者
当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。多对多，一个观察者也可以观察多个对象，
 
 



状态模式
允许一个对象在其内部状态改变时改变它的行为，比如网络连接在Established、listening、Closed。。。各种状态下表现出不同的行为，

当一个对象的行为取决于它的状态时，或者庞大的分支语句依赖对象的状态，那么状态模式可以将分支代码独立到各个类中，

 


策略模式
封装算法，使算法独立于客户的变化，
 
strategy可能就是一个参数，


模板方法
在父类中用虚函数写下一份模板流程，子类可以重载其中的模板方法（那些可变的部分），

访问者
书中编译器访问抽象语法树的例子，把操作提取到Visitor对象里，当遍历到某个节点时，可以调用相应的访问操作，并把节点信息作为参数传入，传统的，我们把操作定义在节点里，
 



实例
demo：文档编辑器的设计模式应用，



要去做的事情
重复代码，api，组件，功能。。。 封装成类， dll， COM。。。 配上文档

乔布斯传读后感

i表情，表情制作，专业的学ps； 傻瓜式的工具，给大众用的表情组装工具；

毛日蒙的简易衣服设计，傻瓜式，大众用的；

动画，3dmax，将枯涩难懂的理论 ，形象生动地 展现；

大数据，自动回复
回复方式：成语，火星，网络。。。
回复风格：批评，赞扬。。。

随音乐震动的画面，游戏，视频。。。

日志解析器

随机数系统：摇奖，抽奖，概率，暗黑随机。。。

计时系统
qq登陆后，可以看到等级——几个太阳，几个月亮，25级什么的；
还有一个qq活跃天数，剩余升级天数
虎娱的，直播满1h，3h什么的；
网络游戏经常有新手礼包，3天连续登陆，5天，7天…

h5制作贺卡，中秋，新年，互动，奖赏。。。
桌面涂鸦
配置管理器，boost库开发；


文档管理工具
类似svn；

电脑闹钟
时间一到，动画，提示，短信，音乐。。。

开机启动
文档，软件。。。打包启动。

日记，博文等文章的正确写法
每天保留晚上要用的素材，花点时间，准备今天的总结。
不过要各大网站，应用普遍支持这种“想插入什么就插入什么”的文章书写方式。

名字管理
html元素的id是建议取成唯一的，所以要有个工具方便管理下；



















Python
sourceforge 开源软件开发者进行开发管理的集中式场所；在这里下载的Python和Pythonwin；
Pythonwin下载地址：http://sourceforge.net/projects/pywin32/files/pywin32/

目录
4，Python对象			P85
5，数字					P115
6，字符串、列表和元组	P152
7，映射和集合类型		P250
8，条件和循环			P285
9，文件和输入输出		P317
10，错误和异常			P345
11，函数和函数式编程	P388
12，模块				P450
13，面向对象编程		P472
14，执行环境			P582
15，正则表达式			P621
16，网络编程			P655
17，网络客户端编程		P685
18，多线程编程			P721
19，图形用户界面编程	P748
20，Web编程			P781
21，数据库编程			P841
22，扩展Python			P880
23，其它话题			P901



概念：
1，Python内存管理由Python解释器负责。
2，Python是一种解释型语言，没有编译环节，其源文件为.py，解释器加载它会将其编译成字节码（.pyc，.pyo文件），然后机器码。
3，运行Python;
	启动解释器、运行Python脚本、集成开发环境。
PythonWin是windows下的集成开发环境，需下载，windows下建议用这个。
IDLE 是下载Python时自带的集成开发环境。

交互运行：
运行脚本：
#!/usr/local/bin/python XX.py  环境变量
开发环境：
	PythonWin针对MFC，包含Win API和COM，可以开发Windows 应用程序；

4，帮助文档
本地手册；
在线文档；

语法：
 (_)在解释器中代表最后一个表达式的值，也不要作变量的开始。
	_xxx 不用from module import * 导入
	___xxx___系统定义
	___xxx 类中的私有变量
不同版本，语法不一样，比如print “%s is number %d” % (“Python”, 1)在343版本中不行，因为print是一个函数了，改成：print("%s is number %d" % ("Python", 1))
print >> sys.stderr ‘..’     print >> logfile,’..’   输出重定向
用户输入：var = input(“tip:”)  int(var) 解析…
注释：# 单行；  ‘’’ 多行注释 ‘’’ ；
运算符：+ - *  /（float除法四舍五入）  //（整除）  %  **（幂）
	<   >   ==  <=  >=   !=
	and 、or、 not ；  就是C++的 &&、||、!；
支持n *= 10，不支持++，--。
is， is not 变量是否指向同一个对象；
位运算：~   &  |  ^   <<   >>
pass就是 执行空语句；



变量
	动态类型，自动识别；无须事先声明；变量名会被回收（所有对象引用计数）；
赋值：（x,y,z） = (1,2,’a string’)
交换：z,x,y = y,z,x
del obj1，obj2。。。删除对象一个引用。
type(变量) 返回变量类型 class ‘int’
浮点型返回false；None；

类型：
数字：int、long(巨长)、bool(True)、float、complex；
字符串：’’；
列表[]和元组()：数组，切片；
字典{}：map；


缩进区分不同的代码块
反斜杠：\ 继续上一行，含括号和三引号不用。

IF语法
if x < .0 and (a >= 10):   括号可要可不要
	..
if ..:
else: ..
三目运算 X if C else Y

if ..:   elif ..:  else:

WHILE语法
while .. :

FOR语法
for iter in iterable: … 
range(n) 能生成 0 ~ n-1的数字；
for i,ch in enumerate(foo):   ..  i索引，ch元素
列表解析：
[expr for iter_var in iterable if cond_expr]
sqdEvens = [x ** 2 for x in range(8) if not x % 2]；

迭代器对象有一个next()方法，迭代完后触发StopIteration异常，for内部处理了；
i = iter(iterable)  使用   iter(func, sentinel) 重复调用func，返回值=sentinel的iter；
i.next()  
让类具有iter功能 P537；



文件语法
handle = open(file_name, access_mode = 'r',buffering=-1)  ‘w’  ‘a’追加 ‘+’读写  ‘b’二进制访问，可自由组合；
工厂 ：file()，等价open()；
read() 读取字节；
readline()
readlines()  
write、readline、readlines；
读会有行结束符，写不会自动加；
seek() 、 tell() 告诉你文件指针在哪里；
遍历 行for eachLine in f:
close()、flush()
truncate() 截取文件；
文件属性
file.closed  encoding  mode   name文件名  

stdin,stdout,stderr文件句柄  sys模块
命令行sys.argv 参数列表  len(sys.argv)  个数；

os模块 和 os.path模块 提供与操作系统无关的统一文件访问
linesep，sep，pathsep，curdir，pardir；
如：fobj.write('%s%s' % (aLine, os.linesep)
P330  os模块
mkfifo/mknod 创建fifo/文件节点
remove/unlink 删除文件
rename/renames 重命名
*stat 文件信息
symlink 创建符号链接
utime 更新时间戳
tmpfile 创建并打开w+b临时文件
walk 
chdir/fchdir 改变当前目录
chroot 改变当前进程根目录
listdir 列出指定目录文件
getcwd/getcwdu  返回当前目录
mkdir/makedirs 创建目录/多层目录
rmdir/removedirs
access  检验权限
chmod  改变权限
chown/lchown  改变owner和group ID
umask 设置默认权限
open，read，write
dup/dup2  复制文件描述符/复制到另一个
makedev，major，minor
P331 os.path模块
basename ，dirname，join，split，splitdrive，getatime，exists，isdir…
异常语法
try:
try_suite  #监控这里的异常
发生异常之后的语句不会执行！解释器搜索处理器，找不到会一直向上抛；
except Exception[, reason]:
except_suite #异常处理代码
except (Exc1[, Exc2[, ... ExcN]])[, reason]: 
	except_suite #多种类型一种处理

捕获所有异常
try:
:
except BaseException, e:

不要把大片代码放入try-except，异常的作用是提供一个可以提示错误或处理错误的机制；

内建异常 P375
ValueError，TypeError，IOError…

finally: 无论如何都会执行；

明确触发异常
raise [SomeException [, args [, traceback]]]
raise [异常名字，字符串,类或实例[, args [, traceback]]]
args：单一的字符串用来指示错误的原因.如果传的是元组,通常的组成是一个错误字符串,一个
错误编号,可能还有一个错误的地址,比如文件,等等；


函数语法
def addMe2Me(x=True):
…
return (x + x)  没有return返回None
cmp() 比较两对象
str()、repr() 以字符串形式返回对象的内容、类型、数值等，str()可读性更好，repr则是：
	obj == eval(repr(obj)) 可以重新获得对象。
数值工厂函数：int(obj, base=10)   complex(…)… 
功能函数：abs()， divmod()商余，round()四舍五入，
	Int直接截取小数部分；floor得到最接近原数但小于原数；round最接近原数；
进制转换：hex   oct   
ASCII转换：ord(‘a’)  -> 97   chr(65) ->  ‘A’   unichr返回unicode码值
高级科学计算包：
http://numeric.scipy.org/
http://scipy.org/

序列相关的内建函数
sorted()，zip() 返回排序的列表；
reversed() ，enumerate() 返回迭代器；

内嵌函数
内部def，另一个方法是lambda语句；

装饰器
接受函数对象的 函数；
@decorator(dec_opt_args)
def func2Bdecorated(func_opt_args):
作用：
加入通用功能，如 1）日志； 2）性能测试；3）事物；
使用：
def tsfunc(func):   	   #装饰器函数
	def wrappedFunc():   #内嵌函数
		print '[%s] %s() called' % (ctime(), func.__name__)
		return func()     #内嵌函数 = print + 原函数
	return wrappedFunc  #返回包装了的函数

@tsfunc				   #装饰器
def foo():
	pass
	
foo()
sleep(4)

for i in range(2):
	sleep(1)
	foo()

参数
任意数量的位置参数
def func(arg1, arg2, *args):
func("hello", "Tuple, values is:", 2, 3, 3, 4) #自动被放入元组中提供给函数使用
func("hello", "Tuple, values is:", *(2, 3, 3, 4)) 传入元组
任意数量的关键字参数
def func(arg1, arg2, **kwargs):
func("hello", "Dict, values is:", x=2, y=3, z=3) #自动被放入字典中提供给函数使用
func("hello", "Dict., values is:", s=3, **{'x':2, 'y':3, 'z':3,})




可变长度参数
lambda
lambda [arg1[, arg2, ... argN]]: expression
>>> a = lambda x, y=2: x + y
>>> a(3)

生成器 P443



类语法
定义
class FooClass(object):
version = 0.1  静态变量
def __init__(self, nm='John Doe'):   #构造，FooClass(‘myn’)；
self.name = nm    #name object的
print 'Created a class instance for', nm
def showname(self):   #有self的是类方法，没有的是static方法，self换成cls就是类方法
print 'Your name is', self.name
print 'My name is', self.__class__.__name__ 
def showver(self):
print self.version 
def addMe2Me(self, x): 
return x + x
创建类实例，调用方法
foo1 = FooClass()
foo1.showname()

子类
class SubClassName (ParentClass1[, ParentClass2, ...]):
def __init__(self, nm, ph, id, em): 
父类.__init__(self, nm, ph) 调父类构造

查看类属性
dir(类名) 或者 类.__dict__ 

特殊类属性（可以通过类.XX访问）
C.__name__ 类Ｃ的名字（字符串）
C.__doc__ 类Ｃ的文档字符串
C.__bases__ 类Ｃ的所有父类构成的元组
C.__dict__ 类Ｃ的属性
C.__module__ 类Ｃ定义所在的模块（1.5 版本新增）
C.__class__ 实例Ｃ对应的类（仅新式类中）


调用父类方法
super(type[,obj]).方法  返回给定type的父类
super(CMyClass, self).__init__()

issubclass, isinstance, *attr系列
obj.attr 其实就是调用 *attr(obj, ‘attr’ …) 系列函数；

可重载的方法
P525；
C.__init__(self[, arg1, ...]) 构造器（带一些可选的参数）
C.__new__(self[, arg1, ...])a 构造器（带一些可选的参数）；通常用在设置不变数据类
型的子类。
C.__del__(self) 解构器
C.__str__(self) 可打印的字符输出；内建str()及print 语句
C.__repr__(self) 运行时的字符串输出；内建repr() 和‘‘ 操作符
C.__unicode__(self)b Unicode 字符串输出；内建unicode()

操作符  等等等，有几十个；
P533 重载例子；


包装
对已存在的对象(类型,代码,对象..)的一些定制，这样可以新建，修改或删除原有类的一些功能；
覆盖__getattr__()方法，包含getattr()内建函数的调用（返回属性或方法），对于切片这种操作，不是以属性存在的报错 P548；
例子 P550；
getattr(self, '_%s__%stime' % \
 	(self.__class__.__name__, t_type[0]))   # __atime  会改名
P553，将字符串转大写写入文件，包装write方法 包装对象.write()，其它还是file的默认行为；


描述符



模块语法
搜索路径：编译或安装时指定；sys.path 里；sys.path.append(‘..’)；
导入模块 import 模块名
顺序：标准库，三方库，自定义；
导入指定属性：from module import name1[, name2[,... nameN]] [as 别名]


访问 module.func()  module.var
布局：
1）起始行    总说明
2）模块文档  模块字符串
3）模块导入  import
4）变量定义
5）类定义
6）函数定义
7）主程序 if __name__ == ‘__main__’:


相关模块：
Debugger：pdb 调试
Logger：logging 日志
Profilers：profile，hotshot，cProfile	性能测试
decimal 十进制浮点运算类 Decimal
array 高效数值数组（字符，整数，浮点数等等）
math/cmath 标准C库数学运算函数。常规数学运算在match模块，复数运算在cmath模块
random 多种伪随机数生成器
randrange() 随机返回range([start,] stop [,step])结果的一项；
uniform() 返回浮点数，不包括上限；
random 0.0 ~ 1.0之间；
choice随机返回给定序列一个元素；


包语法
有层次的文件目录结构；
Phone/
__init__.py
common_util.py
Voicedta/
__init__.py
Pots.py
		Isdn.py
Fax/
__init__.py
G3.py
Mobile/
__init__.py
Analog.py
igital.py
Pager/
__init__.py
Numeric.py
导入
import Phone.Mobile.Analog
Phone.Mobile.Analog.dial()

from Phone import Mobile
Mobile.Analog.dial('555-1212')




Python对象
特性：身份id()、类型type()、值；
类型type(42) <type ‘int’>  type(type(42)) <type ‘type’>
None对象 False





序列
概念
成员关系操作符：
in ，not in 操作符；
Seq[i]	下标为i的元素
Seq[ i1 : i2: step]  seq[i1] ~ seq[i2-1]的集合  step步长默认1，负数是倒过来，None是最后一个
Seq * expr  序列重复expr次
Seq1 + seq2 连接序列

i = iter(myTuple)  获取序列迭代器
>>> i.next()  第一个元素




序列内建函数
转换：list()   str()  tuple() 
辅助：enumerate() 返回索引，值的pair，   len，max，min
Reversed，sorted，sum，zip返回pair列表


字符串
‘http://’#protocol  ‘localhost’ #hostname …  字符可以自动拼接，可以加注释了。
‘Hello’+u’’ + u’!’  -> u’Hello!’  自动转成Unicode。
重复操作符：*
	‘Ni’ * 3  ->  ‘Ni!Ni!Ni!’
格式控制：
同C。
	辅助指令：*		精度；-		左对齐；+		加号；<sp>		空格；
# 八进制0，十六进制0x；0		填0；m.n	总宽.小数位

原始字符串：
所有的字符都是按照字面意思使用，没有转义或不能打印字符，这对regex的创建等工作变得简单。
r’\n’  ->  ‘\\n’

内建函数  P186

unicode
u’…’；
unicode()  和 unichar() 转换；
使用：
1）	一定要加前缀u
2）	不要用string模块，str()等函数，用unicode版本；
3）	直到写文件或数据库或网络时才调用encode()编码，读的时候decode()解码；


列表
aList = [123, 'abc', 4.56, ['inner', 'list'], 7-9j]
list('foo')  ->   ['f', 'o', 'o']
aList[2] = 'float replacer'
del aList[1]
aList.remove(123)
1ist1 < list2
切片访问
+ ,*, in,not in,

元组
和列表相似，用()，区别：不可变类型，所以可以用作字典的key；
并不是绝对不可变：
t = ('third', 'fourth')
t = t + ('fifth', 'sixth')

t = (['xyz', 123], 23, -103.4)
t[0][1] = ['abc', 'def']

return 'abc', -4.24e93
x, y = 1, 2 等，默认都是元组
一个元素的元组：(‘xyz’,)  有个逗号


浅拷贝和深拷贝
序列类型对象的浅拷贝是默认的，1）完全切片[:]  2）工厂函数list(),dict()  3）copy模块的copy函数  都会实施；
person = ['name', ['savings', 100.00]]
hubby = person[:] # slice copy
wifey = list(person) # fac func copy
hubby[0] = 'joe'
wifey[0] = 'jane'
>>> hubby, wifey
(['joe', ['savings', 100.0]], ['jane', ['savings', 100.0]])
>>> hubby[1][1] = 50.00
>>> hubby, wifey
(['joe', ['savings', 50.0]], ['jane', ['savings', 50.0]])
字符串是不可变对象，序列是浅拷贝；
>>> import copy
>>> wifey = copy.deepcopy(person)
这样再修改就不会了；


字典
dict2 = {'name': 'earth', 'port': 80}
>>> ddict = {}.fromkeys(('x', 'y'), -1)
>>> ddict
{'y': -1, 'x': -1}
>>> edict = {}.fromkeys(('foo', 'bar'))
>>> edict
{'foo': None, 'bar': None}

>>>> for key in dict2:
... print 'key=%s, value=%s' % (key, dict2[key])

del dict2['name'] # 删除键为“name”的条目
dict2.clear() # 删除dict2 中所有的条目
del dict2 # 删除整个dict2 字典
dict2.pop('name') # 删除并返回键为“name”的条目

'name' in dict2

比较顺序
长度， key， 值；


集合
set，frozenset
s = set('cheeseshop')  唯一创建方法；
联合 |，交集 &， 差集 s-t 只属于s， 对称差分^ ；




性能
while i < len(s) :    计算一次
ls = os.line		 取别名


书签  556¬



xml
一、xml文档规则
语法：
1，只有一个root元素
2，<XX>...</XX>开始标签、结束标签，标签名可以有- . : a-zA-Z 0-9
3，区分大小写
4，空元素<XX.../>
5，属性必须有值，且必须""或''包含，属性无序，同一个元素不能有同名属性
6，声明：必须首行
	<?xml version="1.0" encoding="GB2312" standalone="yes"?>
	      遵守XML1.0规范（必须） 对文档解码用的字符集 文档是否要引用其它资源
字符集：GBK简体中文，BIG5繁体中文，Unicode，UTF-8默认。
保存时，中文版的windows默认以GBK编码，如果读、写用的字符集不一致，会导致乱码。
7，字符数据
	1）xml合并空白
	2）实体引用：&lt; <    &gt; >   &amp;  &   &apos; '   &quot; "
	3）<![CDATA[文本内容]]> 文本内容不做任何处理，没用；
	
8，处理指令：告诉XML处理程序如何处理
	放前排。
	<?处理指令名 处理信息?> 一般都是开发者自己提取信息处理的，在XML中它不会有作用。
	如：<?xml-stylesheet  type="text/css" href="book.css"?> 导入样式单
	
9，其它
	多写点元素比用属性好，可读性，维护，扩展等都好；
	ASCII有两个行尾控制符：\r回车，\n换行; windows存储\r\n，unix \n，mac \r；
xml以\n存储; 


约束的作用：xml允许哪些元素、元素关系、支持哪些属性、元素数据类型、文本内容，默认值等；
二、XML Schema语法
语法：
1，Schema本身就是xml，Schema根元素<schema.../>
<xx:schema xmlns:xx="http://www.w3.org/2001/XMLSchema"> 
xmlns属性：Schema文档要使用的语义约束，xx：xml可以有多个Schema，所以这个xx是命名空间前缀

<?xml version="1.0" encoding="gb2312"?>
<xs:schema xmlns:xs=" http://www.w3.org/2001/XMLSchema "
 xmlns="http://www." <!-- 使用这里的组件时，不需要前缀-->
 xmlns[:xxx]=”可以有多个”
 targetNamespace="x88"> <!-- 使用正在编写的这个Schema组件的前缀是x88-->
</xs:schema>

schema其它属性：
	1）elementFormDefault=qualified/unqualified 指定XML文档使用该Schema中定义的局部元素时是否用命名空间。
	2）attributeFormDefault=qualified/unqualified ...局部属性是否使用...

2，导入到XML文档里
<?xml version...?>
<booklist xmlns:qqq="http://ww.w3.org/2001/XMLSchema-instance" <!--导入http对应的Schema，使用前缀qqq -->
	qqq:noNamespaceSchemaLocation="xxx.xsd" <!--Schema文件URI -->
	xmlns:ppp="http://www..." <!--有命名空间的 -->
	xmlns:zzz="http://..."
	ppp:schemaLocation="ppp.xsd zzz.xsd">
	<book1>
		<ppp:Introduction>This is an IT book</ppp:Introduction>
		<zzz:Address>Shanghai</zzz:Address>
	</book1>
</booklist>

3，注释
<!-- -->
<annotation.../>
	<documentation.../>
	<appinfo.../>

4，数据类型
1）内置类型
string
normalizedString 	tab,/n,/r当作空白处理
token		当作空白且压缩连续空白
Name		合法的XML标签名
QName		带命名空间的标签名，可以省略前缀
NCName		不带命名空间的标签名

integer
positiveInteger		1,2...
negativeInteger		...-2,-1,
nonNegativeInteger	0,1,2...
nonPositiveInteger	...-2,-1,0
long	[-9223372036854775808,9223372036854775807]
unsignedLong
int		[-2147483648,2147483647]
unsignedInt
short	[-32768,32767]
unsignedShort
byte	[-128,127]
unsignedByte

float		5.6e3(5600), 5.6, -INF(负无穷),INF(正无穷),NaN(非数),+0(正零),-0
			其中：+0>-0;NaN大于所有;INF大于一般浮点数;double类似;
double
decimal		精确小数，18位，不支持科学计数法，-INF,INF,NaN等

boolean		true,false,1,0

前加-号表示公元前，后加Z表示UTC时间
duration	PnYnMnDnTnHnMnS	P是必须滴，S前的n可以有小数
dateTime	YYYY-MM-DDThh:mm:ss.sss	T是必须滴
data		YYYY-MM-DD
time		hh:mm:ss.sss
gYear		YYYY
gYearMonth	YYYY-MM		中划线是必须滴
gMonth		--MM
gMonthDay	--MM--DD
gDay		--DD

anyURI		URI包含着URL，网络，文件，本地磁盘...
language

base64Binary	4n个字符的16进制
hexBinary		偶数位的16进制数

两种指定类型的方式
1），<xs:element name="books" type="xs:token"/>
2），<xs:element name="books">
		<xs:simpleType>
			<xs:restriction base="xs:token">
			</xs:restriction>
		</xs:simpleType>
	</xs:element>


派生类型
<restriction.../>在现有类型上添加一个或多个约束。
12种：
	enumeration 枚举
	fractionDigits 定义小数点后的位数
	totalDigits	小数+整数位数
	length 字符长度
	minExclusive 下界
	maxExclusive 上界
	minLength 字符最小长度
	maxLength 最大
	minInclusive 下界（包含）
	maxInclusive 上界（包含）
	pattern 正则
	whiteSpace 对字符中空白的处理，preserve保留，replace替换，collapse替换再压缩

<!--*.xsd-->	
<?xml version=...?>
<xs:schema xmlns:xs="...">
	<xs:simpleType name="age_Type">  <!--simpleType和complexType用于定义新的数据类型 有id name属性 -->
		<xs:restriction base="xs:int"> <!-- id base属性-->
			<xs:maxInclusive value="100"/> <!--约束的使用 value属性 -->
			<xs:minInclusive value="0"/>
		</xs:restriction>
	<xs:simpleType>
	<xs:element name="age" type="age_Type"/> <!-- 定义一个元素（标签）type指定类型 name指定名字-->
</xs:schema>


<list.../>
//...
	<xs:simpleType name="age_list_Type">
		<xs:list>  //在为list指定基类型
			<xs:simpleType> //使用simpleType子元素
				<xs:restriction base="xs:int">
					<xs:minExclusive value="0">
					<xs:maxExclusive value="100">
				</xs:restriction>
			</xs:simpleType>
		</xs:list>
	</xs:simpleType>
	<xs:element name="age_list" type="age_list_Type"/>
	
	//xml中
	<age_list>
		57 12 23	9		//替换再压缩
		68
	</age_list>
	
		<!--另一种定义方式-->
		<xs:simpleType name="age_list_Type">
			<xs:restriction> //也可以在这里用base指定基类型
				<xs:simpleType> //定义一个匿名列表类型作为<restriction.../>元素的子元素，即被限制的基类型
					<xs:list itemType="age_Type"/> //list的itemType属性
				</xs:simpleType>
				<xs:length value="4"/>
			</xs:restriction>
		//...
		
		<!--另一种方式，不需要约束-->
		<simpleType name=”email_list_type">
			<list itemType="email_type"/>
		</simpleType>
		
	列表约束：
	length,maxLength,minLength,列表元素个数
	enumeration
	pattern
	whiteSpace 只是collapse
	
	
	
<union.../>
将多个简单类型联合成新类型。
创建方式：
1）memberTypes属性，空格隔开
2）增加多个<simpleType.../>子元素
P109例子

限制：enumeration,pattern

list和union可以嵌套，但list不能含list。


阻止派生、约束fixed
<simpleType.../> final属性 =#all不能通过增加约束派生，也不能派生list，union类型。
=restriction、list、union或其组合，不允许相应的派生

有时候派生会覆盖原约束，如果合理，就会覆盖，但指定fixed就会报错了。

Schema的合并
开发将不同模块的XML组件定义在不同的Schema中，再合并。
方式：
	1，include元素
	必须是<schema.../>的子元素；必须靠前放，除了<import.../>、<redefine.../>和<annotation.../>可以放在它前面；被包含的Schema会丢失本身的命名空间；
属性：id 元素的唯一标识
schemaLocation
	2,redefine元素
	取代include，支持重定义被包含的Schema类型。
	3，import元素
	要么没有目标命名空间，要么空间名和当前Schema的不同，使用被导入的Schema组件时要加前缀。
属性：id schemaLocation namespace没有则省略
	
	
	
复杂类型 : 即子类型
两种定义方式：
全局命名的复杂类型：将<complexType.../>作为<schema../>的子元素。
局部匿名：将<complexType.../>作为<element.../>的子元素。

complexType子元素
<simpleContent.../>用于定义包含简单内容的复杂类型。
	只能有<restriction.../>（添加约束）或<extension.../>（添加属性）子元素。
<complexContent.../>包含复杂类型的。
	
	
关于属性关联元素：
1）局部属性：直接放在<complexType.../>内
2）全局属性：<schema.../>的子元素，通过<attribute.../>指定ref属性关联。
fixed：为元素指定固定值；default：默认值

<...>
	<complexType name="book_type">
		<simpleContent>
			<extension base="decimal">
				<attribute name="isbn" default="123456"> //属性：局部
					<simpleType>
						<restriction base="int">
							<totalDigits="8">
						</restriction>
					</simpleType>
				</attribute>
				<attribute name="name" type="token"/> //属性：局部
			</extension>
		</simpleContent>
	</complexType>
	
	<attribute ref="isbn" use="optional"/> //引用全局属性；
	use属性 optional可选，prohibited禁止的，required必需的
	use只有在指定了ref属性和局部时使用。
	
anyType派生新类型	
<sequence.../>子元素必须按顺序出现
<choice.../>只能出现之一
<all.../>任意出现
	
Schema约定：如果某个类型是由anyType派生的，那么定义该类型时可以直接在<complexType.../>内使用<sequence.../>等来定义元素和属性。
如：
<xs:schema ...>
	<xs:complexType name="book_type">
		<xs:sequence>
			<xs:element name="name" type="xs:string" maxOccurs="unbounded"/> //允许出现的次数,all只能是0或1
			<xs:element name="price" type="decimal"/>
		</xs:sequence>
		<!--定义属性-->
		<xs:attribute name="isbn" type="xs:int" use="required"/>
	</xs:complexType>
</xs:schema>
还可以嵌套

空元素类型 P137
混合类型mixed属性="true" P138
复杂类型的进一步派生：限制和扩展。
限制空元素：对属性的进一步约束；删除某个属性（prohibited）;
扩展空元素：增加属性；增加子元素；增加mixed="true"
限制/扩展包含子元素的类型：进一步约束属性；对子元素进一步约束；删除属性/元素

阻止派生：<complexType.../>final属性=“#all"，extension，restriction及其组合。


通配符
<any.../>元素通配符，可以代替任意元素
属性：maxOccurs minOccurs 
namespace 元素来自##any任意命名空间 ##other ##local（无命名空间） ##targetNamespace URI 组合
processContents 指定XML处理器如何验证替换的元素=strict,lax,skip

<anyAttribute.../>属性通配符
类似<any.../>

元素替换
给元素指定substitutionGroup属性
替换与被替换都是全局元素
要么是相同类型，要么是子转父



抽象元素和类型
abstract="true"
在XML中必须用替换元素或派生类型替换


一致性约束
key约束：指定内容必须存在且唯一
keyref：两个数据的引用关系，refer属性（来自哪里）
unique：指定内容唯一但可以不存在
<element.../>最后面定义
指定约束对哪些部分起作用，必须使用：
	<selector.../>：XPath表达式，指定元素范围，只出现一次。
	<field.../>：XPath表达式，{1,more}
	含义：在范围内，field表示的内容遵守一致性约束。多个field，只要组合遵守即可。
	
例子：P164


元素组、属性组
<group.../>
<attributeGroup.../>
P166

定义符号
<notation.../>
属性：id name（符号名称，唯一）
public：符号所标识的数据格式或处理程序，必选
system：同上，可选
P168


命名空间
xmlns或xmlns[:prefix]
XML元素所在的范围，往往使用URL，本公司/组织域名+项目名+模块名
由于名字一般很长，所以起了别名：prefix

在Schema根元素中指定targetNamespace属性，表明组件放在这个命名空间下。
<?...?>
<xs:schema xmlns:xs="http://...2001/.."
	targetNamespace="http://www.maoyinan.org/schema"
	xmlns="http://www.maoyinan.org/schema"> //取别名，使用该空间不需要前缀
	//...
对一致性约束的影响：只要元素没有添加前缀，它就认为元素不在任何空间下，即使你定义了不加前缀的空间。解决办法是加前缀。

elementFormDefault和attributeFormDefault意思是XML中使用Schema局部元素或属性时，能不能省略前缀，推荐qualified不省略，虽然复杂但明确。
	
	
	
	
XPaht语言
专门在XML中查找信息的语言。


解析XML
流行规范：
	DOM：文档对象模型：DOM解析器读入整个文档（常驻内存的树状结构）。
	SAX：事件驱动机制。发现文档开始、元素开始。。。向外发送事件，程序员编写事件监听来获取信息。
	内存更小，速度更快。

XML解析器：Apache的Xerces项目，提供C++，Java，Perl等语言的实现。



dom4j和JDOM解析器都是专门解决Xerces-J的繁琐的。

XQuery是查询XML数据的，类似SQL语句，要想获得查询结果，界面上有大量工具，代码中要借助专门的API。
XQuery建立在XPath上。


















html
简要
http://www.w3school.com.cn/
sublime text 3使用，输入!,ctrl+e；
发布自己的网站
浏览器通过请求从web服务器读取页面，类似：http://www.... 如何显示是浏览器的事；
所有网页的集合叫网站，要发布才能让别人看到（把网站放到一个web服务器上），web服务器可以是你的pc，不过大多是ISP提供的web主机；
ISP
连接Internet的速度，24小时支持，备份重要数据，流量带宽，电子邮件，数据库访问，安全和稳定性。。。
磁盘空间：图片，音视频文件大小等；
月流量：访问量，超过限制了网站会关闭，额外费用，容易升级吗？
签合同之前可以访问下其他客户或网站；
图片服务器：分离负载模块；
CDN：内容分发网络，通过在网络各处放置 节点服务器 所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
域名
去域名注册公司买一个；

在本地部署网站
控制面板，打开或关闭windows功能，IIS服务；
打开IIS管理器，右键网站，将html/css/js文件路径添加进去，ip/port配置一下，局域网内即可访问了；


标签
概念
标签的含义，分类，属性，事件，上w3c 查手册；
全局属性，每个标签都可以指定的，如id（标签唯一）,class,style（css相关）;
相似标签的区别，如<span>,<p>,<div>；
不同浏览器支持的h5标签不同：支持度不同，名字不同。。。；

常用标签一览
头部和元信息
<script脚本><style内部样式><link外部样式><title标题><base链接前缀target,href><meta元数据>
元数据属性
http-equiv 元数据名称（浏览器专用）
<meta http-equiv=”Expires” content=”Sat Sep 27 16:12:36 CST 2008”/> 网页过期时间
http-equiv=”Pragma” content=”no-cache” 禁止缓存网页
http-equiv=”Refresh” content=”2” 2s后自动刷新网页
http-equiv=”Set-Cookie” content=”name=value expires=过期时间, path=/”  设置Cookie，过期Cookie会删除
http-equiv=”content-Type” content=”text/html;charset=GBK” 页面内容和字符集
http-equiv=”X-UA-Compatible” content=””强制浏览器按照特定标准渲染网页；

name=”generator页面生成工具/description站点内容/keywords搜索引擎关键词”
content 值


body标签
<style样式><h1-6标题><p段落><br换行><hr水平线><div块><span块>
<b粗体><i斜体><em强调><strong粗体（增强语义）><small小字><sup上标><sub下标><bdo文本方向><mark重点><time时间，如果内容不是yyyy-mm-ddThh:mm:ss格式，就要datetime属性>
<abbr缩写><address地址><blockquote长引用><q短引用><cite作品标题><code代码><dfn专用术语><del删除的文本><ins插入的文本><pre保留格式><samp示范文本><kbd键盘输入的文本><var变量><article文章<header,footer,section,article子元素互相嵌套>><nav导航条><aside附属信息><figure图片区域><figcaption标题>
<a超链接href 资源url,target在哪里打开,media资源类型>  href=”xx.html#锚点(id)”
<ul无序列表><ol有序列表><li列表子元素><dl普通列表><dt列表标题><dd列表项>
<img图像 src图片url,alt图片文本,height,width><map图片映射><area图片映射区域>
<table表格 cellpadding内容与边框间距,cellspacing单元格间距,width><caption标题><thead头><tfoot><tr一行><tbody表格体><td单元格 colspan横跨多少列,rowspan><th页眉(td加粗)><colgroup整体指定属性><col子元素>
<iframe内联框架显示资源 src>
<meter计数仪表图形><progress进度条>


示例：
<div><bdo dir=”ltr”><b onclick=..>文本</b></bdo><br/></div> keyword：标签、属性、事件、内容、嵌套；
<img src=.. usemap=”#map名”>  keywrod：配合
<map name=...>
	<area ..>
常用属性一览
id唯一标识，style样式，contentEditable=”true”可编辑（继承），designMode=’on’整个html可编辑，hidden=”true”，draggable=”true”可拖拽
h5拖拽api
简要
拖动能携带数据，交互更强大，指定draggable=”true”即可，然后为拖动元素绑定事件监听器；

使用js控制拖放

事件一览
ondragstart开始拖动；ondrag在拖动；ondragend结束；ondragenter拖动时鼠标经过的元素触发，进入；ondragover在范围内；ondragleave离开；ondrop范围内结束；

<div id="abc" draggable="true">abc</div>
		<script type="text/javascript">
			var btn = document.getElementById("abc");
			btn.ondragstart = function(evt){//绑定事件
				evt.dataTransfer.setData("text/plain","abc");
			}
			document.ondragover = function(evt){
				return false;//取消事件默认行为
			}
</script>

拖放事件有一个dataTransfer属性，它是一个DataTransfer对象，属性和方法有：
dropEffect拖放目标上的拖放行为：none、copy、link、move
effectAllowed拖放元素的行为：none、copy、copyLink、copyMove、link、linkMove、move、all、uninitialized；
items拖放数据DataTransferItems对象；
setDragImage设置拖放图标；
addElement添加图标；
types返回DOMStringList对象，包含了所有数据类型；
getData获取数据；
setData设置数据；
clearData清除数据；

h5多媒体
简要
以前网页播放音视频通常借助于第三方插件，如flash，或者开发者自己开发多媒体播放插件；
现在h5提供audio和video，各浏览器厂商实现了内置的播放器，但是音视频格式 涉及相应厂商的专利，浏览器无法自由使用它们的解码器；

<audio controls> //兼容写法
	<source src="筷子兄弟 - 我一定要得到你.mp3" type="audio/ogg">
	</audio><br/>
	<video src="想变得可爱.mp4" controls>不支持</video><br/>

<audio/video音频 src资源URL，autoplay自动播放，controls播放控制条，loop循环，preload预加载=auto全部，metadata元数据，指定autoplay忽略，poster视频用，播放之前的海报，width视频用，height>

使用js控制播放
audio元素对应HTMLAudioElement对象，video-HTMLVideoElement，支持的方法：play，pause，load，canPlayType浏览器是否支持类型播放；

属性一览
buffered返回TimeRanges对象，浏览器缓存的数据；currentSrc播放资源的URL；currentTime时间点秒；defaultPlaybackRate播放速度；duration持续时间秒；ended播放结束否；error有错误返回MediaError对象；muted静音否；networkState下载资源状态；paused暂停否；playbackRate播放速度；played返回TimeRanges对象，已播放时间段；readyState准备状态；seekable返回TimeRanges对象；seeking是否在定位；startTime开始时间；volume音量；
注：TimeRanges是时间段数组，length，start(index)，end(index)第index个时间段的开始结束时间；

事件一览
onabort播放器下载数据中止了；oncanplay播放中间缓冲数据时；oncanplaythrough不缓冲；ondurationchange文件长度改变；onemptied元素为空（网络、加载错误）；onended播放结束；onerror出错；onloadeddata加载完成后；onloadedmetadata元数据加载完成后；onloadstart开始加载；onpause暂停；onplay播放；onplaying正在播放；onprogress正在加载；onratechange速度变化；onreadystatechange状态改变；onseeked成功定位后；onseeking在定位；onstalled延迟；onsuspend未获取全部数据停止；ontimeupdate播放位置改变；onvolumechange音量改变；onwaiting暂时得不到下一帧；



表单
简要
收集用户输入，作为请求参数提交到服务器；

表单元素
<form表单action提交的地址,method请求类型,enctype字符集,name表单名称,target>
注：
1），请求类型 GET,POST，GET会把请求参数以name-value字符串附加到原URL后，POST则放到html header中；
2），enctype类型，application/x-www-form-urlencoded 默认，只处理控件的value值，multipart/form-data 以二进制流处理，文件域的文件内容也作为请求参数，text/plain，当action是mailto:URL时；
3），每个有name属性的控件对应一个参数，相同name一个参数多个值；
如：http://www.xxx.org/?username=abc&username=&ok=%CC%E1%BD%BB，?开始，username是相同name，&隔开，value为空不填，%CC..是中文，用了默认编码；
<input输入控件 type类型，checked，disabled，maxlength，readonly，size宽度，src>
注：
1)，type类型，单行文本text，密码输入password，隐藏域hidden（提交额外请求参数），单选radio，复选checkbox，图像域image（有图像的提交），文件域file，提交、重设、无动作submit，reset，button，颜色选择器color，日期选择器date，时间选择器time，UTC日期时间datetime，datetime-local，第几周week，month，email（multiple属性），url，number，拖动条range（min，max，step）；

<label标签>有语义，点击获得焦点；
		<label for="username">用户名：</label>
		<input id="username" name="username" type="text" /><br/>
		<label>密码框：
			<input id="pswd" name="pswd" type="password" />
		</label><br/>
<button按钮 type类型，name，value，disabled>，可包含文本格式化标签，图像等，不要放图像映射；
<select列表框或下拉菜单multiple，size显示多少项（指定任一个就显示列表框）><option列表项 disabled，selected，value><optgroup项组 label，disabled>
<textarea文本域>，文本内容作为value值；
<input type=”file”文件上传域 accept 文件MIME类型，multiple>，多个文件，js可访问文件内容，P69；

表单属性
form=”form name”，控件属于哪个表单；formaction提交给不同的action；formxxx属性：动态改变，formenctype ，formmethod，formtarget；
autofocus自动获得焦点；placeholder默认提示信息；
list属性，一个ComboBox功能，值=<datalist>的id，<datalist>和select一样，只是它看不见；
required必填，pattern符合正则，min、max、step数值、日期类型范围；
name/id属性不能和对象的原有方法和属性名相同，会导致失效；

表单校验
1），required，pattern，min、max、step等属性；
2），checkValidity()表单控件方法，P76；

绘图
简要
h5新增<canvas画布>，获取CanvasRenderingContext2D对象，使用js控制绘图；
	<canvas id="mycanvas" width="300" height="180" style="border:1px solid black">
	<script type="text/javascript">
//三步：1）获取Canvas对象，2）获取CanvasRenderingContext2D对象，3）调用api绘图
		var mc = document.getElementById('mycanvas');
		var ctx = mc.getContext('2d');
		ctx.fillStyle = '#f00';
		ctx.fillRect(30,40,80,100);
	</script>	
	</canvas>

绘图api一览
https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D
arc画弧；arcTo画弧；beginPath定义路径；closePath结束路径；bezierCurveTo贝塞尔曲线；clearRect擦除矩形区域上的图形；clip裁剪画布；createLinearGradient线性渐变；createPattern平铺；createRadialGradient圆形渐变；drawImage绘制位图；fill填充路径；fillRect填充矩形；fillText填充字符串；lineTo画线；moveTo移动点；quadraticCurveTo二次曲线；rect画矩形；stroke画路径边框；strokeRect画矩形边框；strokeText画字符串边框；save保存绘图状态；restore恢复绘图状态；rotate旋转坐标系；scale缩放坐标系；translate平移坐标系；

绘图属性一览
fillStyle填充样式；strokeStyle画笔样式；font字体；globalAlpha透明度；globalCompositeOperation叠加效果；lineCap线条端点样式；lineJoin线条拐点样式；miterLimit拐点样式为meter控制；lineWidth线宽；shadowBlur阴影模糊度；shadowColor阴影颜色；shadowOffsetX阴影偏移；textAlign文本水平对齐方式；textBaseAlign垂直对齐方式；


CSS
简要
css3.0是最新标准，控制html文档显示的；
4种用法：
	链接外部（css与html分离）；
<link rel="stylesheet" href="test.css" type="text/css" />
	导入外部；
<style type="text/css">
		@import url("mycss.css");
</style>
	使用内部（head下定义style）;
	使用内联（控制部分元素）；
<div style="font-size: 18px;
	color: #60c;
	height: 30px;">
内联语法格式：style=”属性1：值1;属性2：值2...”

定义样式的格式大致如下：
selector { //对哪些元素作用
property1 : value1;
property2: value2;
 ...}
所以css就是掌握selector定义方法 和 css样式；

效果是叠加显示的，取优先级高的，各浏览器支持度不同；

单位
像素：1英寸=90像素，和分辨率有关；
em：本元素字体的font-size，如元素font-size=14，那1em=14px；如果font-size本身以em为单位，则取父节点的；
%：font-size * %；


选择器定义
E{}：元素；
E[attr]{}：对具有attr属性的元素；
E[attr=value]{}：对attr=value的元素；
E[attr ~=value]{}：attr是系列值，以空格隔开，对attr的某个值=value的元素；
E[attr |=value]{}：attr是系列值，以|隔开，对attr第一个值=value的元素；
E[attr ^=”value”]{}：对attr的值是以value字符串开头的元素；
E[attr $=”value”]{}：value字符串结尾；
E[attr *=”value”]{}：包含value字符串；

#id{}：选择id；
E#id{}：元素内id；

.class{}：选择class；
[E].class{}：元素内class；

sel1 sel2 {}：选择器内的选择器；
sel1>sel2{}：选择器内的子元素；
sel1~sel2{}：选择器的兄弟元素；
sel1,sel2..{}：选择器组合；
sel1:not(sel2)：符合sel1但不符合sel2；

sel:root/first-child/last-child/nth-child(n)/nth-last-child(n)/only-child/first-of-type/last-of-type/nth-of-type(n)/nth-last-of-type(n)/only-of-type/empty：child是子元素，type是兄弟元素，nth还可以指定n=odd/event奇偶，3n+1(n=0,1,2…)；
sel:link/visited：未访问过的/访问过的超链接；
sel:active/hover：鼠标点击未释放/悬停/获得焦点的元素；
sel:focus/enabled/disabled/checked/default/read-only/read-write/selection：获得焦点/可用/不可用/选中/默认选中/只读/读写/选中内容；
sel:target：锚点目标元素；

:first-letter：对象的第一个字符；
:first-line：第一行，和first-letter一样，只对div,p,section等起作用，span需要指定宽高或position或display；
:before：对象前端插入数据；
:after：尾端；

css属性一览
其它
content元素之前或之后插入内容：字符串、url(url)、attr(alt)、counter(name)、counter(name,list-style-type)、open-quote、close-quote等；quotes为content定义open/close-quote的，两个空格隔开的字符串；counter-increment计数器；counter-reset计数器复位；
div>div{ counter-increment: cnt;  } //quotes,counter-increment,counter-reset是配合content使用的；
div>div:before{ content:counter(cnt) ') '; / content:'第' counter(cnt,upper-roman) '个  '; }
counter-reset属性用在多级编号，在父元素内重置；

文字
font字体 font-style font-variant font-weight font-size line-height font-family；color颜色；font-family字体（浏览器内嵌，逗号隔开的多个字体，优先）；font-size大小，xx-small/large/../%父组件百分比/11pt/px；font-size-adjust字体大小微调；font-style风格，normal/italic斜体/oblique倾斜；font-weight加粗，lighter/normal/bold/bolder/100；font-stretch字体横向拉伸，narrower压缩/wider拉伸；text-decoration修饰线，none/blink闪烁/underline下划线/line-through中划线/overline上划线；font-variant大写字母格式，normal/small-caps；text-shadow文字阴影；text-transform大小写，none/capitalize首字母大写/uppercase全大写/lowercase全小写；line-height行高；letter-spacing字符间距；word-spacing单词间距；
text-shadow:color xoffset yoofset length / x y radius color；多个阴影逗号隔开；
font-size-adjust：同样16px大小，宽度不同，小写x高度/16px，固定；
color：，#88/red/rgb()，hsl hue色调0红色120绿色240蓝色，saturation饱和度%，lightness亮度%，rgba，alpha透明度0~1，hsla；
text-indent缩进；text-overflow文本溢出，clip裁剪/ellipsis省略号；vertical-align垂直对齐，auto/baseline/sub/super/top/middle/bottom/length；text-align水平对齐，left/right/center/justify两端对齐；direction文本方向，ltr/rtl；word-break换行方式，normal浏览器规则/keep-all/break-all单词间换行；white-space空格处理，normal/nowrap不换行；word-wrap内容换行，normal/break-word；
@font-face{ font-family:name任意; src: local(url), ur(url) format(“TrueType/OpenType”);}服务器字体，优先使用本地；

背景
background背景；background-attachment背景图片滚动否，scroll/fixed；background-color颜色；background-image图片；background-position图片位置；background-repeat平铺，repeat/no-repeat/repeat-x/repeat-y；background-clip背景覆盖范围；background-origin背景覆盖起点；background-size背景大小，20px/80%父组件/auto纵横比；
 
background-clip/background-origin，border-box边框以内/no-clip边框以内/padding-box内补丁以内/content-box内容区；
可以指定多张背景图片，及它们的重复，位置等属性；

边框
边框
border粗细线型颜色复合；border-color；border-style线型，none/hidden/dotted点线/dashed虚线/solid实线/double双线/groove3D凹槽/ridge3D凸槽/inset3D凹入/outset3D凸入；border-width；border-top/right/bottom/left上右下左边框复合；border-top-color/border-top-style/border-top-width；border-radius圆角边框；border-top-left-radius；
padding/margin内/外补丁边距；padding/margin-top；
粗细线型颜色 指定4个参数，上右下左，2个参数，上下左右，3个参数，上左右下，1个参数，所有；
圆角指定2个参数，左上右下，3个参数，左上右上左下；
height；max_height；min_height；width；内容区宽高；box-sizing指定区域，content-box/padding-box/border-box；resize可拖动改变大小否，组件要设置overflow属性，none/both/horizontal/vertical/inherit继承父组件默认；
布局&盒模型 
盒模型
能呈现一片空白的元素，都可以当盒模型，盒子模型和布局不冲突，div，span，section等，
盒子的3D模型
从上到下依次：border，content+padding，bg-image，bg-color，margin；
display属性可控制其外观，none/block/inline/inline-block/inline-table； 
block，默认占据一行；
inline，一行可以有多个组件； 
none隐藏对象，页面空间释放；
inline-block既不一行又能指定宽高，默认底端对齐，vertical-align:top；
inline-table/table/table-caption/table-cell/table-column/table-column-group/table-header-group/table-footer-group/table-row/table-row-group，表格既不一行又能指定宽高，将组件显示为表格元素；
list-item将组件转化为列表元素，list-style-type序号类型；
box-shadow盒阴影，hOffset水平偏移/vOffset/blurLength模糊度/scaleLength缩放度/color；
columns分栏复合宽和数，column-width/column-count，column-rule分隔条复合宽样式颜色，column-rule-width/style/color，column-gap栏间距，column-fill栏高，auto/balance统一成内容最多的；

布局
 
有标准的文档流、float属性，position属性等；
标准文档流
标签元素（div，ul，li，dl，span...），触碰到边缘会自动换行，一个元素就是一个“盒子”，有margin，padding，border，content；
浮动布局
float，会左右移动，直到碰到容器（父元素）边缘，仍然是标准文档流中，left/right属性；
设置了float，元素的宽度随内容变化，受其影响的只有它后面紧邻的元素；
clear清除浮动（对紧邻的后面的元素），none/left/right/both都不允许；clip裁剪，auto不裁剪/rect(A,B,C,D)该区域显示，overflow要设置hidden；overflow/overflow-x/y组件不够容纳内容时显示方式，visible不剪切不加滚动条/auto加滚动条/hidden裁剪/scroll总是显示滚动条；visibility元素显示隐藏，元素页面空间保留；
 


绝对布局
position（层模型），absolute绝对定位/relative相对前一个对象（仍在文档流中）/static（默认）；
absolute不在文档流中了，宽度随内容变化；
偏移：无已定位的祖先元素，以<html>为偏移参照基准，有已定位，则参照最近的定位祖先元素偏移；
z-index漂浮层数；top/left/right/bottom偏移；
outline轮廓颜色线型线宽；outline-color/outline-style/outline-width/outline-offset轮廓与边框的距离；

表格&列表&光标
border-collapse边框合并还是分隔，separate/collapse；border-spacing边框间距；caption-side标题位置top/bottom/left/right；empty-cells空内容是否显示边框separate时有效，show/hide；table-layout宽度布局，auto/fixed；

list-style复合序号图片位置类型；list-style-image/position/type，outside/inside；

改变光标在组件上的形状；
all-scroll十字箭头/col-resize水平拖动线/crosshair十字线/move移动十字线/help问号箭头/no-drop禁止光标/not-allowed禁止/pointer手型/progress沙漏/row-resize垂直拖动/text文本编辑/vertical-text旋转90度/*-resize各种方向拖动光标，w/s/n/e/ne/sw/se/nw，上北下南；

media query
对方设备、浏览器等原因，如分辨率，色深，最终效果非常丑陋，css定义了各种媒体类型，针对不同设备编写；
语法：
@media [not|only] 设备类型 [and 设备特性] *（出现0~N次）
设备类型：all/aural语音和音频合成器/braille触觉反馈/embossed盲文印刷/handheld手提/print打印机/projection投影图像/screen计算机显示器/tty固定间距字符设备/tv电视类；
设备特性：width/min/max-width浏览器宽/height/aspect-ratio宽高比/device-width设备分辨率/device-height/device-aspect-astio/color设备色深（多少位）/color-index色彩表颜色数/monochrome单色帧缓冲器中每像素位数/resolution分辨率值/scan扫描方式，progressive逐行/interlace隔行/grid基于栅格否；

变形与动画
transform设置变形，translate(tx[,ty])平移/translateX/Y/scale(sx,sy)缩放比/scaleX/Y/rotate(angle,30deg)顺时针旋转/skew(sx[,sy])横/纵向倾斜/skewX/Y/matrix(m11,m12,m21,m22,dx,dy)变换矩阵/transform-origin变形中心点，xCenter/yCenter=left/top/right/bottom/center/长度值/%/left top组合；
矩阵变换公式：(x,y) *( ■(m11&m12@m21&m22)) = (x*m11 + y*m21, x*m12 + y*m22); 再平移dx,dy；

transition设置动画，transition-property对哪个属性进行平滑渐变，width,bg-color等/transition-duration/transition-timing-function渐变速度，ease慢-快-最快-慢/linear匀速/ease-in慢-快/ease-out快-慢/ease-in-out同ease/cubic-bezier(x1,y1,x2,y2)贝塞尔曲线控制；
同时指定多个，不同属性用分号，同属性指定多个用逗号；
transition: left 5s linear, top 5s linear;
transform:rotate(24deg);transform:translate(5px);
 
贝塞尔曲线，x轴：时间，y轴：属性完成度；

Animation动画，animation-name已有关键帧/animation-duration/animation-timing-function速度/animation-delay多久开始执行/animation-iteration-count循环次数；
animation-name格式：
@keyframes 帧名称{
from | to | % {//关键帧位置
属性n：值n;}}

JavaScript
概念
桌面，游戏机，平板，手机。。。它们的Web浏览器都有JavaScript解释器，它是一种脚本语言，浏览器动态解释执行（无须编译）。
运行方式：
1，<a href=”javascript:代码”>...
2，<script type=”text/javascript”>代码</script>
3，<script src=”xx.js” type=”text/javascript”></script>
代码有错误，浏览器会指出来的；

语法
注释&变量&数据类型
注释
// /**/
变量
var a,b=0,c; 
如果不使用var，程序会先查找上下文是否存在变量，不存在则定义一个；
数据类型
数值
5e2, 0x13, 014, Infinity正无穷（数值超过范围）;
与(_-^+)Infinity运算得NaN，(_-^+)Infinity各自相等，两个NaN不相等，0/0得NaN，(_-^+)x/0得(_-^+)Infinity；
Number.MAX_VALUE, POSITIVE_INFINITY, NAN...；
浮点数用差值比较（小于一个值即可认为相等）；
字符串
单/双引号一样，相邻使用了就一个单一个双；
JS以String类包装方法属性有：String()构造/charAt()指定索引字符/charCodeAt()指定索引字符的Unicode字符/length/toUpperCase()/toLowerCase()/fromCharCode()静态方法，Unicode转字符串/indexOf()字符串第一次出现位置/lastIndexOf()/substring()/slice()返回子串/match()正则匹配子串/search()正则匹配子串/concat()拼接/split()分隔/replace()；
s.slice(0,-1)取第一个到最后一个字符的串；
s.charCodeAt(n)取第n个字符的Unicode值，汉字是1个长度；
a = s.match(/[a-z]+@d.m/g);search 返回索引/-1，match返回子字符串/数组（使用g）/null；
布尔值
true，false；
undefined&null
undefined表示不存在或未分配值，null是存在，只是值为空；
undefined == null 返回true，undefined === null 返回false；
对象
内置对象有：Array数组/Data日期/Error错误/Function函数/Math数学/Number数值/Object对象/String字符串；
数组
var a=[3,3.14,”str”];  var b = new Array();  c[100]=’a’;
不会越界，未赋值元素返回undefined，类型可以不同；
函数
可以当一个函数/类/对象，代码复用的基础；
 


类型转换
隐式：
值         	目标类型
	字符串	数值	布尔型	对象
undefined	“undefined”	NaN	false	Error
null	“null”	0	false	Error
字符串	不变	数值或NaN	true	String
空字符串	不变	0	false	String
0	“0”	0	false	Number
NaN	“NaN”	NaN	false	Number
Infinity	“Infinity”	Infinity	true	Number
-Infinity	“-Infinity”	- Infinity	true	Number
数值	数值字符串	不变	true	Number
true	“true”	1	不变	Boolean
false	“false”	0	不变	Boolean
对象	toString()返回值	valueOf(),toString()或NaN	true	不变
隐式虽然方便，但可读性非常差，比如var a = “3.14”; var b = a – 2;//a转成数字 var c=a+2//2转成字符串；
显示：
toStirng()，parseInt()，parseFloat()；
运算符
大致同c++；
赋值：=；
算术：+ - * / % Math对象方法，++--，+&>>=。
位运算：&|~<< >>  >>>无符号；
比较：!=值不等，!==类型和值都不等，===严格相等；
逻辑：&&||!；
三目：?:；
逗号：表达式返回最右边的值；
void：强行指定表达式不会返回值，如：a = void(b=5,c=7);   a=undefined;
typeof/instanceof：typeof(a)或typeof a，返回数据类型，
数据值	返回类型
undefined	undefined
null	object
布尔值	boolean
数字	number
字符串	string
对象	object
函数	function
instanceof变量是否为某个类的实例，如：a instanceof Array;

语句
语句块：{}，不能作为变量的作用域的；
异常：js异常都是Error对象，使用throw new Error(errString);抛出异常，机制和c++类似，寻找catch，找不到就给浏览器，程序终止；
try{} catch(e){} finally{}
try后只能有一个catch，e.message就是errString；
with：避免重复书写对象， with(object){ }，如：
with(document){ wirteln(); getElementById(); } //省略了document.
流程控制：大致同c++，if-else，switch，do-while，for，break，continue，
for in遍历元素或者对象的属性，for(索引/属性 in object) {}
break/continue 标识符; 跳转到标识处，如
outer: 
for(...){ for(...) { break outer; }}


函数
定义&调用&参数
定义
1）function 名(参数列表){ }   //同时定义了函数、对象、方法、类
2）var f = function(参数列表){};  //匿名函数，只定义一个函数对象
可以定义局部函数（函数内定义）；

调用
直接调用：obj.method();
call调用
var each = function(arr, fn) {
	var i = ..;
fn.call(null, i); //函数.call(调用者，参数1，...);null是window对象
}
函数.call(调用者，参数1，...)  = 调用者.函数(参数1，...)
apply调用
和call大致相同；
var f = function(a,b){}
var g = function(m,n){ f.apply(this, arguments); } //用arguments代表传入的所有参数，其实它是一个数组，所以f.apply(window, [12,23]); 也是对的；

参数
按值传递，只是复合类型它本身就是一个引用；
参数在调用的时候可以不传，它的值是undefined；
由于js是弱类型，因此编写健壮代码有时候要这样：if(typeof xxx == “object” && typeof xxx.nn == “number”){}


函数、对象、方法、类
定义一个函数，同时定义了函数、对象、方法、类；
var test = function(name){ return “你好,”+name; }
var rval = test(“myn”); //函数
var obj = new test(“myn”); //同名的类构造

function Person(name, age){
	this.name = name; //this，对象成员
	Person.age = age; //类名，static成员，用Person.age访问
	this.info = function(){ ... } //成员方法，方法附加到对象，默认附加到window对象上
}
var p = new Person(“myn”,26);
p.info();
p.weight = 120; //动态增加属性

对象的本质是一个map，key是成员属性名/成员函数名，可以用obj[name]访问；


函数是一等公民，就算它定义为成员方法，也不会从属于其他类、对象；
function Dog(name,age,bark){
	this.name = name; this.age = age; this.bark = bark;
	this.info = function() { return this.name; }
}
var dog = new Dog(“旺财”,3,”汪汪”);
function Cat(name,age){
	this.name = name ; this.age = age;
}
var cat = new Cat(“甜心”,2);
alert(dog.info.call(cat));  //dog.info翻译为Dog类的info函数，call(cat)翻译为this变成了cat;

没有继承；
都是Object类的子类，可以动态的添加属性和方法；
function Person(name, age){
	this.info = function(){ } //这种定义方式每次创建对象时，都会创建一个info函数，导致系统有多个info函数，性能低下；
}
模仿继承：为类的prototype属性添加函数、属性；
Person.prototype.Fun1 = function(p1){ }
扩展后才起作用，之前的对象没用；

JSON创建对象/数组
var object = {
	属性n : 值n,
	...
};
var arr = [值n,...];
如：
person = {
	name:”myn”,
son : { //看到{}是对象
	name:”hh”, //看到:是属性值
	grade:1
},
info:function(p1){ ... }
}

DOM
概念
文档模型，提供访问、修改文档的编程接口，浏览器厂商都内置DOM解析器：将磁盘上的文档（xml/html等）转换成内存中的DOM树，当浏览器加载html时，内存中已经有DOM树了；
js提供的接口
简要
js用对象封装标签，Node、Document、Element、HTMLElement四个父类，其他子类：HTMLDocument整个文档/HTMLBodyElement<body>控件/HTMLDivElement/Form/Select/Option/IFrame/InputFrame/Table.....；

访问
简要
1）document.getElementById(id); //返回HTMLXxx对象
2）Node parentNode父节点/previousSibling上一个兄弟节点/nextSibling/Node[] childNodes所有子节点/Node[] getElementsByTagName(tagName)具有指定标签名的所有子节点/firstChild/lastChild
换行、空白等，也会被HTML当作节点！

表单&列表框&表格
HTMLFormElement，额外属性有：action/elements全部表单控件的数组/length=elements.length/method/target；额外方法：reset()/submit()；
elements是一个HTMLCollection对象，它既可以当数组（索引）也可以当map（key值），如elements[“pass”]控件name或id值=”pass”的，如果有多个，继续返回elements，很多返回对象数组的地方其实都是它；
访问表单元素：elements[i]，elements[“name/id”]/，HTMLFormElement.name/id；

HTMLSelectElement，额外属性：form表单对象/length/options选项数组/selectedIndex选中索引/type类型select-multiple或select-one；
访问列表框元素：select.options[i]，HTMLOptionElement，属性有：form/defaultSelected是否默认选中/index/selected是否被选中/text/value；

HTMLTableElement，额外属性：caption/rows/tBodies/tFoot/tHead；
访问表格元素：table.rows[i]，HTMLTableRowElement，属性：cells/rowIndex/sectionRowIndex该行索引，HTMLTableCellElement单元格，cellIndex该单元格索引；

增删改
修改属性
属性：innerHTML当元素开始结束标签之间只是字符串时，元素内容，但将其置为null也会删除控件所有选项/value表单控件内容/className选择器/style修改内联css；

增加节点
document.createElement(“div”);
Node cloneNode(boolean deep); //开销略小
appendChild(Node); 
insertBefore(Node, Node 参照节点);
replaceChild(Node, Node old);

HTMLSelectElement有add方法：add(HTMLOptionElement, HTMLOptionElement before)，before=null追加 或者var op = new Option(...);  a.options[i] = op；
HTMLTableElement有如下方法：
insertRow(index)在索引处插入一行，返回HTMLTableRowElement，CreateCaption/CreateTFoot/createTHead/insertCell(index)；


删除节点
removeChild(Node)删除Node子节点；
HTMLSelectElement有remove方法，或者 options[i] = null; 或者 innerHTML=null;
HTMLTableElement有deleteRow，deleteCell；

window&document对象
全局变量在其内，只是在window内，如果一个页面有多个frame（多个window），它们互不影响；
属性/方法：alert()/confirm()/prompt()弹出警告确认和提示输入对话框/close()关闭窗口/focus()/blur()让窗口获得失去焦点/moveBy()/moveTo()移动窗口/open()打开新窗口/print()打印窗口/resizeBy()/resizeTo()重设窗口/scrollBy()/scrollTo()滚动文档/setInterval()/clearInterval()定时器每隔/setTimeout()/clearTimeout()定时器执行一次/closed/defaultStatus/status状态栏的文本/document/frames[]/history浏览历史/location文档URL/name窗口名字/navigator浏览器/parent返回本frame的直接父窗口/screen屏幕对象/self/top返回包含本frame的顶级窗口；
history是History对象，方法：back()/foward()/go(i)前进后退多少页；
location对象，方法：hostname主机名/href/host/port/pathname/protocol
screen对象，属性：width/height/colorDepth；
confirm()点击确定返回true，prompt()返回字符串；
open()语法，略；
setInterval(“code”,ms)/clearInterval(timer);
Navigator对象，appName内核名/appVersion浏览器版本/platform所在操作系统/
geolocation地理对象，方法：getCurrentPosition(成功回调，失败回调，可选参数)/int watchCurrentPosition()持续监听地理位置，返回监听器id/clearWatch(id)；
回调函数形如：function(position){}，position对象属性：timestamp/coords是Coordinates对象，属性：longitude/latitude/altitude高度值/accuracy精度m/altitudeAccuracy/speed浏览器所在设备的移动速度/heading设备移动方向/timestamp；
失败回调：function(error){} ，error属性：code错误代码：用户拒绝、无法获取、超时/message错误描述；
额外选项，一个js对象，包含属性：enableHighAccuracy是否要求高精度/timeout超时时长/maximumAge地理位置的缓存时间；


document方法属性：close()/open()打开关闭document对象/write()/writeln()输出字符串/alinkColor/linkColor/vlinkColor/bgColor/fgColor超链接激活、没访问过、访问过、前景背景色/all所有子元素/anchors所有命名锚点/applets所有Applet/cookie/documentElement返回html节点/forms所有表单/frames所有frame/images所有图像/lastModified/links/location/referrer上一个页面url/scripts所有脚本/styleSheets所有css/title/URL；

cookie
name=value对，可以是服务器传给浏览器，浏览器写入磁盘，也可以是浏览器读取，传给服务器；
name可以任意指定，有几个内置的：max-age存活时间s/expires过期时间/path路径/domain域/secure安全属性；

事件
简要
绑定元素
<标签 onXXX=”js code1; js code2; …”/>
坏处：修改了html元素和html页面；
绑定DOM对象属性
在js中，document.form[0].onsubmit = check; //事件属性绑定函数引用；
事件一览
onabort中断/onblur失去焦点/onchange/onclick/ondblclick/onerror出错/onfocus/onkeydown/onkeypress/onkeyup/onload装载完毕/onmousedown/onmousemove/onmouseout/onmouseover/onmouseup/onreset重置表单/onresize/onselect选择文本/onsubmit/onunload；
改变事件的默认行为
return false; confirm();等方法，让其返回false；
元素：click，dragdrop，keydown等等；
触发事件
监听器 或者 代码手动触发（调用元素的submit()/click()/blur()/select()等方法）；

Internet Exporer事件机制
绑定
1，<script for="btn" event="onclick" type="text/javascript">
		alert("abc");  </script> //每个元素对应一个script for；
2，attachEvent
obj.attachEvent(“onclick”, 函数);//event自动传入
obj.detachEvent(“onclick”, 函数);//删除事件处理器

访问事件对象
事件对象封装了详细信息，IE中的事件对象是个全局对象：event，属性：type类型，”click”等/srcElement发生事件的元素/clientX鼠标x坐标/offsetX鼠标相对事件源元素坐标/button哪个鼠标键/keyCode键盘键/altKey/ctrlKey/shiftKey是否按下了/cancelBubble阻止冒泡/returnValue事件处理函数的返回值/fromElement /toElement鼠标移出移入的元素，对mouseover/mouseout有效；
事件冒泡
向父节点传递，依次调用事件处理函数，表单提交/获得焦点等没有冒泡，通过event对象的cancelBubble=true阻止；
转发事件
事件在不同节点跳跃，如转发到子节点，或者根本不在DOM上的其它节点；
event.cancelBubble=true;
target.fireEvent(“onclick”, event); //将事件重定向到target上；
事件捕获
事件分捕获和冒泡阶段，如果事件被捕获了，那它就不会冒泡，直接触发事件处理器直到调用release或捕获中断（浏览器失去焦点弹框显示系统菜单等），onlosecapture监听！
target.setCapture()/releaseCapture();

DOM事件机制
绑定
obj.addEventListener(“click/mousedown”, hander, captureFlag,true捕获false冒泡);
removeEventListener
访问事件对象
DOM发生事件会隐式创建一个Event对象，并作为事件处理器的第一个参数传入，因此，写跨浏览器的代码，就需要多个分支；
DOM事件接口
Event，MouseEvent，UIEvent，MutationEvent等，继承体系，有相应的事件；

事件属性
Event：type，”click”/target事件源/currentTarget事件当前所在的事件源/eventPhase，Event.CAPTURING_PHASE等/timeStamp发生时间/bubbles支持冒泡否/cancelable有默认行为否；
UIEvent：view返回window对象/detail数字，1单击2双击等；
MouseEvent：button数字，0鼠标左等/atlKey等/clientX文档坐标/screenX屏幕坐标/relatedTarget相关元素；
事件捕获&冒泡
 
阻止传播&取消默认行为
event.stopPropagation();
event.preventDefault();

转发事件
target.dispatchEvent(Event); Node对象方法，不能转发系统事件，创建人工事件的方法：document.createEvent(“Events/UIEvents/MouseEvents”);
得到事件对象后，initEvent(“click事件类型”,是否支持冒泡,是否有默认行为); initUIEvent(1,2,3,view,detail); intiMouseEvent(1,2,3,4,5,…);


本地存储与离线应用
概念
离线应用显式控制浏览器缓存哪些东西；Web Storage本地存储，离线状态下将用户提交的数据存储在本地，联网后集中提交；
cookie的不足：4KB；包含在每个http请求中，多次重复发送；

接口
Web Storage分Session和Local，Session数据与用户Session（关闭浏览器或离开网页）相同，Local保存在磁盘；
window.sessionStorage，window.localStorage属性，它们是接口实例，属性方法：length多少组key-value/key(i)/getItem(key)/set(key,value)/removeItem(key)/clear()；
存储结构化数据
JSON对象，JSON.parse(String)，JSON.stringify(JSObject);

离线应用
像w3c school网站，离线了还能点来点去，百度搜索在断网情况下就不能用了；

多线程
创建一个Worker对象，浏览器即可启动一个线程；
objWorker.postMessage(data)给线程发送数据；
onmessage事件监听，收到线程数据；
示例：
<script type="text/javascript">
		var w = new Worker("worker.js");
		w.onmessage = function(event){
			document.getElementById("result").innerHTML += event.data + ",";
		};	
	</script>

worker.js
onmessage = function(event){ }  //线程挂起，直到postMessage

注意：
chrome不允许new Worker("worker.js")这样，会报错，用来测试的js和html文件都需要发布到站点才可以正常访问；
不能使用DOM API修改前台，可用的api有：onmessage, postMessage,importScripts(“a.js”,”b.js”)导入执行脚本，sessionStorage/localStorage，Worker嵌套，XMLHttpRequest异步请求，navigator一个WorkerNavigator对象，location一个WorkerLocation对象，self，其它与界面无关的api；

网络
跨文档消息传递
多个html（web应用）；
targetWindow.postMessage(message, targetOrigin) //发送消息
onmessage = function(event) //接收消息
event是一个MessageEvent对象，属性：data信息/origin源域名/lastEventId发送消息的事件id/source发送消息的窗口

WebSocket
方法：send向服务器发送数据/close关闭连接；
监听器：onopen建立连接时/onerror连接出错/onclose/onmessage接收到服务器的数据；
socket状态：readyState属性，CONNECTING/OPEN已连接/CLOSING/CLOSED；

握手协议。。。；


webprj练手
 
1,2,3用了<ul>，因为有index属性，css里修改它的盒模型能成这样（css什么不能改？），js里修改元素样式就要访问className属性，所以css里大多按class编辑样式！



日志
相关链接：
云栖社区：https://yq.aliyun.com/articles/2620，
c++日志库：boost::log 和 google-glog，
boost::log
boost::log 的设计主要有日志器（ Logger ）、日志核心（ Logging core ）、 日志接收器Sink 前后端（ frontend, backend ）组成。
日志文本以及日志环境由日志器负责搜集，日志核心负责处理日志数据（例如全局过滤、将日志记录传递给 Sink ）， Sink 前端（同步异步等）负责将日志记录传递给 Sink 后端处理。 Sink 后端负责把日志记录格式化并输出到不同的介质中（例如日志文件、报警以及统计源中）。
日志器（收集）-》日志核心（处理）-》Sink前端（传递）-》Sink后端（输出），
key words
Log record、Attribute、Log sink、Log source、Log filter、Log formatter、Logging core。。。
 


boost::log功能
	严重性分级
默认：trace, debug, info, warning, error, fatal，可自定义，
	日志过滤 Log filter
支持两层过滤，可以通过 core::set_filter 设置全局过滤器，也能通过 sink::set_filter 设置 sink 过滤器，配合lambda或者函数对象， boost::log 可以生成无论多么复杂的过滤器。（例如只把某个级别的日志写入文件，或者把统计日志、 trace 日志分别重定向到不同的 sink 中，然后输出到不同的介质）。
	线程安全
boost::log 支持 同步和异步 sink
	自定义属性 Attribute
有时程序需要记录的信息 包含执行环境的一些属性（例如网络对端的 IP 地址）。 boost::log 提供了 属性集 功能，属性集不仅仅包括常用的数据（例如计数器、时间、计时器、线程 ID 等信息）还支持自定义属性。用户可以将程序的任意上下文放入日志记录对象中，然后在 sink 中进行处理。
	滚动日志
boost::log 则支持不同的 sink 按照文件大小、时间等参数来 旋转 。
	支持宽字符：sink 可以通过设置 locale 进行必要的编码转换。
	参数配置：boost::log 可以针对不同 sink 设置不同参数。
	格式化：传递一个 formatter 对象给 sink 即可。 Log formatter
	boost::log 提供很多使用小工具，例如支持日志排序、输出操作、 binary dump 操作（ logging::dump(packet.data(), packet.size() 对于输出内存块很方便）。
	boost::log 支持从 配置文件 中读取日志配置信息，可以通过修改配置文件来修改日志过滤器、格式等配置。
	对于不同的输出方式， boost::log 提供了一些现成的 sink backend ，例如输出到 Windows 事件日志、调试器、 Linux syslog 接口、文本文件等。


glog相对简单，可参考链接：云栖社区，


boost_1_63_0版本log库
file:///E:/maoyinan/prj/boost_1_63_0/libs/log/doc/html/index.html，
Trivial logging  简单日志
<boost\log\trivial.hpp>
main : BOOST_LOG_TRIVIAL(trace) << "trace severity";
 
时间戳、线程id（Process Explorer）、严重级别

过滤日志
过滤严重级别
<boost\log\core.hpp>
<boost\log\trivial.hpp>
<boost\log\expressions.hpp>
namespace logging = boost::log;
main() :
	logging::core::get()->set_filter //设置日志核心（单例）的过滤函数
	(
		logging::trivial::severity >= logging::trivial::info
	);

更灵活的日志处理——log sink
boost::log库提供一个默认sink，在你没有向Logging core注册任何sink之前可以输出上面的那种固定格式的日志，
将日志改为输出到文件
<boost\log\utility\setup\file.hpp>
logging::add_file_log("sample.log");//日志.log 支持中文

限制日志文件
namespace sinks = boost::log::sinks;
namespace keywords = boost::log::keywords;
	logging::add_file_log(
		keywords::file_name = "日志_%N.log",
		keywords::rotation_size = 10 * 1024 * 1024,//10M
		keywords::time_based_rotation = sinks::file::rotation_at_time_point(0, 0, 0),//0点旋转文件
		keywords::format = "[%TimeStamp%]: %Message%"
	);

//支持中文
std::locale loc = boost::locale::generator()("en_US.UTF-8");
		sink->imbue(loc);

一个sink绑定多个输出 和 注册多个sink绑定到一个输出
<boost/smart_ptr/shared_ptr.hpp>
<boost/smart_ptr/make_shared_object.hpp>
<boost/log/core.hpp>
<boost/log/trivial.hpp>
<boost/log/sinks/sync_frontend.hpp>
<boost/log/sinks/text_ostream_backend.hpp>
<boost/log/sources/logger.hpp>
<boost/log/sources/record_ostream.hpp>
<boost/core/null_deleter.hpp>
namespace logging = boost::log;
namespace src = boost::log::sources;
namespace sinks = boost::log::sinks;
void init()
{
	/*frontend线程同步、过滤、格式化等任务， 
	backend输出，库提供很多，有syslog，NT event log，
	*/
	typedef sinks::synchronous_sink< sinks::text_ostream_backend > text_sink;
	//声明一个接收器sink
	boost::shared_ptr< text_sink > sink = boost::make_shared< text_sink >();
	// 给接收器绑定文件流（日志输出的地方）
	//locked_backend 访问backend，
	sink->locked_backend()->add_stream(
		boost::make_shared< std::ofstream >("sample.log"));
	// 绑定标准输出流
	boost::shared_ptr< std::ostream > stream(&std::cout, boost::null_deleter());
	sink->locked_backend()->add_stream(stream);
	//绑定到其他
	sink->locked_backend()->add_stream(
		boost::make_shared< std::ofstream >("备份日志.log"));
	// 把接收器注册到核心
	logging::core::get()->add_sink(sink);
}
main：
	init();
	src::logger lg; //日志器
	BOOST_LOG(lg) << "Hello myn!"; //收集日志

日志器
全局日志器
<boost/log/sources/global_logger_storage.hpp>
BOOST_LOG_INLINE_GLOBAL_LOGGER_DEFAULT(my_logger, src::logger_mt)
src::logger_mt& lg = my_logger::get();
BOOST_LOG(lg) << "mao"; //输出到console logging::add_file_log("sample.log");输出到文件

级别日志器
using namespace logging::trivial;
src::severity_logger< severity_level > lg;
BOOST_LOG_SEV(lg, trace) << "A trace severity message";

属性
公共属性
<boost/log/utility/setup/common_attributes.hpp>
logging::add_common_attributes();

对于自定义sink，库是不会加入公共属性的，
属性可以加入core、日志器，只有指定了formatter 才会输出，

添加自定义属性
？

格式化
日志记录的格式化
<boost/log/expressions.hpp>
namespace expr = boost::log::expressions;
void init()
{
	logging::add_file_log
	(
		keywords::file_name = "sample_%N.log",
		keywords::rotation_size = 10 * 1024 * 1024,
		keywords::time_based_rotation = sinks::file::rotation_at_time_point(0, 0, 0),
		//keywords::format = "[%TimeStamp%]: %Message%"
		keywords::format =
		(
			expr::stream
			<< expr::attr< unsigned int >("LineID")
			<< ": <" << logging::trivial::severity
			<< "> " << expr::smessage
			)
	);
}

手动设置sink格式
	sink->set_formatter
	(
		expr::stream
		// line id will be written in hex, 8-digits, zero-filled
		<< std::hex << std::setw(8) << std::setfill('0') << expr::attr< unsigned int >("LineID")
		<< ": <" << logging::trivial::severity
		<< "> " << expr::smessage
	);

有多种格式化方法，lambda、字符串，Boost.Format，函数。。。


日志过滤
<boost/log/core/record.hpp> 


可记录的信息
日志所在的主机名，ip，进程id，
创建的各个线程id，日志发生时间，日志编号，
日志对齐，文件名，行号，
分隔符，缩进，日志信息，
分类标签，

可控制的
缓存大小，实时刷新，文件大小，输出目录，

日志查看器
添加颜色，分类，搜索，收缩。。。



